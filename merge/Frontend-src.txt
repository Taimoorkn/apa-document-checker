// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary: #3b82f6;
  --secondary: #10b981;
  --accent: #8b5cf6;
  --error: #ef4444;
  --warning: #f59e0b;
  --background: #ffffff;
  --text: #1f2937;
}

/* Base styling */
body {
  color: var(--text);
  background-color: var(--background);
}

/* Typography */
h1, h2, h3, h4, h5 {
  font-family: 'Inter', sans-serif;
}

body {
  font-family: 'Roboto', sans-serif;
}

/* APA styling for document viewer */
.prose {
  font-family: 'Times New Roman', Times, serif;
  font-size: 12pt;
  line-height: 2;
  max-width: none;
}

/* Issue highlighting styles */
mark[data-issue-id] {
  border-radius: 2px;
  cursor: pointer;
  padding: 0 1px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

mark[data-issue-id]::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform 0.3s ease;
}

mark[data-issue-id]:hover::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

.bg-red-200 {
  background-color: rgba(254, 202, 202, 0.7);
  border-bottom: 2px solid var(--error);
}

.bg-red-200:hover {
  background-color: rgba(254, 202, 202, 0.9);
}

.bg-red-200::after {
  background-color: var(--error);
}

.bg-orange-200 {
  background-color: rgba(254, 215, 170, 0.7);
  border-bottom: 2px solid var(--warning);
}

.bg-orange-200:hover {
  background-color: rgba(254, 215, 170, 0.9);
}

.bg-orange-200::after {
  background-color: var(--warning);
}

.bg-blue-200 {
  background-color: rgba(191, 219, 254, 0.7);
  border-bottom: 2px solid var(--primary);
}

.bg-blue-200:hover {
  background-color: rgba(191, 219, 254, 0.9);
}

.bg-blue-200::after {
  background-color: var(--primary);
}

/* Active issue highlighting */
.active-issue {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  animation: pulse 2s infinite;
}

/* Custom animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
  100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Animation utilities (fallback for older Tailwind versions) */
.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 0.3s ease-out forwards;
}

.animate-pulse-blue {
  animation: pulse 2s infinite;
}

/* Apply animations to components */
.issue-category {
  animation: fadeIn 0.4s ease-out;
}

.issue-item {
  animation: slideIn 0.3s ease-out;
}

/* Staggered animations for issue items */
.issue-item:nth-child(1) { animation-delay: 0.05s; }
.issue-item:nth-child(2) { animation-delay: 0.1s; }
.issue-item:nth-child(3) { animation-delay: 0.15s; }
.issue-item:nth-child(4) { animation-delay: 0.2s; }
.issue-item:nth-child(5) { animation-delay: 0.25s; }

/* Custom utility classes */
.hover-shadow:hover {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-grow:hover {
  transform: scale(1.02);
}

/* Loading spinner */
.loading-spinner {
  border: 3px solid rgba(59, 130, 246, 0.1);
  border-radius: 50%;
  border-top: 3px solid var(--primary);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\layout.js
import './globals.css'
import ErrorBoundary from '@/components/ErrorBoundary'

export const metadata = {
  title: 'APA 7th Edition Document Checker',
  description: 'Validate academic documents against APA 7th edition guidelines',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
      </head>
      <body className="font-sans antialiased text-gray-800 bg-gray-50">
        <ErrorBoundary showDetails={process.env.NODE_ENV === 'development'}>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\page.js
'use client';
import './globals.css';
import { useState } from 'react'; 
import IssuesPanel from '@/components/IssuesPanel';
import Header from '@/components/Header'; 
import { BookOpen } from 'lucide-react';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import DocumentViewer from '@/components/DocumentViewer';

export default function Home() {
  const [splitRatio, setSplitRatio] = useState(60);
  const { documentText, issues } = useDocumentStore();

  return (
    <main className="flex flex-col h-screen bg-gray-100">
      <Header />
      
      <div className="flex-1 flex overflow-hidden">
        {/* Document Viewer (left panel) */}
        <div 
          className="relative bg-white border-r border-gray-300"
          style={{ width: `${splitRatio}%` }}
        >
          <DocumentViewer />
        </div>
        
        {/* Resize handle */}
        <div 
          className="w-1 bg-gray-300 hover:bg-blue-400 cursor-col-resize transition-colors relative group"
          onMouseDown={(e) => {
            const startX = e.clientX;
            const startWidth = splitRatio;
            
            const handleMouseMove = (moveEvent) => {
              const containerWidth = document.body.clientWidth;
              const newWidth = startWidth + ((moveEvent.clientX - startX) / containerWidth * 100);
              
              // Constrain between 35% and 75%
              const constrainedWidth = Math.max(35, Math.min(75, newWidth));
              setSplitRatio(constrainedWidth);
            };
            
            const handleMouseUp = () => {
              document.removeEventListener('mousemove', handleMouseMove);
              document.removeEventListener('mouseup', handleMouseUp);
            };
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          }}
        >
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 opacity-0 group-hover:opacity-100 transition-opacity">
            <div className="flex flex-col space-y-1">
              <div className="w-1 h-1.5 bg-white rounded-full"></div>
              <div className="w-1 h-1.5 bg-white rounded-full"></div>
              <div className="w-1 h-1.5 bg-white rounded-full"></div>
            </div>
          </div>
        </div>
        
        {/* Issues Panel (right panel) */}
        <div 
          className="bg-white border-l border-gray-300"
          style={{ width: `${100 - splitRatio}%` }}
        >
          <IssuesPanel />
        </div>
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\DocumentViewer.js
'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import { FileText, InfoIcon } from 'lucide-react';

export default function DocumentViewer() {
const { documentText, documentHtml, activeIssueId, issues, setActiveIssue, lastFixAppliedAt, processingState, documentFormatting } = useDocumentStore();
  const viewerRef = useRef(null);
  // Use processing state from store instead of local loading state
  const isLoading = processingState.isUploading || processingState.isAnalyzing;
  const [lastContentUpdate, setLastContentUpdate] = useState(null);
  
  // Add a state for showing/hiding issues
  const [showIssues, setShowIssues] = useState(true);
  
  
  // Function to apply highlighting to the document
  const applyHighlighting = useCallback(() => {
    if (!viewerRef.current || !documentHtml || !issues || !showIssues) {
      console.log('Cannot apply highlighting, missing prerequisites');
      return;
    }
    
    console.log('Applying highlighting to document with', issues.length, 'issues');
    
    // First, reset any existing highlighting and remove event listeners to prevent memory leaks
    const existingMarks = viewerRef.current.querySelectorAll('mark[data-issue-id]');
    existingMarks.forEach(mark => {
      // Clone the mark without event listeners to prevent memory leaks
      if (mark.parentNode) {
        const textContent = mark.textContent;
        const textNode = document.createTextNode(textContent);
        mark.parentNode.replaceChild(textNode, mark);
      }
    });
    
    // Track created marks so we can efficiently handle cleanups later
    const createdMarks = [];
    
    // Now apply new highlighting
    for (const issue of issues) {
      if (!issue.text) continue;
      
      // Find all text nodes in the document
      const allTextNodes = [];
      const walker = document.createTreeWalker(
        viewerRef.current,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      let node;
      while ((node = walker.nextNode())) {
        allTextNodes.push(node);
      }
      
      // Look for the issue text in these nodes
      for (const textNode of allTextNodes) {
        const content = textNode.textContent;
        const index = content.indexOf(issue.text);
        
        if (index === -1) continue;
        
        try {
          // Found a match, split the node and highlight
          const range = document.createRange();
          range.setStart(textNode, index);
          range.setEnd(textNode, index + issue.text.length);
          
          // Create a mark element
          const mark = document.createElement('mark');
          mark.setAttribute('data-issue-id', issue.id);
          mark.setAttribute('data-issue-title', issue.title);
          mark.setAttribute('data-issue-explanation', issue.explanation || issue.description || 'APA formatting issue detected');
          mark.className = getIssueClass(issue.severity);
          
          // Wrap the text in the mark
          range.surroundContents(mark);
          
          // Use a data attribute instead of direct event listener
          // This makes the DOM element serializable and prevents memory leaks
          mark.setAttribute('data-clickable', 'true');
          
          // Track created marks
          createdMarks.push(mark);
          
          // Only highlight the first occurrence
          break;
        } catch (error) {
          console.error('Error highlighting text:', error);
          // Continue with next node if there's an error
          continue;
        }
      }
    }
    
    // Add delegated event listeners at the container level for better performance
    // and to avoid memory leaks from multiple individual listeners
    if (viewerRef.current) {
      // Remove existing event handlers
      viewerRef.current.removeEventListener('click', handleMarkClick);
      viewerRef.current.removeEventListener('mouseenter', handleMarkHover, true);
      viewerRef.current.removeEventListener('mouseleave', handleMarkLeave, true);
      
      // Add new event handlers
      viewerRef.current.addEventListener('click', handleMarkClick);
      viewerRef.current.addEventListener('mouseenter', handleMarkHover, true);
      viewerRef.current.addEventListener('mouseleave', handleMarkLeave, true);
    }
    
    // Highlight the active issue with a special class
    if (activeIssueId) {
      const activeMark = viewerRef.current.querySelector(`mark[data-issue-id="${activeIssueId}"]`);
      if (activeMark) {
        activeMark.classList.add('active-issue');
        // Scroll to active issue
        activeMark.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
    
    return () => {
      // Clean up event listeners when component unmounts or before re-applying
      if (viewerRef.current) {
        viewerRef.current.removeEventListener('click', handleMarkClick);
        viewerRef.current.removeEventListener('mouseenter', handleMarkHover, true);
        viewerRef.current.removeEventListener('mouseleave', handleMarkLeave, true);
      }
    };
  }, [documentHtml, issues, showIssues, activeIssueId]);
  
  // Event handler for mark clicks using event delegation
  const handleMarkClick = useCallback((event) => {
    // Find the closest mark element from the click target
    const mark = event.target.closest('mark[data-issue-id][data-clickable="true"]');
    if (mark) {
      const issueId = mark.getAttribute('data-issue-id');
      if (issueId) {
        setActiveIssue(issueId);
      }
    }
  }, [setActiveIssue]);
  
  // Event handler for mark hover using event delegation
  const handleMarkHover = useCallback((event) => {
    // Tooltip functionality removed - placeholder for potential future functionality
  }, []);
  
  // Event handler for mark leave using event delegation
  const handleMarkLeave = useCallback((event) => {
    // Tooltip functionality removed - placeholder for potential future functionality
  }, []);
  
  // Main useEffect for handling document HTML changes and initial load
  useEffect(() => {
    let mainTimeoutId;
    let highlightTimeoutId;
    
    console.log('DocumentViewer main effect running:', {
      hasDocumentHtml: !!documentHtml,
      htmlLength: documentHtml?.length,
      issuesCount: issues?.length
    });
    
    if (documentHtml) {
      
      // Use a ref to track the current render cycle
      const renderCycleId = Date.now();
      if (viewerRef.current) {
        viewerRef.current.setAttribute('data-render-cycle', renderCycleId.toString());
      
        mainTimeoutId = setTimeout(() => {
          // Check if this is still the current render cycle
          if (viewerRef.current && viewerRef.current.getAttribute('data-render-cycle') === renderCycleId.toString()) {
            console.log('Document HTML ready for highlighting');
            
            // Apply highlighting after a short delay to ensure DOM is ready
            highlightTimeoutId = setTimeout(() => {
              // Double-check that we're still on the same render cycle before highlighting
              if (viewerRef.current && viewerRef.current.getAttribute('data-render-cycle') === renderCycleId.toString()) {
                const cleanup = applyHighlighting();
                // Store cleanup function for later use if needed
                if (cleanup && typeof cleanup === 'function') {
                  viewerRef.current.setAttribute('data-cleanup', 'available');
                }
              }
            }, 100);
          }
          
          // Loading state is now managed by store processing state
        }, 200);
      }
    }
    
    // Cleanup function
    return () => {
      if (mainTimeoutId) clearTimeout(mainTimeoutId);
      if (highlightTimeoutId) clearTimeout(highlightTimeoutId);
    };
  }, [documentHtml, applyHighlighting]);
  
  // Separate effect for handling issue changes (highlighting updates)
  useEffect(() => {
    if (documentHtml && !isLoading && viewerRef.current) {
      console.log('Issues or showIssues changed, updating highlighting');
      const highlightTimeout = setTimeout(() => {
        const cleanup = applyHighlighting();
        if (cleanup && typeof cleanup === 'function') {
          viewerRef.current.setAttribute('data-cleanup', 'available');
        }
      }, 50);
      
      return () => clearTimeout(highlightTimeout);
    }
  }, [issues, showIssues, applyHighlighting, isLoading, documentHtml]);
  
  // Separate effect for handling active issue changes (scrolling)
  useEffect(() => {
    if (activeIssueId && viewerRef.current && !isLoading) {
      console.log('Active issue changed to:', activeIssueId);
      
      // Small delay to ensure highlighting is applied first
      const scrollTimeout = setTimeout(() => {
        if (viewerRef.current) {
          // Remove previous active highlights
          const previousActive = viewerRef.current.querySelectorAll('.active-issue');
          previousActive.forEach(el => el.classList.remove('active-issue'));
          
          // Add active highlight and scroll to the new active issue
          const activeMark = viewerRef.current.querySelector(`mark[data-issue-id="${activeIssueId}"]`);
          if (activeMark) {
            activeMark.classList.add('active-issue');
            activeMark.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }
        }
      }, 100);
      
      return () => clearTimeout(scrollTimeout);
    }
  }, [activeIssueId, isLoading]);
  
  // Effect for handling fixes applied (content updates)
  useEffect(() => {
    if (lastFixAppliedAt && lastFixAppliedAt !== lastContentUpdate) {
      console.log('Fix was applied at:', lastFixAppliedAt, '- updating content');
      setLastContentUpdate(lastFixAppliedAt);
      
      // Ensure highlighting is reapplied after content changes
      if (viewerRef.current && !isLoading) {
        const updateTimeout = setTimeout(() => {
          const cleanup = applyHighlighting();
          if (cleanup && typeof cleanup === 'function') {
            viewerRef.current.setAttribute('data-cleanup', 'available');
          }
        }, 150);
        
        return () => clearTimeout(updateTimeout);
      }
    }
  }, [lastFixAppliedAt, lastContentUpdate, applyHighlighting, isLoading]);

  // Helper function to get issue class based on severity
  const getIssueClass = (severity) => {
    switch (severity) {
      case 'Critical':
        return 'bg-red-200 border-b-2 border-red-500 cursor-pointer';
      case 'Major':
        return 'bg-orange-200 border-b-2 border-orange-500 cursor-pointer';
      case 'Minor':
        return 'bg-blue-200 border-b-2 border-blue-500 cursor-pointer';
      default:
        return '';
    }
  };
  
  // Create dynamic styles based on actual document formatting
  const getDocumentStyles = useCallback(() => {
    const baseStyles = {
      fontFamily: '"Times New Roman", Times, serif',
      fontSize: '12pt',
      lineHeight: '2.0',
      color: '#111827'
    };
    
    // Use actual document formatting if available
    if (documentFormatting && documentFormatting.document) {
      const { font, spacing } = documentFormatting.document;
      
      console.log('ðŸŽ¨ Applying formatting - Font:', font, 'Spacing:', spacing);
      
      // Apply actual font family if available
      if (font && font.family) {
        const fontFamily = `"${font.family}", ${baseStyles.fontFamily}`;
        baseStyles.fontFamily = fontFamily;
        console.log('âœ… Font family applied:', fontFamily);
      }
      
      // Apply actual font size if available and is a valid number
      if (font && font.size && typeof font.size === 'number' && font.size > 0) {
        const fontSize = `${font.size}pt`;
        baseStyles.fontSize = fontSize;
        console.log('âœ… Font size applied:', fontSize);
      }
      
      // Apply actual line spacing if available and is a valid number
      if (spacing && spacing.line && typeof spacing.line === 'number' && spacing.line > 0) {
        const lineHeight = spacing.line.toString();
        baseStyles.lineHeight = lineHeight;
        console.log('âœ… Line spacing applied:', lineHeight);
      } else {
        // Use default double spacing for APA
        baseStyles.lineHeight = '2.0';
        console.log('ðŸ“„ Using default APA line spacing: 2.0');
      }
    }
    
    console.log('ðŸŽ¨ Final document styles:', baseStyles);
    return baseStyles;
  }, [documentFormatting]);

  // Add CSS for paragraph-specific indentation
  const addIndentationCSS = useCallback(() => {
    if (!documentFormatting || !documentFormatting.paragraphs) return;
    
    // Create dynamic CSS for paragraph indentation
    let indentCSS = '';
    documentFormatting.paragraphs.forEach((para, index) => {
      if (para.indentation && para.indentation.firstLine && para.indentation.firstLine > 0.1) {
        indentCSS += `.apa-document p:nth-of-type(${index + 1}) { text-indent: ${para.indentation.firstLine}in; }\n`;
      }
    });
    
    if (indentCSS) {
      // Remove existing indentation style
      const existingStyle = document.getElementById('paragraph-indentation-css');
      if (existingStyle) existingStyle.remove();
      
      // Add new indentation style
      const styleElement = document.createElement('style');
      styleElement.id = 'paragraph-indentation-css';
      styleElement.textContent = indentCSS;
      document.head.appendChild(styleElement);
      
      console.log('ðŸ“ Applied paragraph indentation CSS');
    }
  }, [documentFormatting]);

  // Effect for applying indentation CSS when document formatting changes
  useEffect(() => {
    if (documentFormatting && !isLoading) {
      const indentTimeout = setTimeout(() => {
        addIndentationCSS();
      }, 200);
      
      return () => clearTimeout(indentTimeout);
    }
  }, [documentFormatting, addIndentationCSS, isLoading]);

  // Add debug output for component state
  console.log('DocumentViewer render - documentText exists:', !!documentText, 'documentHtml:', !!documentHtml, 'isLoading:', isLoading, 'processingState:', processingState);
  console.log('Document formatting data:', documentFormatting);
  
  // Debug the actual values being applied
  if (documentFormatting && documentFormatting.document) {
    console.log('Font family:', documentFormatting.document.font?.family);
    console.log('Font size:', documentFormatting.document.font?.size);
    console.log('Line spacing:', documentFormatting.document.spacing?.line);
    console.log('Applied styles:', getDocumentStyles());
  }

  return (
    <div className="h-full flex flex-col">
      {documentText ? (
        <>
          {isLoading ? (
            <div className="flex-1 flex flex-col items-center justify-center bg-gray-50 p-8">
              <div className="bg-white rounded-2xl p-8 shadow-sm border border-gray-200 flex flex-col items-center">
                <div className="loading-spinner mb-6"></div>
                <h3 className="text-lg font-semibold text-gray-900 mb-2">Analyzing Document</h3>
                <p className="text-sm text-gray-500 text-center max-w-sm">
                  Checking your document against APA 7th edition guidelines...
                </p>
              </div>
            </div>
          ) : (
            <div className="h-full flex flex-col">
              {/* Document Controls - Fixed Header */}
              <div className="bg-white border-b border-gray-200 px-6 py-4 flex-shrink-0">
                <div className="flex justify-between items-center">
                  <div className="flex items-center space-x-4">
                    <h3 className="text-lg font-semibold text-gray-900">Document Review</h3>
                    {lastFixAppliedAt && (
                      <span className="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                        <div className="w-1.5 h-1.5 bg-green-400 rounded-full mr-1.5"></div>
                        Recently Updated
                      </span>
                    )}
                  </div>
                  <div className="flex items-center space-x-3">
                    <button 
                      onClick={() => setShowIssues(!showIssues)}
                      className={`flex items-center px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                        showIssues 
                          ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' 
                          : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                      }`}
                    >
                      {showIssues ? (
                        <>
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                            <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                          </svg>
                          Hide Issues
                        </>
                      ) : (
                        <>
                          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fillRule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z" clipRule="evenodd" />
                            <path d="M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z" />
                          </svg>
                          Show Issues
                        </>
                      )}
                    </button>
                    <div className="h-4 w-px bg-gray-300"></div>
                    <div className="text-xs text-gray-500">
                      {issues.length} {issues.length === 1 ? 'issue' : 'issues'} found
                    </div>
                  </div>
                </div>
              </div>

              {/* Document Content - Scrollable Area */}
              <div className="flex-1 overflow-auto bg-gray-50">
                <div className="p-6">
                  <div className="max-w-4xl mx-auto">
                    <div 
                      ref={viewerRef}
                      className="bg-white rounded-lg shadow-sm border border-gray-200 p-8"
                      style={getDocumentStyles()}
                    >
                      {documentHtml ? (
                        <div dangerouslySetInnerHTML={{ __html: documentHtml }} />
                      ) : (
                        <div className="text-center py-12">
                          <div className="bg-yellow-50 rounded-lg p-6 border border-yellow-200">
                            <h4 className="text-lg font-medium text-yellow-800 mb-2">Content Display Issue</h4>
                            <p className="text-sm text-yellow-700 mb-4">
                              Document loaded but HTML content could not be displayed.
                            </p>
                            <div className="bg-white p-4 rounded border border-yellow-200 text-left">
                              <p className="text-sm font-medium text-gray-700 mb-2">Raw text preview:</p>
                              <p className="text-xs text-gray-600 font-mono">
                                {documentText ? documentText.substring(0, 500) + (documentText.length > 500 ? '...' : '') : 'No text content available'}
                              </p>
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </>
      ) : (
        <div className="h-full flex flex-col items-center justify-center bg-gradient-to-br from-gray-50 to-blue-50 p-8">
          <div className="text-center max-w-md">
            <div className="w-24 h-24 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-2xl mx-auto mb-6 flex items-center justify-center shadow-lg">
              <FileText className="h-12 w-12 text-white" />
            </div>
            <h2 className="text-2xl font-bold text-gray-900 mb-3">Ready to Check Your Document</h2>
            <p className="text-gray-600 mb-8 leading-relaxed">
              Upload your academic paper and get instant feedback on APA 7th edition compliance
            </p>
            
            <div className="bg-white rounded-xl p-6 border border-gray-200 shadow-sm">
              <div className="flex items-start space-x-3">
                <div className="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center flex-shrink-0 mt-0.5">
                  <InfoIcon className="h-4 w-4 text-blue-600" />
                </div>
                <div className="text-left">
                  <p className="font-medium text-gray-900 mb-1">Supported Format</p>
                  <p className="text-sm text-gray-600">
                    Only <span className="font-medium">.docx files</span> are supported. Ensure your document is properly formatted for best results.
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ErrorBoundary.js
'use client';

import { Component } from 'react';
import { AlertTriangle } from 'lucide-react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // You can log the error to an error reporting service
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
    this.setState({
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <div className="flex flex-col items-center justify-center p-6 bg-red-50 border border-red-200 rounded-lg shadow-sm text-center">
          <div className="bg-red-100 p-3 rounded-full mb-4">
            <AlertTriangle className="h-8 w-8 text-red-500" />
          </div>
          <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-sm text-red-600 mb-4">
            {this.state.error ? this.state.error.toString() : 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
          >
            Reload Page
          </button>
          {this.props.showDetails && this.state.errorInfo && (
            <div className="mt-6 w-full">
              <details className="text-left">
                <summary className="text-sm font-medium text-red-800 cursor-pointer">Error Details</summary>
                <pre className="mt-2 p-3 text-xs text-red-800 bg-red-100 overflow-auto rounded-md">
                  {this.state.errorInfo.componentStack}
                </pre>
              </details>
            </div>
          )}
        </div>
      );
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\Header.js
'use client';

import { useState, useEffect, useRef } from 'react';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import { BookOpen, Upload, Download, File, AlertTriangle, ChevronDown, FileCheck, Sparkles } from 'lucide-react';

export default function Header() {
  const { 
    uploadDocument, 
    documentName, 
    analyzeDocument, 
    analyzeDocumentDebounced, 
    analysisScore, 
    exportDocument, 
    processingState
  } = useDocumentStore();
  
  // Local state for UI-only errors (now using store for processing state)
  const [uploadError, setUploadError] = useState(null);
  const [showExportDropdown, setShowExportDropdown] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const exportDropdownRef = useRef(null);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (exportDropdownRef.current && !exportDropdownRef.current.contains(event.target)) {
        setShowExportDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  const handleFileUpload = async (e) => {
    // Reset error state
    setUploadError(null);
    
    const file = e.target.files[0];
    if (!file) return;
    
    // Validate file type
    if (!file.name.endsWith('.docx')) {
      setUploadError('Please upload a .docx file only');
      return;
    }
    
    // Validate file size (max 10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB in bytes
    if (file.size > maxSize) {
      setUploadError(`File size exceeds limit (max ${maxSize / (1024 * 1024)}MB)`);
      return;
    }
    
    try {
      console.log('ðŸš€ Header: Starting upload process...');
      // Upload document (processing state is managed inside the store now)
      const success = await uploadDocument(file);
      console.log('ðŸ“¤ Header: Upload result:', success);
      
      if (success) {
        console.log('ðŸ“Š Header: Starting analysis...');
        // Only analyze if upload was successful
        // Use debounced analysis for better performance with large documents
        const analysisResult = await analyzeDocumentDebounced();
        console.log('ðŸ“Š Header: Analysis result:', analysisResult);
        
        // If analysis failed, display error
        if (!analysisResult?.success && analysisResult?.error) {
          console.log('âŒ Header: Analysis failed:', analysisResult.error);
          setUploadError(`Analysis error: ${analysisResult.error}`);
        } else {
          console.log('âœ… Header: Complete workflow finished successfully');
        }
      } else {
        console.log('âŒ Header: Upload failed');
        // If upload failed and store didn't set an error, set a generic one
        if (!processingState.lastError) {
          setUploadError('Failed to process document. Please try a different file.');
        }
      }
    } catch (error) {
      console.error('Error in file upload handler:', error);
      setUploadError(`Error: ${error.message || 'Failed to upload document'}`);
    } finally {
      // Reset file input to allow re-uploading the same file
      e.target.value = '';
    }
  };

  const handleExport = async (format) => {
    setIsExporting(true);
    setShowExportDropdown(false);
    
    try {
      await exportDocument(format);
    } catch (error) {
      console.error('Export failed:', error);
      alert(`Failed to export ${format.toUpperCase()} document. Please try again.`);
    } finally {
      setIsExporting(false);
    }
  };
  
  return (
    <header className="bg-white border-b border-gray-200 shadow-sm">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="py-4 flex justify-between items-center">
          {/* Brand Section */}
          <div className="flex items-center">
            <div className="flex items-center mr-8">
              <div className="bg-gradient-to-br from-blue-500 to-indigo-600 p-2.5 rounded-xl mr-3 shadow-md">
                <FileCheck className="h-7 w-7 text-white" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-gray-900 leading-none">APA Checker</h1>
                <p className="text-sm text-gray-500 font-medium">7th Edition</p>
              </div>
            </div>
            
            {/* Upload Section */}
            <div className="flex items-center space-x-4">
              <div className="relative">
                <label className={`
                  flex items-center px-6 py-3 rounded-xl font-medium text-sm transition-all duration-200 cursor-pointer
                  ${processingState.isUploading || processingState.isAnalyzing || processingState.isSchedulingAnalysis
                    ? 'bg-gray-100 text-gray-500 cursor-not-allowed' 
                    : 'bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white shadow-lg hover:shadow-xl transform hover:-translate-y-0.5'
                  }
                `}>
                  <Upload className={`h-5 w-5 mr-2.5 ${processingState.isUploading ? 'animate-pulse' : ''}`} />
                  {
                    processingState.isUploading ? 'Uploading...' : 
                    processingState.isSchedulingAnalysis ? 'Processing...' :
                    processingState.isAnalyzing ? 'Analyzing...' : 
                    'Upload Document'
                  }
                  <input
                    type="file"
                    accept=".docx"
                    className="hidden"
                    onChange={handleFileUpload}
                    disabled={processingState.isUploading || processingState.isAnalyzing || processingState.isSchedulingAnalysis}
                  />
                </label>
                
                {uploadError && (
                  <div className="absolute top-full left-0 mt-2 bg-red-50 border border-red-200 rounded-lg px-3 py-2 flex items-center text-sm text-red-700 shadow-sm min-w-max z-10">
                    <AlertTriangle className="h-4 w-4 mr-2 flex-shrink-0" />
                    {uploadError}
                  </div>
                )}
              </div>
              
              {documentName && (
                <div className="relative" ref={exportDropdownRef}>
                  <button 
                    className="flex items-center px-5 py-3 bg-white border border-gray-300 rounded-xl text-gray-700 font-medium text-sm hover:bg-gray-50 hover:border-gray-400 transition-all duration-200 shadow-sm hover:shadow-md"
                    onClick={() => setShowExportDropdown(!showExportDropdown)}
                    disabled={isExporting}
                  >
                    <Download className="h-4 w-4 mr-2" />
                    {isExporting ? 'Exporting...' : 'Export'}
                    <ChevronDown className="h-4 w-4 ml-2" />
                  </button>

                  {showExportDropdown && (
                    <div className="absolute right-0 top-full mt-2 w-56 bg-white border border-gray-200 rounded-xl shadow-xl z-50 overflow-hidden">
                      <div className="py-2">
                        <button
                          onClick={() => handleExport('html')}
                          className="flex items-center w-full px-4 py-3 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
                          disabled={isExporting}
                        >
                          <div className="w-8 h-8 bg-orange-100 rounded-lg flex items-center justify-center mr-3">
                            <File className="h-4 w-4 text-orange-600" />
                          </div>
                          <div className="flex-1 text-left">
                            <p className="font-medium">Export as HTML</p>
                            <p className="text-xs text-gray-500">Viewable in browser</p>
                          </div>
                        </button>
                        <button
                          onClick={() => handleExport('docx')}
                          className="flex items-center w-full px-4 py-3 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
                          disabled={isExporting}
                        >
                          <div className="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center mr-3">
                            <File className="h-4 w-4 text-blue-600" />
                          </div>
                          <div className="flex-1 text-left">
                            <p className="font-medium">Export as DOCX</p>
                            <p className="text-xs text-gray-500">Editable in Word</p>
                          </div>
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
          
          {/* Status Section */}
          <div className="flex items-center space-x-4">
            {analysisScore !== null && (
              <div className="bg-white border border-gray-200 rounded-xl px-5 py-3 shadow-sm">
                <div className="flex items-center mb-2">
                  <Sparkles className="h-4 w-4 text-gray-400 mr-2" />
                  <span className="text-sm font-medium text-gray-600">Compliance Score</span>
                </div>
                <div className="flex items-center">
                  <span className={`text-2xl font-bold mr-3 ${
                    analysisScore > 80 ? 'text-green-600' : 
                    analysisScore > 60 ? 'text-yellow-600' : 
                    'text-red-600'
                  }`}>
                    {analysisScore}%
                  </span>
                  <div className="bg-gray-200 rounded-full h-2 w-24">
                    <div 
                      className={`h-2 rounded-full transition-all duration-500 ${
                        analysisScore > 80 ? 'bg-gradient-to-r from-green-500 to-emerald-500' : 
                        analysisScore > 60 ? 'bg-gradient-to-r from-yellow-500 to-orange-500' : 
                        'bg-gradient-to-r from-red-500 to-pink-500'
                      }`}
                      style={{ width: `${analysisScore}%` }}
                    ></div>
                  </div>
                </div>
              </div>
            )}
            
            {documentName && (
              <div className="bg-gray-50 border border-gray-200 rounded-xl px-4 py-3 flex items-center">
                <div className="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center mr-3">
                  <File className="h-4 w-4 text-blue-600" />
                </div>
                <div>
                  <p className="text-sm font-medium text-gray-900 truncate max-w-[180px]">
                    {documentName.replace('.docx', '')}
                  </p>
                  <p className="text-xs text-gray-500">DOCX Document</p>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\IssuesPanel.js
'use client';

import { useState, useMemo, useCallback } from 'react';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import React from 'react';
import { 
  ClipboardList, 
  AlertTriangle, 
  AlertCircle, 
  AlertOctagon, 
  PieChart, 
  Check,
  ChevronDown,
  FileText
} from 'lucide-react';

export default function IssuesPanel() {
  const { issues, activeIssueId, setActiveIssue, applyFix, processingState } = useDocumentStore();
  const [expandedCategories, setExpandedCategories] = useState({
    Critical: true,
    Major: true,
    Minor: false
  });
  
  // Group issues by severity (memoized to prevent recalculation on re-renders)
  const groupedIssues = useMemo(() => {
    return (issues || []).reduce((acc, issue) => {
      if (!acc[issue.severity]) {
        acc[issue.severity] = [];
      }
      acc[issue.severity].push(issue);
      return acc;
    }, {});
  }, [issues]);
  
  // Count issues by severity (memoized)
  const issueCounts = useMemo(() => ({
    Critical: groupedIssues.Critical?.length || 0,
    Major: groupedIssues.Major?.length || 0,
    Minor: groupedIssues.Minor?.length || 0
  }), [groupedIssues]);
  
  // Toggle category expansion (use useCallback to prevent unnecessary function recreation)
  const toggleCategory = useCallback((category) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  }, []);
  
  // Calculate compliance score (memoized)
  const { totalIssues, weightedScore } = useMemo(() => {
    const total = issueCounts.Critical + issueCounts.Major + issueCounts.Minor;
    const score = total > 0 
      ? Math.max(0, 100 - (issueCounts.Critical * 5 + issueCounts.Major * 3 + issueCounts.Minor)) 
      : null;
    return { totalIssues: total, weightedScore: score };
  }, [issueCounts]);
  
  return (
    <div className="h-full bg-white flex flex-col">
      <div className="border-b border-gray-200 px-6 py-4">
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-3">
            <div className="w-8 h-8 bg-blue-100 rounded-lg flex items-center justify-center">
              <ClipboardList className="h-4 w-4 text-blue-600" />
            </div>
            <div>
              <h2 className="text-lg font-semibold text-gray-900">Issues Found</h2>
              <p className="text-sm text-gray-500">APA 7th edition compliance</p>
            </div>
          </div>
          {totalIssues > 0 && (
            <div className="bg-red-50 border border-red-200 rounded-lg px-3 py-1.5">
              <span className="text-red-700 text-sm font-medium">
                {totalIssues} {totalIssues === 1 ? 'Issue' : 'Issues'}
              </span>
            </div>
          )}
        </div>
      </div>
      
      <div className="flex-1 overflow-auto p-6">
      
      {totalIssues > 0 ? (
        <div className="space-y-5">
          {/* Critical Issues */}
          {issueCounts.Critical > 0 && (
            <IssueCategory 
              title="Critical Issues" 
              count={issueCounts.Critical} 
              severity="Critical"
              expanded={expandedCategories.Critical}
              toggleExpanded={() => toggleCategory('Critical')}
            >
              {expandedCategories.Critical && groupedIssues.Critical.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
          
          {/* Major Issues */}
          {issueCounts.Major > 0 && (
            <IssueCategory 
              title="Major Issues" 
              count={issueCounts.Major} 
              severity="Major"
              expanded={expandedCategories.Major}
              toggleExpanded={() => toggleCategory('Major')}
            >
              {expandedCategories.Major && groupedIssues.Major.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
          
          {/* Minor Issues */}
          {issueCounts.Minor > 0 && (
            <IssueCategory 
              title="Minor Issues" 
              count={issueCounts.Minor} 
              severity="Minor"
              expanded={expandedCategories.Minor}
              toggleExpanded={() => toggleCategory('Minor')}
            >
              {expandedCategories.Minor && groupedIssues.Minor.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
        </div>
      ) : issues.length === 0 ? (
        <div className="flex flex-col items-center justify-center py-20 text-center">
          <div className="w-16 h-16 bg-gray-100 rounded-2xl mb-6 flex items-center justify-center">
            <FileText className="h-8 w-8 text-gray-400" />
          </div>
          <h3 className="text-lg font-medium text-gray-900 mb-2">No Document Loaded</h3>
          <p className="text-gray-500 max-w-sm">
            Upload a document using the button in the header to check it against APA 7th Edition guidelines
          </p>
        </div>
      ) : (
        <div className="bg-green-50 border border-green-200 rounded-xl p-6">
          <div className="flex items-start space-x-4">
            <div className="w-12 h-12 bg-green-100 rounded-xl flex items-center justify-center flex-shrink-0">
              <Check className="h-6 w-6 text-green-600" />
            </div>
            <div>
              <h3 className="text-lg font-semibold text-green-900 mb-1">Excellent Work!</h3>
              <p className="text-green-700 mb-2">
                No APA compliance issues found in your document.
              </p>
              <p className="text-sm text-green-600">
                Your document follows APA 7th Edition guidelines correctly.
              </p>
            </div>
          </div>
        </div>
      )}
      
      </div>
      
      {/* Document Statistics */}
      {issues.length > 0 && (
        <div className="border-t border-gray-200 p-6 bg-gray-50">
          <div className="flex items-center mb-4">
            <div className="w-6 h-6 bg-blue-100 rounded-lg flex items-center justify-center mr-2">
              <PieChart className="h-3.5 w-3.5 text-blue-600" />
            </div>
            <h3 className="text-sm font-semibold text-gray-900">Document Statistics</h3>
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div className="bg-white p-4 rounded-xl border border-gray-200">
              <p className="text-xs font-medium text-gray-500 mb-2">Compliance Score</p>
              <div className="flex items-center">
                <span className={`text-2xl font-bold mr-3 ${
                  weightedScore > 80 ? 'text-green-600' : weightedScore > 50 ? 'text-yellow-600' : 'text-red-600'
                }`}>{weightedScore}%</span>
                <div className="flex-1">
                  <div className="bg-gray-200 rounded-full h-2">
                    <div 
                      className={`h-2 rounded-full transition-all duration-300 ${
                        weightedScore > 80 ? 'bg-green-500' : weightedScore > 50 ? 'bg-yellow-500' : 'bg-red-500'
                      }`}
                      style={{width: `${weightedScore}%`}}
                    ></div>
                  </div>
                </div>
              </div>
            </div>
            <div className="bg-white p-4 rounded-xl border border-gray-200">
              <p className="text-xs font-medium text-gray-500 mb-2">Issue Breakdown</p>
              <div className="flex justify-between items-end h-12">
                {issueCounts.Critical > 0 && (
                  <div className="flex flex-col items-center justify-end h-full">
                    <span className="text-xs font-medium text-red-600 mb-1">{issueCounts.Critical}</span>
                    <div 
                      className="bg-red-500 w-6 rounded-t-lg" 
                      style={{height: `${Math.max(8, issueCounts.Critical * 4)}px`}}
                    ></div>
                    <span className="text-xs text-gray-500 mt-1">Critical</span>
                  </div>
                )}
                {issueCounts.Major > 0 && (
                  <div className="flex flex-col items-center justify-end h-full">
                    <span className="text-xs font-medium text-orange-600 mb-1">{issueCounts.Major}</span>
                    <div 
                      className="bg-orange-500 w-6 rounded-t-lg" 
                      style={{height: `${Math.max(8, issueCounts.Major * 4)}px`}}
                    ></div>
                    <span className="text-xs text-gray-500 mt-1">Major</span>
                  </div>
                )}
                {issueCounts.Minor > 0 && (
                  <div className="flex flex-col items-center justify-end h-full">
                    <span className="text-xs font-medium text-blue-600 mb-1">{issueCounts.Minor}</span>
                    <div 
                      className="bg-blue-500 w-6 rounded-t-lg" 
                      style={{height: `${Math.max(8, issueCounts.Minor * 4)}px`}}
                    ></div>
                    <span className="text-xs text-gray-500 mt-1">Minor</span>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Memoize the IssueCategory component to prevent unnecessary renders
const IssueCategory = React.memo(function IssueCategory({ title, count, severity, expanded, toggleExpanded, children }) {
  // Set colors based on severity
  const getStyles = () => {
    switch (severity) {
      case 'Critical': 
        return {
          bg: 'bg-gradient-to-r from-red-50 to-red-100',
          text: 'text-red-800',
          border: 'border-red-200',
          icon: 'text-red-500',
          badge: 'bg-red-500',
          shadow: 'shadow-red-100'
        };
      case 'Major': 
        return {
          bg: 'bg-gradient-to-r from-orange-50 to-amber-100',
          text: 'text-orange-800',
          border: 'border-orange-200',
          icon: 'text-orange-500',
          badge: 'bg-orange-500',
          shadow: 'shadow-orange-100'
        };
      case 'Minor': 
        return {
          bg: 'bg-gradient-to-r from-blue-50 to-blue-100',
          text: 'text-blue-800',
          border: 'border-blue-200',
          icon: 'text-blue-500',
          badge: 'bg-blue-500',
          shadow: 'shadow-blue-100'
        };
      default: 
        return {
          bg: 'bg-gray-100',
          text: 'text-gray-800',
          border: 'border-gray-200',
          icon: 'text-gray-500',
          badge: 'bg-gray-500',
          shadow: 'shadow-gray-100'
        };
    }
  };
  
  const styles = getStyles();
  
  // Get icon based on severity
  const getIcon = () => {
    switch (severity) {
      case 'Critical':
        return <AlertOctagon className="h-5 w-5 mr-2" />;
      case 'Major':
        return <AlertTriangle className="h-5 w-5 mr-2" />;
      case 'Minor':
        return <AlertCircle className="h-5 w-5 mr-2" />;
      default:
        return null;
    }
  };
  
  return (
    <div className={`rounded-lg overflow-hidden border ${styles.border} shadow-sm ${styles.shadow} issue-category hover-shadow`}>
      <button 
        onClick={toggleExpanded}
        className={`w-full flex justify-between items-center px-5 py-3.5 ${styles.bg} ${styles.text} transition-all duration-200 hover:shadow-inner`}
      >
        <span className="font-medium flex items-center text-base">
          <span className={`${styles.icon}`}>{getIcon()}</span>
          {title}
        </span>
        <div className="flex items-center">
          <span className={`${styles.badge} text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center ${count > 0 ? 'animate-pulse-blue' : ''}`}>{count}</span>
          <ChevronDown 
            className={`h-5 w-5 ml-3 transition-transform duration-300 ease-in-out ${expanded ? 'transform rotate-180' : ''} ${styles.icon}`}
          />
        </div>
      </button>
      
      {expanded && (
        <div className="bg-white divide-y divide-gray-100 transition-all duration-300 ease-in-out animate-fade-in">
          {children}
        </div>
      )}
    </div>
  );
});

// Memoize IssueItem to prevent unnecessary re-renders
const IssueItem = React.memo(function IssueItem({ issue, isActive, onSelect, onApplyFix, isApplyingFix = false }) {
  // Get highlight color based on severity
  const getHighlightColor = () => {
    switch (issue.severity) {
      case 'Critical': return 'border-red-500 bg-red-50';
      case 'Major': return 'border-orange-500 bg-orange-50';
      case 'Minor': return 'border-blue-500 bg-blue-50';
      default: return 'border-gray-300 bg-gray-50';
    }
  };
  
  // Get icon based on severity
  const getIcon = () => {
    switch (issue.severity) {
      case 'Critical':
        return <AlertOctagon className="h-4 w-4 text-red-500" />;
      case 'Major':
        return <AlertTriangle className="h-4 w-4 text-orange-500" />;
      case 'Minor':
        return <AlertCircle className="h-4 w-4 text-blue-500" />;
      default:
        return null;
    }
  };
  
  return (
    <div 
      className={`px-4 py-4 hover:bg-gray-50 cursor-pointer transition-colors duration-150 ease-in-out issue-item ${
        isActive ? `border-l-4 ${getHighlightColor()}` : 'border-l-4 border-transparent'
      }`}
      onClick={onSelect}
    >
      <div className="flex justify-between">
        <div className="flex-1 pr-4">
          <div className="flex items-center mb-1.5">
            {getIcon()}
            <p className="text-sm font-semibold text-gray-800 ml-1">{issue.title}</p>
          </div>
          <p className="text-xs text-gray-600 mb-2 leading-relaxed">{issue.description}</p>
          {issue.text && (
            <div className="mt-2 p-3 bg-gray-50 border border-gray-200 rounded-md text-xs font-mono text-gray-700 relative animate-scale-in">
              <div className="absolute -left-1 -top-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -right-1 -top-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -left-1 -bottom-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -right-1 -bottom-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              "{issue.text}"
            </div>
          )}
        </div>
        
        {issue.hasFix && (
          <div className="flex flex-col justify-center">
            <button 
              onClick={(e) => {
                e.stopPropagation();
                if (!isApplyingFix) onApplyFix();
              }}
              disabled={isApplyingFix}
              className={`flex items-center justify-center text-white text-xs px-4 py-1.5 rounded-md shadow-sm transition-all h-fit whitespace-nowrap font-medium ${
                isApplyingFix 
                  ? 'bg-blue-400 cursor-not-allowed' 
                  : 'bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 hover:shadow hover:translate-y-[-1px]'
              }`}
            >
              {isApplyingFix ? (
                <>
                  <svg className="animate-spin h-3.5 w-3.5 mr-1" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Fixing...
                </>
              ) : (
                <>
                  <Check className="h-3.5 w-3.5 mr-1" />
                  Apply Fix
                </>
              )}
            </button>
          </div>
        )}
      </div>
    </div>
  );
});


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\store\enhancedDocumentStore.js
// src/store/enhancedDocumentStore.js - Updated store with server integration
'use client';

import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

// Import the enhanced APA analyzer (same as before, but now works with rich data)
import { EnhancedAPAAnalyzer } from '@/utils/enhancedApaAnalyzer';

export const useDocumentStore = create((set, get) => ({
  // Document state - now includes rich formatting data
  documentText: null,
  documentHtml: null,
  documentName: null,
  documentFormatting: null, // Rich formatting data from server
  documentStructure: null,  // Document structure data
  documentStyles: null,     // Document styles
  documentStats: {
    wordCount: 0,
    charCount: 0,
    paragraphCount: 0,
    processingTime: 0
  },
  
  // Issues and analysis state
  issues: [],
  activeIssueId: null,
  analysisScore: null,
  complianceDetails: null, // Detailed compliance information
  lastFixAppliedAt: null,
  
  // Processing state
  processingState: {
    isUploading: false,
    isAnalyzing: false,
    isSchedulingAnalysis: false,
    isApplyingFix: false,
    lastError: null,
    progress: 0,
    currentFixId: null,
    stage: null
  },
  
  // Upload document with server-side processing
  uploadDocument: async (file) => {
    const SERVER_URL = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3001' 
      : '';
    
    try {
      set({
        processingState: {
          ...get().processingState,
          isUploading: true,
          lastError: null,
          progress: 10,
          stage: 'Uploading document...'
        }
      });
      
      // Validate file on client side
      if (!file.name.toLowerCase().endsWith('.docx')) {
        throw new Error('Please upload a .docx file only');
      }
      
      if (file.size > 10 * 1024 * 1024) { // 10MB
        throw new Error('File size must be less than 10MB');
      }
      
      // Create FormData for file upload
      const formData = new FormData();
      formData.append('document', file);
      
      set({
        documentName: file.name,
        processingState: {
          ...get().processingState,
          progress: 20,
          stage: 'Sending to server...'
        }
      });
      
      // Send to server for processing
      const response = await fetch(`${SERVER_URL}/api/upload-docx`, {
        method: 'POST',
        body: formData,
        // Don't set Content-Type header - let browser set it with boundary
      });
      
      set({
        processingState: {
          ...get().processingState,
          progress: 60,
          stage: 'Processing document...'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Server error: ${response.status}`);
      }
      
      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error || 'Server processing failed');
      }
      
      set({
        processingState: {
          ...get().processingState,
          progress: 80,
          stage: 'Extracting document data...'
        }
      });
      
      const { document: documentData } = result;
      
      // Validate that we got the expected data structure
      if (!documentData.html || !documentData.text) {
        console.warn('Incomplete document data from server:', documentData);
        throw new Error('Server returned incomplete document data');
      }
      
      // Calculate stats
      const words = documentData.processingInfo?.wordCount || 
                    documentData.text.trim().split(/\s+/).filter(Boolean).length;
      const chars = documentData.text.length;
      const paragraphs = documentData.formatting?.paragraphs?.length || 0;
      
      set({
        processingState: {
          ...get().processingState,
          progress: 90,
          stage: 'Finalizing...'
        }
      });
      
      // Store the rich document data
      set(state => ({
        documentHtml: documentData.html,
        documentText: documentData.text,
        documentFormatting: documentData.formatting,
        documentStructure: documentData.structure,
        documentStyles: documentData.styles,
        documentStats: {
          wordCount: words,
          charCount: chars,
          paragraphCount: paragraphs,
          processingTime: documentData.processingInfo?.processingTime || 0
        },
        complianceDetails: documentData.formatting?.compliance || null,
        issues: [], // Clear previous issues
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          progress: 100,
          isUploading: false,
          stage: 'Upload complete'
        }
      }));
      
      console.log('âœ… Document successfully processed with rich formatting data');
      console.log('Document Text length:', documentData.text?.length);
      console.log('Document HTML length:', documentData.html?.length);
      console.log('Has formatting data:', !!documentData.formatting);
      console.log('Has structure data:', !!documentData.structure);
      console.log('Current processing state:', get().processingState);
      
      return true;
      
    } catch (error) {
      console.error('Error uploading document:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isUploading: false,
          lastError: error.message || 'Failed to process document',
          progress: 0,
          stage: null
        }
      }));
      
      return false;
    }
  },
  
  // Enhanced analysis using rich document data
  analyzeDocument: async () => {
    const { 
      documentText, 
      documentHtml, 
      documentFormatting, 
      documentStructure,
      documentStyles 
    } = get();
    
    if (!documentText) {
      console.warn('Cannot analyze document: No document data available');
      return { success: false, error: 'No document data available' };
    }
    
    try {
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null,
          stage: 'Analyzing APA compliance...'
        }
      }));
      
      // Create comprehensive document data object
      const documentData = {
        text: documentText,
        html: documentHtml,
        formatting: documentFormatting,
        structure: documentStructure,
        styles: documentStyles
      };
      
      console.log('ðŸ” Starting APA analysis with rich data...');
      console.log('Available data:', {
        hasText: !!documentText,
        hasHtml: !!documentHtml,
        hasFormatting: !!documentFormatting,
        hasStructure: !!documentStructure,
        formattingCompliance: documentFormatting?.compliance?.overall
      });
      console.log('Current processing state before analysis:', get().processingState);
      
      // Use enhanced analyzer with rich document data
      const analysisResults = await new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            const analyzer = new EnhancedAPAAnalyzer();
            const results = analyzer.analyzeDocument(documentData);
            resolve(results);
          } catch (error) {
            reject(error);
          }
        }, 100);
      });
      
      // Map results to store format and add IDs
      const issues = analysisResults.map(issue => ({
        id: uuidv4(),
        ...issue,
        // Ensure all required fields are present
        title: issue.title || 'Unknown Issue',
        description: issue.description || '',
        severity: issue.severity || 'Minor',
        category: issue.category || 'general',
        text: issue.text || null,
        location: issue.location || null,
        hasFix: issue.hasFix || false,
        fixAction: issue.fixAction || null,
        explanation: issue.explanation || issue.description || ''
      }));
      
      // Calculate enhanced compliance score
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;
      
      // Use server-provided compliance data if available
      let analysisScore;
      if (documentFormatting?.compliance?.overall !== undefined) {
        // Adjust server compliance score based on content issues
        const contentPenalty = criticalCount * 10 + majorCount * 5 + minorCount * 2;
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(documentFormatting.compliance.overall - contentPenalty)
        ));
      } else {
        // Fallback calculation
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))
        ));
      }
      
      set(state => ({
        issues,
        analysisScore,
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          isSchedulingAnalysis: false,
          stage: null
        }
      }));
      
      console.log(`âœ… Analysis complete: ${issues.length} issues found, score: ${analysisScore}%`);
      console.log('Issues breakdown:', { criticalCount, majorCount, minorCount });
      console.log('Final processing state:', get().processingState);
      
      return { 
        success: true, 
        issueCount: issues.length,
        score: analysisScore,
        breakdown: { criticalCount, majorCount, minorCount }
      };
      
    } catch (error) {
      console.error('âŒ Error analyzing document:', error);
      console.error('Error details:', error.message, error.stack);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          isSchedulingAnalysis: false,
          lastError: error.message || 'Analysis failed',
          stage: null
        }
      }));
      
      return { success: false, error: error.message };
    }
  },
  
  // Auto-analyze after upload
  analyzeDocumentDebounced: async () => {
    // For server-side processing, we can analyze immediately since processing is faster
    return await get().analyzeDocument();
  },
  
  // Enhanced fix application (same as before, but with better data)
  applyFix: async (issueId) => {
    const { issues, documentHtml, documentText } = get();
    const issue = issues.find(i => i.id === issueId);
    
    if (!issue || !issue.hasFix) {
      console.warn('Cannot apply fix: issue not found or no fix available');
      return false;
    }
    
    console.log('Applying fix for issue:', issue.title);
    
    set(state => ({
      processingState: {
        ...state.processingState,
        isApplyingFix: true,
        currentFixId: issueId,
        stage: `Applying fix: ${issue.title}`
      }
    }));
    
    try {
      // Apply the fix using the existing logic
      let updatedHtml = documentHtml;
      let updatedText = documentText;
      let contentChanged = false;
      
      const success = await get().applySpecificFix(issue, updatedHtml, updatedText);
      
      if (success.changed) {
        updatedHtml = success.html;
        updatedText = success.text;
        contentChanged = true;
      }
      
      // Remove the fixed issue
      const updatedIssues = issues.filter(i => i.id !== issueId);
      
      // Recalculate score
      const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
      const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
      const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
      
      const newScore = updatedIssues.length === 0 ? 100 : 
        Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
      
      set(state => ({
        documentText: updatedText,
        documentHtml: updatedHtml,
        issues: updatedIssues,
        analysisScore: newScore,
        lastFixAppliedAt: contentChanged ? Date.now() : state.lastFixAppliedAt,
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          isApplyingFix: false,
          currentFixId: null,
          stage: null
        }
      }));
      
      console.log('Fix applied successfully');
      return true;
      
    } catch (error) {
      console.error('Error applying fix:', error);
      
      // Still remove the issue even if fix failed
      const updatedIssues = issues.filter(i => i.id !== issueId);
      
      set(state => ({
        issues: updatedIssues,
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          isApplyingFix: false,
          currentFixId: null,
          lastError: `Failed to apply fix: ${error.message}`,
          stage: null
        }
      }));
      
      return false;
    }
  },
  
  // Apply specific fix logic (same as before)
  applySpecificFix: async (issue, html, text) => {
    let updatedHtml = html;
    let updatedText = text;
    let changed = false;
    
    try {
      switch (issue.fixAction) {
        case 'fixFont':
          updatedHtml = html.replace(
            /font-family:[^;]+;?/gi, 
            'font-family: "Times New Roman", Times, serif;'
          );
          if (!html.includes('font-family')) {
            updatedHtml = `<div style="font-family: 'Times New Roman', Times, serif;">${html}</div>`;
          }
          changed = updatedHtml !== html;
          break;
          
        case 'addCitationComma':
          if (issue.text) {
            const fixedText = issue.text.replace(
              /\(([^,)]+)\s+(\d{4})\)/g, 
              '($1, $2)'
            );
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixParentheticalConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(' and ', ' & ');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'addPageNumber':
          if (issue.text && issue.text.includes('(') && issue.text.includes(')')) {
            const fixedText = issue.text.replace(/\)$/, ', p. 1)');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixEtAlFormatting':
          if (issue.text) {
            // Fix et al. formatting: (Smith et al., 2021) â†’ (Smith, et al., 2021)
            const fixedText = issue.text.replace(
              /\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, 
              '($1, et al., $2)'
            );
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixReferenceConnector':
          if (issue.text) {
            // Fix reference connector: "Author, A., and Author, B." â†’ "Author, A., & Author, B."
            const fixedText = issue.text.replace(/, and /g, ', & ');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixAllCapsHeading':
          if (issue.text) {
            // Convert ALL CAPS heading to Title Case
            const fixedText = issue.text.toLowerCase()
              .split(' ')
              .map(word => {
                // Capitalize first letter of each word, except small words (unless first word)
                const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
                const isFirstWord = word === issue.text.toLowerCase().split(' ')[0];
                
                if (isFirstWord || !smallWords.includes(word)) {
                  return word.charAt(0).toUpperCase() + word.slice(1);
                }
                return word;
              })
              .join(' ');
            
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        default:
          console.log('Fix action not implemented:', issue.fixAction);
          break;
      }
      
      return { html: updatedHtml, text: updatedText, changed };
      
    } catch (error) {
      console.error('Error in applySpecificFix:', error);
      return { html, text, changed: false };
    }
  },
  
  // Set active issue
  setActiveIssue: (issueId) => {
    set({ activeIssueId: issueId });
  },
  
  // Get analysis summary with rich formatting data
  getAnalysisSummary: () => {
    const { 
      issues, 
      analysisScore, 
      documentStats, 
      documentFormatting,
      complianceDetails 
    } = get();
    
    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, {});
    
    const categoryCounts = issues.reduce((acc, issue) => {
      acc[issue.category] = (acc[issue.category] || 0) + 1;
      return acc;
    }, {});
    
    return {
      score: analysisScore,
      totalIssues: issues.length,
      severity: severityCounts,
      categories: categoryCounts,
      documentInfo: {
        ...documentStats,
        hasRichFormatting: !!documentFormatting,
        formattingCompliance: complianceDetails
      },
      compliance: complianceDetails
    };
  },

  // Export document
  exportDocument: async (format) => {
    const { documentHtml, documentName } = get();
    
    if (!documentHtml) {
      alert('No document to export');
      return false;
    }
    
    try {
      // Simple HTML export
      const fullHtml = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <title>APA Formatted Document</title>
          <style>
            body { 
              font-family: "Times New Roman", Times, serif; 
              font-size: 12pt; 
              line-height: 2; 
              margin: 1in; 
            }
          </style>
        </head>
        <body>${documentHtml}</body>
        </html>
      `;
      
      const blob = new Blob([fullHtml], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = documentName ? 
        documentName.replace('.docx', '_APA_formatted.html') : 
        'apa_formatted_document.html';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      return true;
    } catch (error) {
      console.error('Export failed:', error);
      throw error;
    }
  }
}));

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\enhancedApaAnalyzer.js
// src/utils/enhancedApaAnalyzer.js - Fixed version with safe property access
'use client';

// Enhanced APA 7th Edition Analyzer that works with rich document formatting data
export class EnhancedAPAAnalyzer {
  constructor() {
    this.apaStandards = {
      font: {
        family: 'times new roman',
        size: 12 // points
      },
      spacing: {
        line: 2.0, // double spacing
        paragraphAfter: 0, // no extra space after paragraphs
        paragraphBefore: 0
      },
      margins: {
        top: 1.0, // inches
        bottom: 1.0,
        left: 1.0,
        right: 1.0
      },
      indentation: {
        firstLine: 0.5 // inches
      }
    };
  }
  
  /**
   * Main analysis function - works with rich document data from server
   */
  analyzeDocument(documentData) {
    const issues = [];
    
    // Safely extract data with defaults
    const { 
      text = '', 
      html = '', 
      formatting = null, 
      structure = null 
    } = documentData || {};
    
    console.log('ðŸ” Enhanced APA Analyzer starting...');
    console.log('ðŸ“Š Data received:', {
      hasText: !!text,
      hasHtml: !!html,
      hasFormatting: !!formatting,
      hasStructure: !!structure
    });
    
    // 1. Analyze formatting with precise data (if available)
    if (formatting) {
      issues.push(...this.analyzeFormatting(formatting));
    } else {
      console.warn('âš ï¸ No formatting data available - using basic analysis');
      issues.push(...this.analyzeBasicFormatting(html));
    }
    
    // 2. Analyze document structure
    if (structure && text) {
      issues.push(...this.analyzeStructure(structure, text));
    } else if (text) {
      console.warn('âš ï¸ No structure data available - using text-based analysis');
      issues.push(...this.analyzeBasicStructure(text));
    }
    
    // 3. Analyze citations - use basic analysis for better results
    if (text) {
      console.log('ðŸ“š Using basic citation analysis for better coverage...');
      issues.push(...this.analyzeBasicCitations(text));
    }
    
    // 4. Analyze references
    if (text) {
      issues.push(...this.analyzeReferences(text, structure));
    }
    
    // 5. Analyze content compliance
    if (text) {
      issues.push(...this.analyzeContent(text));
    }
    
    console.log(`âœ… Analysis complete: ${issues.length} issues found`);
    
    return this.prioritizeAndDeduplicateIssues(issues);
  }
  
  /**
   * Analyze formatting with precise measurements - FIXED with safe property access
   */
  analyzeFormatting(formatting) {
    const issues = [];
    
    console.log('ðŸŽ¨ Analyzing formatting with rich data...');
    
    // Safely access formatting properties
    const documentFormatting = formatting?.document || {};
    const font = documentFormatting.font || {};
    const spacing = documentFormatting.spacing || {};
    const margins = documentFormatting.margins || {};
    const indentation = documentFormatting.indentation || {};
    const paragraphs = formatting?.paragraphs || [];
    const compliance = formatting?.compliance || {};
    
    // Check font family - SAFE ACCESS
    if (font.family) {
      const fontFamily = font.family.toLowerCase();
      if (!fontFamily.includes('times new roman') && 
          !fontFamily.includes('times') && 
          !fontFamily.includes('liberation serif')) {
        issues.push({
          title: "Incorrect font family",
          description: `Document uses "${font.family}" instead of Times New Roman`,
          text: `Font: ${font.family}`,
          severity: "Major",
          category: "formatting",
          location: { type: "document", section: "font" },
          hasFix: true,
          fixAction: "fixFont",
          explanation: "APA 7th edition requires Times New Roman 12pt font throughout the document."
        });
      }
    } else if (compliance.font && !compliance.font.family) {
      issues.push({
        title: "Font family not specified or non-compliant",
        description: "Document should use Times New Roman font",
        severity: "Major",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    // Check font size with tolerance - SAFE ACCESS
    if (font.size && Math.abs(font.size - 12) > 0.5) {
      issues.push({
        title: "Incorrect font size",
        description: `Font size is ${font.size}pt instead of 12pt`,
        text: `Font size: ${font.size}pt`,
        severity: "Major",
        category: "formatting", 
        location: { type: "document", section: "font" },
        hasFix: true,
        fixAction: "fixFontSize",
        explanation: "APA 7th edition requires 12-point font size."
      });
    }
    
    // Check line spacing - SAFE ACCESS
    if (spacing.line && Math.abs(spacing.line - 2.0) > 0.1) {
      issues.push({
        title: "Incorrect line spacing",
        description: `Line spacing is ${spacing.line} instead of double (2.0)`,
        text: `Line spacing: ${spacing.line}`,
        severity: "Major",
        category: "formatting", 
        location: { type: "document", section: "spacing" },
        hasFix: true,
        fixAction: "fixLineSpacing",
        explanation: "APA 7th edition requires double spacing (2.0) throughout the document."
      });
    }
    
    // Check margins with tolerance - SAFE ACCESS
    const marginIssues = [];
    Object.entries(this.apaStandards.margins).forEach(([side, required]) => {
      const actual = margins[side];
      if (actual !== null && actual !== undefined && Math.abs(actual - required) > 0.1) {
        marginIssues.push(`${side}: ${actual}" (should be ${required}")`);
      }
    });
    
    if (marginIssues.length > 0) {
      issues.push({
        title: "Incorrect margins",
        description: `Margins are not 1 inch: ${marginIssues.join(', ')}`,
        text: marginIssues.join(', '),
        severity: "Major",
        category: "formatting",
        location: { type: "document", section: "margins" },
        hasFix: true,
        fixAction: "fixMargins",
        explanation: "APA 7th edition requires 1-inch margins on all sides."
      });
    }
    
    // Check paragraph indentation - SAFE ACCESS
    if (paragraphs.length > 0) {
      const bodyParagraphs = paragraphs.filter(p => 
        p && p.indentation && (p.indentation.firstLine !== null || p.indentation.left !== null)
      );
      
      const incorrectIndentation = bodyParagraphs.filter(p => {
        const firstLine = (p.indentation && p.indentation.firstLine) || 0;
        return Math.abs(firstLine - 0.5) > 0.05; // 5% tolerance
      });
      
      if (bodyParagraphs.length > 0 && incorrectIndentation.length > 0) {
        issues.push({
          title: "Incorrect paragraph indentation",
          description: `${incorrectIndentation.length} of ${bodyParagraphs.length} paragraphs have incorrect first-line indentation`,
          text: `Expected: 0.5", Found: varies`,
          severity: "Minor",
          category: "formatting",
          location: { 
            type: "paragraph", 
            indices: incorrectIndentation.map(p => p.index).slice(0, 5) 
          },
          hasFix: true,
          fixAction: "fixIndentation",
          explanation: "APA 7th edition requires 0.5-inch first-line indentation for all paragraphs."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback formatting analysis for when rich data isn't available
   */
  analyzeBasicFormatting(html) {
    const issues = [];
    
    console.log('ðŸ“ Using basic formatting analysis (no rich data)...');
    
    if (!html) return issues;
    
    // Check font family
    const fontCheck = html.match(/font-family:\s*['"]([^'"]+)['"]/i);
    if (fontCheck && !fontCheck[1].toLowerCase().includes('times new roman')) {
      issues.push({
        title: "Incorrect font detected",
        description: `Document appears to use "${fontCheck[1]}" instead of Times New Roman`,
        text: `Font: ${fontCheck[1]}`,
        severity: "Minor",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze document structure with heading hierarchy
   */
  analyzeStructure(structure, text) {
    const issues = [];
    
    console.log('ðŸ—ï¸ Analyzing document structure...');
    
    if (!structure || !text) return issues;
    
    const headings = structure.headings || [];
    const sections = structure.sections || [];
    const citations = structure.citations || [];
    
    // 1. Check for required sections
    const hasAbstract = sections.some(s => s.type === 'abstract') || text.toLowerCase().includes('abstract');
    const hasReferences = sections.some(s => s.type === 'references') || text.toLowerCase().includes('references');
    const wordCount = text.split(/\s+/).length;
    
    if (wordCount > 1000 && !hasAbstract) {
      issues.push({
        title: "Missing abstract",
        description: "Long papers typically require an abstract",
        severity: "Major",
        category: "structure",
        hasFix: true,
        fixAction: "addAbstract",
        explanation: "Papers longer than 1000 words typically require an abstract (150-250 words) summarizing the main points."
      });
    }
    
    if (!hasReferences && citations.length > 0) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    // 2. Check heading hierarchy
    if (headings.length > 1) {
      for (let i = 1; i < headings.length; i++) {
        const current = headings[i];
        const previous = headings[i - 1];
        
        if (current.level > previous.level + 1) {
          issues.push({
            title: "Improper heading hierarchy",
            description: `Heading level ${current.level} follows level ${previous.level}`,
            text: `"${current.text}" (Level ${current.level}) after "${previous.text}" (Level ${previous.level})`,
            severity: "Major",
            category: "structure",
            location: { 
              type: "heading", 
              paragraphIndex: current.paragraphIndex 
            },
            hasFix: true,
            fixAction: "fixHeadingLevel",
            explanation: "Headings must follow sequential order: Level 1, then Level 2, then Level 3, etc. Don't skip levels."
          });
        }
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback structure analysis
   */
  analyzeBasicStructure(text) {
    const issues = [];
    
    if (!text) return issues;
    
    console.log('ðŸ—ï¸ Basic structure analysis starting...');
    
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,\s*\d{4}\)/.test(text);
    
    console.log('Has references section:', hasReferences);
    console.log('Has citations:', hasCitations);
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    console.log(`Basic structure analysis found ${issues.length} issues`);
    return issues;
  }
  
  /**
   * Analyze citations with extracted citation data
   */
  analyzeCitations(text, extractedCitations) {
    const issues = [];
    
    console.log('ðŸ“š Analyzing citations with structure data...');
    
    // Use extracted citations for more accurate analysis
    const citations = extractedCitations || [];
    
    citations.forEach((citation, index) => {
      // Check author-year format - SAFE ACCESS
      if (!citation.year || !citation.author) {
        issues.push({
          title: "Incomplete citation",
          description: "Citation missing author or year",
          text: citation.text || 'Unknown citation',
          severity: "Major",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: false,
          explanation: "All in-text citations must include author surname(s) and publication year."
        });
        return;
      }
      
      // Check for proper punctuation
      if (citation.text && !citation.text.includes(`, ${citation.year}`)) {
        issues.push({
          title: "Missing comma in citation",
          description: "Citation missing comma between author and year",
          text: citation.text,
          severity: "Minor",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: true,
          fixAction: "addCitationComma",
          explanation: "In-text citations require a comma between the author name and year: (Smith, 2023)."
        });
      }
    });
    
    return issues;
  }
  
  /**
   * Fallback citation analysis
   */
  analyzeBasicCitations(text) {
    const issues = [];
    
    if (!text) return issues;
    
    console.log('ðŸ“ Basic citation analysis starting...');
    console.log('Text length:', text.length);
    console.log('Text sample:', text.substring(0, 200));
    
    // Enhanced citation patterns to catch all APA violations
    
    // 1. Check for citations missing commas (Author YEAR) format - but exclude et al. cases
    const missingCommaPattern = /\(([A-Za-z][A-Za-z\s&.]+(?<!et\s+al))\s+(\d{4})\)/g;
    let missingCommaMatch;
    while ((missingCommaMatch = missingCommaPattern.exec(text)) !== null) {
      const fullCitation = missingCommaMatch[0];
      const authorPart = missingCommaMatch[1];
      
      // Skip if this contains et al. - handle separately
      if (authorPart.includes('et al')) continue;
      
      console.log(`Found citation missing comma:`, fullCitation);
      
      issues.push({
        title: "Missing comma in citation",
        description: "Citations must have a comma between author and year",
        text: fullCitation,
        severity: "Minor", 
        category: "citations",
        hasFix: true,
        fixAction: "addCitationComma",
        explanation: "APA format requires a comma between author name(s) and year: (Author, YEAR)."
      });
    }
    
    // 2. Standard citation pattern with comma (Author, YEAR)
    const citationPattern = /\(([^)]+),\s*(\d{4})[^)]*\)/g;
    let match;
    let citationCount = 0;
    
    while ((match = citationPattern.exec(text)) !== null) {
      citationCount++;
      const fullCitation = match[0];
      const authorPart = match[1];
      
      console.log(`Found citation ${citationCount}:`, fullCitation);
      
      // Check for incorrect ampersand usage
      if (authorPart.includes(' and ') && fullCitation.includes('(')) {
        issues.push({
          title: "Incorrect connector in parenthetical citation",
          description: "Use '&' instead of 'and' in parenthetical citations",
          text: fullCitation,
          severity: "Minor",
          category: "citations",
          hasFix: true,
          fixAction: "fixParentheticalConnector",
          explanation: "In parenthetical citations, use & to connect author names."
        });
      }
      
      // Check for incorrect et al. formatting - APA 7th edition REQUIRES comma before et al.
      if (authorPart.includes(' et al.') && !authorPart.includes(', et al.')) {
        issues.push({
          title: "Missing comma before et al.",
          description: "APA 7th edition requires comma before 'et al.' in citations",
          text: fullCitation,
          severity: "Minor",
          category: "citations", 
          hasFix: true,
          fixAction: "fixEtAlFormatting",
          explanation: "APA 7th edition requires a comma before 'et al.': (Smith, et al., 2021)."
        });
      }
    }
    
    console.log(`Found ${citationCount} total citations`);
    
    // 3. Analyze References section for consistency issues
    const referencesSection = text.match(/REFERENCES([\s\S]*?)(?=\n\n[A-Z]|$)/i);
    if (referencesSection) {
      const referencesText = referencesSection[1];
      console.log('Found references section, analyzing...');
      
      // Check for "and" instead of "&" in references
      const andInReferencesPattern = /^[^.]+,\s+[^,]+,\s+and\s+[^,]+\./gm;
      let andMatch;
      while ((andMatch = andInReferencesPattern.exec(referencesText)) !== null) {
        issues.push({
          title: "Incorrect connector in reference",
          description: "Use '&' instead of 'and' in reference list",
          text: andMatch[0],
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixReferenceConnector",
          explanation: "In reference lists, use & (ampersand) to connect author names, not 'and'."
        });
      }
      
      // Check for missing DOI/URL when available
      const lines = referencesText.split('\n').filter(line => line.trim().length > 0);
      lines.forEach((line, index) => {
        if (line.match(/^\s*[A-Z]/)) { // Reference entry line
          if (!line.includes('doi:') && !line.includes('http') && !line.includes('Retrieved from')) {
            if (line.toLowerCase().includes('journal') || line.toLowerCase().includes('article')) {
              issues.push({
                title: "Missing DOI or URL",
                description: "Journal articles should include DOI or URL when available",
                text: line.substring(0, 100) + '...',
                severity: "Minor",
                category: "references",
                hasFix: false,
                explanation: "Include DOI (preferred) or URL for journal articles and online sources when available."
              });
            }
          }
        }
      });
    }
    
    // 4. Check for title page issues
    const titlePageIssues = this.analyzeTitlePage(text);
    issues.push(...titlePageIssues);
    
    // 5. Check for spacing issues around citations
    const spacingIssuePattern = /[^\s]\(([^)]+,\s*\d{4})\)|(\([^)]+,\s*\d{4}\))[^\s.,;]/g;
    let spacingMatch;
    while ((spacingMatch = spacingIssuePattern.exec(text)) !== null) {
      issues.push({
        title: "Citation spacing error",
        description: "Citations need proper spacing before and after",
        text: spacingMatch[0],
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "There should be a space before opening parenthesis and proper punctuation after citations."
      });
    }
    
    // 6. Check for URLs in text that should be properly formatted
    const urlInTextPattern = /https?:\/\/[^\s)]+/g;
    let urlMatch;
    while ((urlMatch = urlInTextPattern.exec(text)) !== null) {
      if (!text.includes('Retrieved from') || !text.includes('doi:')) {
        issues.push({
          title: "URL formatting in text",
          description: "URLs should be properly formatted in references, not embedded in text",
          text: urlMatch[0],
          severity: "Minor",
          category: "formatting",
          hasFix: false,
          explanation: "URLs should appear in the reference list, not embedded in the main text."
        });
      }
    }
    
    // 7. Check for ALL CAPS headings (more precise detection)
    const allCapsHeadingPattern = /\n\s*([A-Z][A-Z\s]{8,})\s*\n/g;
    let titleMatch;
    while ((titleMatch = allCapsHeadingPattern.exec(text)) !== null) {
      const heading = titleMatch[1].trim();
      // Only flag if it's truly ALL CAPS and looks like a heading
      if (heading.length > 8 && heading === heading.toUpperCase() && 
          !heading.includes('(') && !heading.includes(',') && 
          heading.split(' ').length <= 8) {
        issues.push({
          title: "ALL CAPS heading detected",
          description: "Headings should use title case or sentence case, not ALL CAPS",
          text: heading,
          severity: "Minor",
          category: "formatting", 
          hasFix: true,
          fixAction: "fixAllCapsHeading",
          explanation: "APA 7th edition headings should use title case (Level 1-3) or sentence case (Level 4-5), not ALL CAPS."
        });
      }
    }
    
    // 8. Check for paragraph structure (multiple consecutive line breaks)
    const excessiveBreaksPattern = /\n\s*\n\s*\n\s*\n/g;
    if (excessiveBreaksPattern.test(text)) {
      issues.push({
        title: "Excessive line spacing",
        description: "Too many blank lines between paragraphs",
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "APA format uses double-spacing with no extra blank lines between paragraphs."
      });
    }
    
    // 9. Check for sentences ending without punctuation (more precise)
    const incompleteSentencePattern = /[a-z]\s+[A-Z][a-z]/g;
    let incompleteMatch;
    let sentenceIssueCount = 0;
    while ((incompleteMatch = incompleteSentencePattern.exec(text)) && sentenceIssueCount < 3) {
      const context = text.substring(Math.max(0, incompleteMatch.index - 30), incompleteMatch.index + 50);
      
      // Skip if this looks like an abbreviation or proper formatting
      if (context.includes('Dr.') || context.includes('Mr.') || context.includes('Ms.') ||
          context.includes('etc.') || context.includes('i.e.') || context.includes('e.g.') ||
          context.match(/\d+\s+[A-Z]/) || // Numbers followed by caps (like page numbers)
          context.includes('(') || context.includes(')')) {
        continue;
      }
      
      sentenceIssueCount++;
      issues.push({
        title: "Possible missing punctuation",
        description: "Check if sentence needs proper punctuation",
        text: context.trim().substring(0, 60) + '...',
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "Sentences should end with appropriate punctuation before starting a new sentence."
      });
    }
    
    // Check for direct quotes without page numbers
    const quotePattern = /[""][^""]{10,}[""]\s*(\([^)]+\))/g;
    let quoteMatch;
    while ((quoteMatch = quotePattern.exec(text)) !== null) {
      const citation = quoteMatch[1];
      if (!citation.match(/,\s*p\.?\s*\d+/)) {
        issues.push({
          title: "Direct quote missing page number",
          description: "Direct quotes require page numbers",
          text: quoteMatch[0],
          severity: "Major",
          category: "citations",
          hasFix: true,
          fixAction: "addPageNumber",
          explanation: "All direct quotations must include a page number to help readers locate the original text."
        });
      }
    }
    
    console.log(`Basic citation analysis found ${issues.length} issues`);
    return issues;
  }
  
  /**
   * Analyze title page structure
   */
  analyzeTitlePage(text) {
    const issues = [];
    
    if (!text) return issues;
    
    console.log('ðŸ“„ Analyzing title page structure...');
    
    const firstPage = text.substring(0, 1500); // First ~1500 chars for title page
    
    // Check for required elements in order
    const lines = firstPage.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    if (lines.length < 3) {
      issues.push({
        title: "Incomplete title page",
        description: "Title page appears to be missing required elements",
        severity: "Major",
        category: "structure",
        hasFix: false,
        explanation: "APA title page requires: paper title, author name(s), institutional affiliation, and author note."
      });
      return issues;
    }
    
    // Check if title is centered (simple heuristic - no excessive leading spaces)
    const possibleTitle = lines[0];
    if (possibleTitle.length > 5 && possibleTitle.startsWith('  ')) {
      // This might indicate improper formatting, but it's hard to detect without rich formatting
      console.log('Possible title formatting issue detected');
    }
    
    // Check for common title page issues
    const titlePageText = firstPage.toLowerCase();
    
    // Check for missing running head
    if (!titlePageText.includes('running head') && !titlePageText.includes('page')) {
      issues.push({
        title: "Missing running head",
        description: "Title page should include a running head (for professional papers)",
        severity: "Minor", 
        category: "structure",
        hasFix: false,
        explanation: "Professional papers require a running head on the title page and throughout the document."
      });
    }
    
    // Check for in-text citations on title page (but be more selective)
    const citationPattern = /\([A-Za-z]+,?\s+\d{4}\)/g;
    const citationsOnTitlePage = firstPage.match(citationPattern);
    if (citationsOnTitlePage && citationsOnTitlePage.length > 0) {
      // Only flag if it's clearly in the main title page content, not in author notes
      const titlePageWithoutAuthorNote = firstPage.split('Author Note')[0];
      if (citationPattern.test(titlePageWithoutAuthorNote)) {
        issues.push({
          title: "Citations on title page",
          description: "Title page should not contain in-text citations",
          severity: "Minor",
          category: "structure", 
          hasFix: false,
          explanation: "The title page should contain only title, author, affiliation information - no citations."
        });
      }
    }
    
    console.log(`Title page analysis found ${issues.length} issues`);
    return issues;
  }
  
  /**
   * Analyze references section
   */
  analyzeReferences(text, structure) {
    const issues = [];
    
    if (!text) return issues;
    
    console.log('ðŸ“– Analyzing references...');
    
    // Simple check - if we have citations but no references section
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,?\s*\d{4}\)/.test(text);
    
    console.log('References check - has references:', hasReferences, 'has citations:', hasCitations);
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing References section",
        description: "Document has citations but no References section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesHeader",
        explanation: "All APA papers must include a References section."
      });
      console.log('Added missing references issue');
    }
    
    const referencesMatch = text.match(/References[\s\n]+([\s\S]+?)(?:\n\n[A-Z]|$)/i);
    if (!referencesMatch) return issues;
    
    const referencesText = referencesMatch[1].trim();
    const referenceEntries = referencesText
      .split(/\n\s*\n/)
      .filter(entry => entry.trim().length > 10);
    
    if (referenceEntries.length === 0) {
      issues.push({
        title: "Empty references section",
        description: "References section contains no entries",
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "The References section must contain entries for all sources cited in your paper."
      });
      return issues;
    }
    
    // Check alphabetical order
    const firstWords = referenceEntries.map(entry => {
      const match = entry.match(/^([^,\s]+)/);
      return match ? match[1].toLowerCase() : '';
    });
    
    const sortedFirstWords = [...firstWords].sort();
    const isAlphabetical = JSON.stringify(firstWords) === JSON.stringify(sortedFirstWords);
    
    if (!isAlphabetical) {
      issues.push({
        title: "References not in alphabetical order",
        description: "Reference entries must be alphabetized by first author's surname",
        text: `First entries: ${firstWords.slice(0, 3).join(', ')}...`,
        severity: "Major",
        category: "references",
        hasFix: true,
        fixAction: "sortReferences",
        explanation: "References must be arranged in alphabetical order by the surname of the first author."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze content for APA compliance
   */
  analyzeContent(text) {
    const issues = [];
    
    if (!text) return issues;
    
    console.log('ðŸ“„ Analyzing content compliance...');
    
    // Check for excessive first person usage
    const firstPersonPattern = /\b(I|me|my|mine|we|us|our|ours)\b/gi;
    const firstPersonMatches = text.match(firstPersonPattern) || [];
    const wordCount = text.split(/\s+/).length;
    
    if (firstPersonMatches.length > wordCount * 0.02) { // More than 2%
      issues.push({
        title: "Excessive first-person usage",
        description: "Consider reducing first-person pronouns in formal academic writing",
        text: `Found ${firstPersonMatches.length} instances`,
        severity: "Minor",
        category: "content",
        hasFix: false,
        explanation: "While not prohibited, excessive first-person usage should be avoided in formal academic writing."
      });
    }
    
    console.log(`Content analysis found ${issues.length} issues`);
    return issues;
  }
  
  /**
   * Helper methods
   */
  prioritizeAndDeduplicateIssues(issues) {
    // Remove duplicates based on title and text
    const unique = issues.filter((issue, index, self) => 
      index === self.findIndex(i => 
        i.title === issue.title && i.text === issue.text
      )
    );
    
    // Sort by severity and category
    const severityOrder = { 'Critical': 0, 'Major': 1, 'Minor': 2 };
    const categoryOrder = { 
      'formatting': 0, 
      'structure': 1, 
      'citations': 2, 
      'references': 3, 
      'content': 4 
    };
    
    return unique.sort((a, b) => {
      // First by severity
      const severityCompare = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityCompare !== 0) return severityCompare;
      
      // Then by category
      return categoryOrder[a.category] - categoryOrder[b.category];
    });
  }
}

// Usage function that matches what your store expects
export function analyzeAPADocument(documentData) {
  const analyzer = new EnhancedAPAAnalyzer();
  return analyzer.analyzeDocument(documentData);
}

