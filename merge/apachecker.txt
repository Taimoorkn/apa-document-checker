// File: c:\Users\Taimoor\apa-document-checker\src\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary: #3b82f6;
  --secondary: #10b981;
  --accent: #8b5cf6;
  --error: #ef4444;
  --warning: #f59e0b;
  --background: #ffffff;
  --text: #1f2937;
}

/* Base styling */
body {
  color: var(--text);
  background-color: var(--background);
}

/* Typography */
h1, h2, h3, h4, h5 {
  font-family: 'Inter', sans-serif;
}

body {
  font-family: 'Roboto', sans-serif;
}

/* APA styling for document viewer */
.prose {
  font-family: 'Times New Roman', Times, serif;
  font-size: 12pt;
  line-height: 2;
  max-width: none;
}

/* Issue highlighting styles */
mark[data-issue-id] {
  border-radius: 2px;
  cursor: pointer;
  padding: 0 1px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

mark[data-issue-id]::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform 0.3s ease;
}

mark[data-issue-id]:hover::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

.bg-red-200 {
  background-color: rgba(254, 202, 202, 0.7);
  border-bottom: 2px solid var(--error);
}

.bg-red-200:hover {
  background-color: rgba(254, 202, 202, 0.9);
}

.bg-red-200::after {
  background-color: var(--error);
}

.bg-orange-200 {
  background-color: rgba(254, 215, 170, 0.7);
  border-bottom: 2px solid var(--warning);
}

.bg-orange-200:hover {
  background-color: rgba(254, 215, 170, 0.9);
}

.bg-orange-200::after {
  background-color: var(--warning);
}

.bg-blue-200 {
  background-color: rgba(191, 219, 254, 0.7);
  border-bottom: 2px solid var(--primary);
}

.bg-blue-200:hover {
  background-color: rgba(191, 219, 254, 0.9);
}

.bg-blue-200::after {
  background-color: var(--primary);
}

/* Active issue highlighting */
.active-issue {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  animation: pulse 2s infinite;
}

/* Custom animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
  100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Animation utilities (fallback for older Tailwind versions) */
.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 0.3s ease-out forwards;
}

.animate-pulse-blue {
  animation: pulse 2s infinite;
}

/* Apply animations to components */
.issue-category {
  animation: fadeIn 0.4s ease-out;
}

.issue-item {
  animation: slideIn 0.3s ease-out;
}

/* Staggered animations for issue items */
.issue-item:nth-child(1) { animation-delay: 0.05s; }
.issue-item:nth-child(2) { animation-delay: 0.1s; }
.issue-item:nth-child(3) { animation-delay: 0.15s; }
.issue-item:nth-child(4) { animation-delay: 0.2s; }
.issue-item:nth-child(5) { animation-delay: 0.25s; }

/* Custom utility classes */
.hover-shadow:hover {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-grow:hover {
  transform: scale(1.02);
}

/* Loading spinner */
.loading-spinner {
  border: 3px solid rgba(59, 130, 246, 0.1);
  border-radius: 50%;
  border-top: 3px solid var(--primary);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
}

// File: c:\Users\Taimoor\apa-document-checker\src\app\layout.js
import './globals.css'
import ErrorBoundary from '@/components/ErrorBoundary'

export const metadata = {
  title: 'APA 7th Edition Document Checker',
  description: 'Validate academic documents against APA 7th edition guidelines',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
      </head>
      <body className="font-sans antialiased text-gray-800 bg-gray-50">
        <ErrorBoundary showDetails={process.env.NODE_ENV === 'development'}>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}

// File: c:\Users\Taimoor\apa-document-checker\src\app\page.js
'use client';
import './globals.css';
import { useState } from 'react';
import DocumentViewer from '@/components/DocumentViewer';
import IssuesPanel from '@/components/IssuesPanel';
import Header from '@/components/Header';
import { useDocumentStore } from '@/store/documentStore';
import { BookOpen } from 'lucide-react';

export default function Home() {
  const [splitRatio, setSplitRatio] = useState(60);
  const { documentText, issues } = useDocumentStore();

  return (
    <main className="flex flex-col h-screen bg-gradient-to-br from-slate-50 to-blue-50">
      <Header />
      
      <div className="flex-1 overflow-hidden flex flex-col max-w-7xl mx-auto w-full px-4 py-3">
        <div className="flex justify-between items-center pb-3 bg-white rounded-t-lg shadow-sm p-3 border-x border-t border-gray-200">
          <div className="flex items-center">
            <BookOpen className="h-5 w-5 text-blue-600 mr-2" />
            <h2 className="text-lg font-semibold text-blue-700">APA Document Checker</h2>
          </div>
          <div className="text-sm bg-blue-50 px-3 py-1 rounded-full text-blue-700 font-medium">
            {documentText ? 'Document loaded and analyzed' : 'No document loaded'}
          </div>
        </div>
        
        <div className="flex flex-1 overflow-hidden rounded-b-lg shadow-lg border border-gray-200 bg-white">
          {/* Document Viewer (left panel) */}
          <div 
            className="relative overflow-auto border-r border-gray-200"
            style={{ width: `${splitRatio}%` }}
          >
            <DocumentViewer />
          </div>
          
          {/* Resize handle */}
          <div 
            className="w-2 bg-gradient-to-r from-gray-100 to-gray-200 hover:from-blue-400 hover:to-blue-500 cursor-col-resize transition-colors relative flex items-center justify-center"
            onMouseDown={(e) => {
              const startX = e.clientX;
              const startWidth = splitRatio;
              
              const handleMouseMove = (moveEvent) => {
                const containerWidth = document.body.clientWidth;
                const newWidth = startWidth + ((moveEvent.clientX - startX) / containerWidth * 100);
                
                // Constrain between 30% and 80%
                const constrainedWidth = Math.max(30, Math.min(80, newWidth));
                setSplitRatio(constrainedWidth);
              };
              
              const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
              };
              
              document.addEventListener('mousemove', handleMouseMove);
              document.addEventListener('mouseup', handleMouseUp);
            }}
          >
            <div className="absolute flex flex-col space-y-1.5">
              <div className="w-1 h-2 bg-gray-400 rounded-full"></div>
              <div className="w-1 h-2 bg-gray-400 rounded-full"></div>
              <div className="w-1 h-2 bg-gray-400 rounded-full"></div>
            </div>
          </div>
          
          {/* Issues Panel (right panel) */}
          <div 
            className="overflow-auto bg-gray-50"
            style={{ width: `${100 - splitRatio}%` }}
          >
            <IssuesPanel />
          </div>
        </div>
        
        <div className="py-3 text-xs text-center text-blue-600 font-medium bg-white mt-2 rounded-lg shadow-sm border border-gray-200 p-2">
          APA 7th Edition Document Checker | Validate academic papers against APA guidelines
        </div>
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\apa-document-checker\src\components\DocumentViewer.js
'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import { FileText, InfoIcon } from 'lucide-react';

export default function DocumentViewer() {
  const { documentText, documentHtml, activeIssueId, issues, setActiveIssue } = useDocumentStore();
  const viewerRef = useRef(null);
  const [isLoading, setIsLoading] = useState(false);
  
  // Add a state for showing/hiding issues
  const [showIssues, setShowIssues] = useState(true);
  
  // Function to apply highlighting to the document
  const applyHighlighting = () => {
    if (!viewerRef.current || !documentHtml || !issues || !showIssues) return;
    
    console.log('Applying highlighting to document with', issues.length, 'issues');
    
    // First, reset any existing highlighting and remove event listeners to prevent memory leaks
    const existingMarks = viewerRef.current.querySelectorAll('mark[data-issue-id]');
    existingMarks.forEach(mark => {
      // Clone the mark without event listeners to prevent memory leaks
      const newMark = mark.cloneNode(true);
      const parent = mark.parentNode;
      const textContent = mark.textContent;
      const textNode = document.createTextNode(textContent);
      parent.replaceChild(textNode, mark);
    });
    
    // Track created marks so we can efficiently handle cleanups later
    const createdMarks = [];
    
    // Now apply new highlighting
    for (const issue of issues) {
      if (!issue.text) continue;
      
      // Find all text nodes in the document
      const allTextNodes = [];
      const walker = document.createTreeWalker(
        viewerRef.current,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      let node;
      while ((node = walker.nextNode())) {
        allTextNodes.push(node);
      }
      
      // Look for the issue text in these nodes
      for (const textNode of allTextNodes) {
        const content = textNode.textContent;
        const index = content.indexOf(issue.text);
        
        if (index === -1) continue;
        
        try {
          // Found a match, split the node and highlight
          const range = document.createRange();
          range.setStart(textNode, index);
          range.setEnd(textNode, index + issue.text.length);
          
          // Create a mark element
          const mark = document.createElement('mark');
          mark.setAttribute('data-issue-id', issue.id);
          mark.className = getIssueClass(issue.severity);
          
          // Wrap the text in the mark
          range.surroundContents(mark);
          
          // Use a data attribute instead of direct event listener
          // This makes the DOM element serializable and prevents memory leaks
          mark.setAttribute('data-clickable', 'true');
          
          // Track created marks
          createdMarks.push(mark);
          
          // Only highlight the first occurrence
          break;
        } catch (error) {
          console.error('Error highlighting text:', error);
          // Continue with next node if there's an error
          continue;
        }
      }
    }
    
    // Add a single delegated event listener at the container level for better performance
    // and to avoid memory leaks from multiple individual listeners
    if (viewerRef.current) {
      // First remove any existing click handler
      viewerRef.current.removeEventListener('click', handleMarkClick);
      // Then add the new one
      viewerRef.current.addEventListener('click', handleMarkClick);
    }
    
    // Highlight the active issue with a special class
    if (activeIssueId) {
      const activeMark = viewerRef.current.querySelector(`mark[data-issue-id="${activeIssueId}"]`);
      if (activeMark) {
        activeMark.classList.add('active-issue');
      }
    }
    
    return () => {
      // Clean up event listener when component unmounts or before re-applying
      if (viewerRef.current) {
        viewerRef.current.removeEventListener('click', handleMarkClick);
      }
    };
  };
  
  // Event handler for mark clicks using event delegation
  const handleMarkClick = (event) => {
    // Find the closest mark element from the click target
    const mark = event.target.closest('mark[data-issue-id][data-clickable="true"]');
    if (mark) {
      const issueId = mark.getAttribute('data-issue-id');
      if (issueId) {
        setActiveIssue(issueId);
      }
    }
  };
  
  useEffect(() => {
    // Declare variables at the function scope level, so they're accessible in the cleanup function
    let mainTimeoutId;
    let highlightTimeoutId;
    
    console.log('DocumentViewer effect running with documentHtml:', !!documentHtml);
    
    if (documentHtml) {
      setIsLoading(true);
      
      // Use a ref to track the current render cycle
      const renderCycleId = Date.now();
      viewerRef.current.setAttribute('data-render-cycle', renderCycleId.toString());
      
      mainTimeoutId = setTimeout(() => {
        // Check if this is still the current render cycle
        if (viewerRef.current && viewerRef.current.getAttribute('data-render-cycle') === renderCycleId.toString()) {
          // Set the HTML content
          viewerRef.current.innerHTML = documentHtml;
          console.log('Document HTML set successfully');
          
          // Apply highlighting after a short delay to ensure DOM is ready
          highlightTimeoutId = setTimeout(() => {
            // Double-check that we're still on the same render cycle before highlighting
            if (viewerRef.current && viewerRef.current.getAttribute('data-render-cycle') === renderCycleId.toString()) {
              applyHighlighting();
            }
          }, 100);
        }
        
        // Finish loading regardless of success
        setIsLoading(false);
      }, 500);
    }
    
    // Cleanup function
    return () => {
      if (mainTimeoutId) clearTimeout(mainTimeoutId);
      if (highlightTimeoutId) clearTimeout(highlightTimeoutId);
    };
  }, [documentHtml]);
  
  // Function to apply highlighting (memoized to prevent unnecessary recreations)
  const highlightIssues = useCallback(() => {
    if (documentHtml && !isLoading && viewerRef.current) {
      return applyHighlighting();
    }
  }, [documentHtml, isLoading]);

  // Apply highlighting when issues change or active issue changes
  useEffect(() => {
    // Only apply if document is loaded and not in loading state
    const cleanup = highlightIssues();
    
    // Return cleanup function to remove event listeners when component unmounts
    return () => {
      if (typeof cleanup === 'function') {
        cleanup();
      }
    };
  }, [issues, activeIssueId, showIssues, highlightIssues]);
  
  // Helper function to get text nodes
  const getTextNodes = (node) => {
    let textNodes = [];
    if (node.nodeType === Node.TEXT_NODE) {
      textNodes.push(node);
    } else {
      const children = node.childNodes;
      for (let i = 0; i < children.length; i++) {
        textNodes = textNodes.concat(getTextNodes(children[i]));
      }
    }
    return textNodes;
  };
  
  // Helper function to get issue class based on severity
  const getIssueClass = (severity) => {
    switch (severity) {
      case 'Critical':
        return 'bg-red-200 border-b-2 border-red-500 cursor-pointer';
      case 'Major':
        return 'bg-orange-200 border-b-2 border-orange-500 cursor-pointer';
      case 'Minor':
        return 'bg-blue-200 border-b-2 border-blue-500 cursor-pointer';
      default:
        return '';
    }
  };
  
  // Add debug output for component state
  console.log('DocumentViewer render - documentText exists:', !!documentText, 'documentHtml:', !!documentHtml, 'isLoading:', isLoading);

  return (
    <div className="p-8 h-full">
      {documentText ? (
        <>
          {isLoading ? (
            <div className="flex flex-col items-center justify-center h-full bg-white shadow-md p-8 rounded-lg">
              <div className="loading-spinner mb-4"></div>
              <p className="text-gray-600 font-medium">Analyzing document...</p>
              <p className="text-sm text-gray-500 mt-1">Checking for APA 7th edition compliance</p>
            </div>
          ) : (
            <div className="bg-white shadow-lg rounded-lg p-6 border border-gray-200">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-semibold text-blue-700">Document Content</h3>
                <button 
                  onClick={() => setShowIssues(!showIssues)}
                  className={`px-3 py-1 rounded-md text-sm font-medium flex items-center ${
                    showIssues 
                      ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' 
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                >
                  {showIssues ? (
                    <>
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                        <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                      </svg>
                      Hide Issues
                    </>
                  ) : (
                    <>
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z" clipRule="evenodd" />
                        <path d="M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z" />
                      </svg>
                      Show Issues
                    </>
                  )}
                </button>
              </div>
              <div 
                ref={viewerRef}
                className="prose max-w-none bg-white p-4 rounded border border-gray-100"
                style={{
                  fontFamily: '"Times New Roman", Times, serif',
                  fontSize: '12pt',
                  lineHeight: '1.6',
                  color: '#1f2937'
                }}
              >
                {/* Document content will be inserted here by useEffect, but we'll also render it directly if innerHTML doesn't work */}
                {documentHtml ? (
                  <div dangerouslySetInnerHTML={{ __html: documentHtml }} />
                ) : (
                  <div>
                    <p>Document loaded but HTML content could not be displayed.</p>
                    <p className="text-gray-500 mt-2">Raw text content:</p>
                    <div className="mt-2 p-4 bg-gray-50 rounded-lg">
                      {documentText ? documentText.substring(0, 500) + (documentText.length > 500 ? '...' : '') : 'No text content available'}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </>
      ) : (
        <div className="flex flex-col items-center justify-center h-full py-20 bg-gradient-to-b from-white to-blue-50 rounded-lg shadow-sm border border-gray-100 animate-scale-in">
          <div className="bg-blue-50 p-5 rounded-full mb-6 shadow-inner flex items-center justify-center">
            <FileText className="h-20 w-20 text-blue-500" />
          </div>
          <h2 className="text-2xl font-semibold text-gray-800 mb-3">Upload a document to begin</h2>
          <p className="text-gray-500 mb-8">Validate your academic paper against APA 7th edition guidelines</p>
          <div className="border-t border-gray-200 pt-6 w-full max-w-md">
            <div className="bg-blue-50 rounded-md p-4 flex items-start hover:bg-blue-100 transition-colors hover-shadow">
              <InfoIcon className="h-5 w-5 text-blue-500 mt-0.5 mr-2 flex-shrink-0" />
              <span className="text-sm text-blue-800">Only .docx files are supported. For best results, ensure your document is properly formatted.</span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}


// File: c:\Users\Taimoor\apa-document-checker\src\components\ErrorBoundary.js
'use client';

import { Component } from 'react';
import { AlertTriangle } from 'lucide-react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // You can log the error to an error reporting service
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
    this.setState({
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <div className="flex flex-col items-center justify-center p-6 bg-red-50 border border-red-200 rounded-lg shadow-sm text-center">
          <div className="bg-red-100 p-3 rounded-full mb-4">
            <AlertTriangle className="h-8 w-8 text-red-500" />
          </div>
          <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-sm text-red-600 mb-4">
            {this.state.error ? this.state.error.toString() : 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
          >
            Reload Page
          </button>
          {this.props.showDetails && this.state.errorInfo && (
            <div className="mt-6 w-full">
              <details className="text-left">
                <summary className="text-sm font-medium text-red-800 cursor-pointer">Error Details</summary>
                <pre className="mt-2 p-3 text-xs text-red-800 bg-red-100 overflow-auto rounded-md">
                  {this.state.errorInfo.componentStack}
                </pre>
              </details>
            </div>
          )}
        </div>
      );
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;


// File: c:\Users\Taimoor\apa-document-checker\src\components\Header.js
'use client';

import { useState } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import { BookOpen, Upload, Download, File, AlertTriangle } from 'lucide-react';

export default function Header() {
  const { uploadDocument, documentName, analyzeDocument, analysisScore, exportDocument, processingState } = useDocumentStore();
  
  // Local state for UI-only errors (now using store for processing state)
  const [uploadError, setUploadError] = useState(null);
  
  const handleFileUpload = async (e) => {
    // Reset error state
    setUploadError(null);
    
    const file = e.target.files[0];
    if (!file) return;
    
    // Validate file type
    if (!file.name.endsWith('.docx')) {
      setUploadError('Please upload a .docx file only');
      return;
    }
    
    // Validate file size (max 10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB in bytes
    if (file.size > maxSize) {
      setUploadError(`File size exceeds limit (max ${maxSize / (1024 * 1024)}MB)`);
      return;
    }
    
    try {
      // Upload document (processing state is managed inside the store now)
      const success = await uploadDocument(file);
      
      if (success) {
        // Only analyze if upload was successful
        const analysisResult = await analyzeDocument();
        
        // If analysis failed, display error
        if (!analysisResult?.success && analysisResult?.error) {
          setUploadError(`Analysis error: ${analysisResult.error}`);
        }
      } else {
        // If upload failed and store didn't set an error, set a generic one
        if (!processingState.lastError) {
          setUploadError('Failed to process document. Please try a different file.');
        }
      }
    } catch (error) {
      console.error('Error in file upload handler:', error);
      setUploadError(`Error: ${error.message || 'Failed to upload document'}`);
    } finally {
      // Reset file input to allow re-uploading the same file
      e.target.value = '';
    }
  };
  
  return (
    <header className="bg-gradient-to-r from-blue-600 via-blue-700 to-indigo-700 shadow-md">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="py-4 flex justify-between items-center">
          <div className="flex items-center">
            <h1 className="text-2xl font-bold text-white mr-8 flex items-center">
              <div className="bg-white/10 p-2 rounded-lg mr-3">
                <BookOpen className="h-8 w-8 text-white" />
              </div>
              APA 7 Checker
            </h1>
            <div className="flex space-x-4">
              <div className="flex flex-col">
                <label className={`${processingState.isUploading ? 'opacity-75 cursor-wait' : 'hover:bg-gray-50'} bg-white text-blue-700 border border-transparent hover:border-blue-100 px-4 py-2 rounded-md cursor-pointer transition-all shadow-md hover:shadow-lg flex items-center group`}>
                  <Upload className={`h-5 w-5 mr-2 ${processingState.isUploading ? 'animate-pulse' : ''} text-blue-500 group-hover:text-blue-600`} />
                  {processingState.isUploading ? 'Uploading...' : processingState.isAnalyzing ? 'Analyzing...' : 'Upload Document'}
                  <input
                    type="file"
                    accept=".docx"
                    className="hidden"
                    onChange={handleFileUpload}
                    disabled={processingState.isUploading || processingState.isAnalyzing}
                  />
                </label>
                
                {uploadError && (
                  <div className="mt-1 text-xs text-red-600 flex items-center bg-red-50 px-2 py-1 rounded border border-red-100">
                    <AlertTriangle className="h-3 w-3 mr-1 flex-shrink-0" />
                    {uploadError}
                  </div>
                )}
              </div>
              
              {documentName && (
                <button 
                  className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md transition-colors shadow-md hover:shadow-lg flex items-center"
                  onClick={exportDocument}
                >
                  <Download className="h-5 w-5 mr-2" />
                  Export Fixed Document
                </button>
              )}
            </div>
          </div>
          
          <div className="flex items-center space-x-6">
            {analysisScore !== null && (
              <div className="flex flex-col items-end bg-white/20 backdrop-blur-sm rounded-lg px-4 py-2 shadow-inner border border-white/30">
                <div className="flex items-center mb-1">
                  <span className="text-white mr-2 text-sm">APA Compliance:</span>
                  <span className="text-white font-bold">{analysisScore}%</span>
                </div>
                <div className="bg-gray-200/30 rounded-full h-3 w-40 shadow-inner">
                  <div 
                    className={`h-3 rounded-full shadow-sm ${
                      analysisScore > 80 ? 'bg-gradient-to-r from-green-400 to-green-500' : 
                      analysisScore > 50 ? 'bg-gradient-to-r from-yellow-400 to-yellow-500' : 
                      'bg-gradient-to-r from-red-400 to-red-500'
                    }`}
                    style={{ width: `${analysisScore}%` }}
                  ></div>
                </div>
              </div>
            )}
            
            {documentName && (
              <div className="text-white/90 bg-white/10 backdrop-blur-sm px-4 py-2 rounded-lg flex items-center shadow-inner border border-white/30">
                <File className="h-5 w-5 mr-2 text-white/80" />
                <span className="font-medium truncate max-w-[200px]">{documentName}</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}


// File: c:\Users\Taimoor\apa-document-checker\src\components\IssuesPanel.js
'use client';

import { useState, useMemo, useCallback } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import React from 'react';
import { 
  ClipboardList, 
  AlertTriangle, 
  AlertCircle, 
  AlertOctagon, 
  PieChart, 
  Check,
  ChevronDown,
  FileText
} from 'lucide-react';

export default function IssuesPanel() {
  const { issues, activeIssueId, setActiveIssue, applyFix, processingState } = useDocumentStore();
  const [expandedCategories, setExpandedCategories] = useState({
    Critical: true,
    Major: true,
    Minor: false
  });
  
  // Group issues by severity (memoized to prevent recalculation on re-renders)
  const groupedIssues = useMemo(() => {
    return (issues || []).reduce((acc, issue) => {
      if (!acc[issue.severity]) {
        acc[issue.severity] = [];
      }
      acc[issue.severity].push(issue);
      return acc;
    }, {});
  }, [issues]);
  
  // Count issues by severity (memoized)
  const issueCounts = useMemo(() => ({
    Critical: groupedIssues.Critical?.length || 0,
    Major: groupedIssues.Major?.length || 0,
    Minor: groupedIssues.Minor?.length || 0
  }), [groupedIssues]);
  
  // Toggle category expansion (use useCallback to prevent unnecessary function recreation)
  const toggleCategory = useCallback((category) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  }, []);
  
  // Calculate compliance score (memoized)
  const { totalIssues, weightedScore } = useMemo(() => {
    const total = issueCounts.Critical + issueCounts.Major + issueCounts.Minor;
    const score = total > 0 
      ? Math.max(0, 100 - (issueCounts.Critical * 5 + issueCounts.Major * 3 + issueCounts.Minor)) 
      : null;
    return { totalIssues: total, weightedScore: score };
  }, [issueCounts]);
  
  return (
    <div className="h-full bg-gray-50 p-4">
      <div className="flex justify-between items-center mb-5">
        <h2 className="text-xl font-bold text-gray-800 flex items-center">
          <ClipboardList className="h-6 w-6 mr-2 text-blue-600" />
          Document Issues
        </h2>
        {totalIssues > 0 && (
          <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full flex items-center">
            <span className="w-2 h-2 bg-blue-500 rounded-full mr-1"></span>
            {totalIssues} {totalIssues === 1 ? 'Issue' : 'Issues'}
          </span>
        )}
      </div>
      
      {totalIssues > 0 ? (
        <div className="space-y-5">
          {/* Critical Issues */}
          {issueCounts.Critical > 0 && (
            <IssueCategory 
              title="Critical Issues" 
              count={issueCounts.Critical} 
              severity="Critical"
              expanded={expandedCategories.Critical}
              toggleExpanded={() => toggleCategory('Critical')}
            >
              {expandedCategories.Critical && groupedIssues.Critical.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
          
          {/* Major Issues */}
          {issueCounts.Major > 0 && (
            <IssueCategory 
              title="Major Issues" 
              count={issueCounts.Major} 
              severity="Major"
              expanded={expandedCategories.Major}
              toggleExpanded={() => toggleCategory('Major')}
            >
              {expandedCategories.Major && groupedIssues.Major.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
          
          {/* Minor Issues */}
          {issueCounts.Minor > 0 && (
            <IssueCategory 
              title="Minor Issues" 
              count={issueCounts.Minor} 
              severity="Minor"
              expanded={expandedCategories.Minor}
              toggleExpanded={() => toggleCategory('Minor')}
            >
              {expandedCategories.Minor && groupedIssues.Minor.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
        </div>
      ) : issues.length === 0 ? (
        <div className="flex flex-col items-center justify-center py-16 text-gray-500">
          <div className="bg-gray-100 p-4 rounded-full mb-4 flex items-center justify-center">
            <FileText className="h-12 w-12 text-gray-400" />
          </div>
          <p className="text-xl font-medium text-gray-600">No document loaded</p>
          <p className="mt-2 text-gray-500 max-w-xs text-center">Upload a document using the button above to check it against APA 7th Edition guidelines</p>
        </div>
      ) : (
        <div className="bg-gradient-to-r from-green-50 to-emerald-50 p-6 rounded-lg border border-green-100 shadow-sm">
          <div className="flex items-center">
            <div className="bg-green-100 p-2 rounded-full flex items-center justify-center">
              <Check className="h-8 w-8 text-green-600" />
            </div>
            <div className="ml-4">
              <p className="text-lg font-semibold text-green-800">Perfect! No APA issues found.</p>
              <p className="text-sm mt-1 text-green-700">Your document follows APA 7th Edition guidelines.</p>
            </div>
          </div>
        </div>
      )}
      
      {/* Document Statistics */}
      {issues.length > 0 && (
        <div className="mt-6 bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
          <h3 className="text-sm font-semibold text-gray-700 mb-4 flex items-center">
            <PieChart className="h-4 w-4 mr-1 text-blue-500" />
            Document Statistics
          </h3>
          <div className="grid grid-cols-2 gap-4">
            <div className="bg-gray-50 p-3 rounded-md border border-gray-100">
              <p className="text-xs text-gray-500 mb-1">Compliance Score</p>
              <div className="flex items-center">
                <div className={`w-2 h-8 rounded-full mr-2 ${
                  weightedScore > 80 ? 'bg-green-500' : weightedScore > 50 ? 'bg-yellow-500' : 'bg-red-500'
                }`}></div>
                <p className="text-2xl font-bold text-gray-800">{weightedScore}%</p>
              </div>
            </div>
            <div className="bg-gray-50 p-3 rounded-md border border-gray-100">
              <p className="text-xs text-gray-500 mb-1">Issue Breakdown</p>
              <div className="flex space-x-3 items-end">
                {issueCounts.Critical > 0 && (
                  <div className="flex flex-col items-center">
                    <span className="text-xs text-red-600">{issueCounts.Critical}</span>
                    <div className="bg-red-500 w-4 rounded-t-sm" style={{height: `${issueCounts.Critical * 6}px`}}></div>
                    <span className="text-xs text-gray-500 mt-1">Critical</span>
                  </div>
                )}
                {issueCounts.Major > 0 && (
                  <div className="flex flex-col items-center">
                    <span className="text-xs text-orange-600">{issueCounts.Major}</span>
                    <div className="bg-orange-500 w-4 rounded-t-sm" style={{height: `${issueCounts.Major * 6}px`}}></div>
                    <span className="text-xs text-gray-500 mt-1">Major</span>
                  </div>
                )}
                {issueCounts.Minor > 0 && (
                  <div className="flex flex-col items-center">
                    <span className="text-xs text-blue-600">{issueCounts.Minor}</span>
                    <div className="bg-blue-500 w-4 rounded-t-sm" style={{height: `${issueCounts.Minor * 6}px`}}></div>
                    <span className="text-xs text-gray-500 mt-1">Minor</span>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Memoize the IssueCategory component to prevent unnecessary renders
const IssueCategory = React.memo(function IssueCategory({ title, count, severity, expanded, toggleExpanded, children }) {
  // Set colors based on severity
  const getStyles = () => {
    switch (severity) {
      case 'Critical': 
        return {
          bg: 'bg-gradient-to-r from-red-50 to-red-100',
          text: 'text-red-800',
          border: 'border-red-200',
          icon: 'text-red-500',
          badge: 'bg-red-500',
          shadow: 'shadow-red-100'
        };
      case 'Major': 
        return {
          bg: 'bg-gradient-to-r from-orange-50 to-amber-100',
          text: 'text-orange-800',
          border: 'border-orange-200',
          icon: 'text-orange-500',
          badge: 'bg-orange-500',
          shadow: 'shadow-orange-100'
        };
      case 'Minor': 
        return {
          bg: 'bg-gradient-to-r from-blue-50 to-blue-100',
          text: 'text-blue-800',
          border: 'border-blue-200',
          icon: 'text-blue-500',
          badge: 'bg-blue-500',
          shadow: 'shadow-blue-100'
        };
      default: 
        return {
          bg: 'bg-gray-100',
          text: 'text-gray-800',
          border: 'border-gray-200',
          icon: 'text-gray-500',
          badge: 'bg-gray-500',
          shadow: 'shadow-gray-100'
        };
    }
  };
  
  const styles = getStyles();
  
  // Get icon based on severity
  const getIcon = () => {
    switch (severity) {
      case 'Critical':
        return <AlertOctagon className="h-5 w-5 mr-2" />;
      case 'Major':
        return <AlertTriangle className="h-5 w-5 mr-2" />;
      case 'Minor':
        return <AlertCircle className="h-5 w-5 mr-2" />;
      default:
        return null;
    }
  };
  
  return (
    <div className={`rounded-lg overflow-hidden border ${styles.border} shadow-sm ${styles.shadow} issue-category hover-shadow`}>
      <button 
        onClick={toggleExpanded}
        className={`w-full flex justify-between items-center px-5 py-3.5 ${styles.bg} ${styles.text} transition-all duration-200 hover:shadow-inner`}
      >
        <span className="font-medium flex items-center text-base">
          <span className={`${styles.icon}`}>{getIcon()}</span>
          {title}
        </span>
        <div className="flex items-center">
          <span className={`${styles.badge} text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center ${count > 0 ? 'animate-pulse-blue' : ''}`}>{count}</span>
          <ChevronDown 
            className={`h-5 w-5 ml-3 transition-transform duration-300 ease-in-out ${expanded ? 'transform rotate-180' : ''} ${styles.icon}`}
          />
        </div>
      </button>
      
      {expanded && (
        <div className="bg-white divide-y divide-gray-100 transition-all duration-300 ease-in-out animate-fade-in">
          {children}
        </div>
      )}
    </div>
  );
});

// Memoize IssueItem to prevent unnecessary re-renders
const IssueItem = React.memo(function IssueItem({ issue, isActive, onSelect, onApplyFix, isApplyingFix = false }) {
  // Get highlight color based on severity
  const getHighlightColor = () => {
    switch (issue.severity) {
      case 'Critical': return 'border-red-500 bg-red-50';
      case 'Major': return 'border-orange-500 bg-orange-50';
      case 'Minor': return 'border-blue-500 bg-blue-50';
      default: return 'border-gray-300 bg-gray-50';
    }
  };
  
  // Get icon based on severity
  const getIcon = () => {
    switch (issue.severity) {
      case 'Critical':
        return <AlertOctagon className="h-4 w-4 text-red-500" />;
      case 'Major':
        return <AlertTriangle className="h-4 w-4 text-orange-500" />;
      case 'Minor':
        return <AlertCircle className="h-4 w-4 text-blue-500" />;
      default:
        return null;
    }
  };
  
  return (
    <div 
      className={`px-4 py-4 hover:bg-gray-50 cursor-pointer transition-colors duration-150 ease-in-out issue-item ${
        isActive ? `border-l-4 ${getHighlightColor()}` : 'border-l-4 border-transparent'
      }`}
      onClick={onSelect}
    >
      <div className="flex justify-between">
        <div className="flex-1 pr-4">
          <div className="flex items-center mb-1.5">
            {getIcon()}
            <p className="text-sm font-semibold text-gray-800 ml-1">{issue.title}</p>
          </div>
          <p className="text-xs text-gray-600 mb-2 leading-relaxed">{issue.description}</p>
          {issue.text && (
            <div className="mt-2 p-3 bg-gray-50 border border-gray-200 rounded-md text-xs font-mono text-gray-700 relative animate-scale-in">
              <div className="absolute -left-1 -top-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -right-1 -top-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -left-1 -bottom-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -right-1 -bottom-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              "{issue.text}"
            </div>
          )}
        </div>
        
        {issue.hasFix && (
          <div className="flex flex-col justify-center">
            <button 
              onClick={(e) => {
                e.stopPropagation();
                if (!isApplyingFix) onApplyFix();
              }}
              disabled={isApplyingFix}
              className={`flex items-center justify-center text-white text-xs px-4 py-1.5 rounded-md shadow-sm transition-all h-fit whitespace-nowrap font-medium ${
                isApplyingFix 
                  ? 'bg-blue-400 cursor-not-allowed' 
                  : 'bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 hover:shadow hover:translate-y-[-1px]'
              }`}
            >
              {isApplyingFix ? (
                <>
                  <svg className="animate-spin h-3.5 w-3.5 mr-1" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Fixing...
                </>
              ) : (
                <>
                  <Check className="h-3.5 w-3.5 mr-1" />
                  Apply Fix
                </>
              )}
            </button>
          </div>
        )}
      </div>
    </div>
  );
});


// File: c:\Users\Taimoor\apa-document-checker\src\store\documentStore.js
'use client';

import { create } from 'zustand';
import mammoth from 'mammoth';
import { v4 as uuidv4 } from 'uuid';

// Import our APA analysis rules
import { analyzeAPAGuidelines } from '@/utils/apaAnalyzer';

// Helper function to escape special regex characters
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

export const useDocumentStore = create((set, get) => ({
  // Document state
  documentText: null,
  documentHtml: null,
  documentName: null,
  documentStats: {
    wordCount: 0,
    charCount: 0
  },
  
  // Issues and analysis state
  issues: [],
  activeIssueId: null,
  analysisScore: null,
  
  // Export functionality
  exportDocument: () => {
    const { documentHtml, documentName } = get();
    
    if (!documentHtml) {
      alert('No document to export');
      return;
    }
    
    try {
      // Create a full HTML document with proper styling
      const fullHtml = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>APA Formatted Document</title>
          <style>
            body {
              font-family: "Times New Roman", Times, serif;
              font-size: 12pt;
              line-height: 2;
              margin: 1in;
            }
            p {
              text-indent: 0.5in;
              margin-top: 0;
              margin-bottom: 0;
            }
            h1, h2, h3, h4, h5 {
              font-weight: bold;
              margin-top: 1em;
              margin-bottom: 1em;
            }
            .title-page {
              text-align: center;
              margin-bottom: 2em;
            }
            .abstract {
              margin-bottom: 2em;
            }
            .abstract h2 {
              text-align: center;
            }
            .references h2 {
              text-align: center;
            }
            .references p {
              text-indent: 0;
              padding-left: 0.5in;
              text-indent: -0.5in;
              margin-bottom: 1em;
            }
          </style>
        </head>
        <body>
          ${documentHtml}
        </body>
        </html>
      `;
      
      // Create a blob from the HTML
      const blob = new Blob([fullHtml], { type: 'text/html' });
      
      // Create a URL for the blob
      const url = URL.createObjectURL(blob);
      
      // Create a download link
      const a = document.createElement('a');
      a.href = url;
      a.download = documentName ? 
        documentName.replace('.docx', '_APA_formatted.html') : 
        'apa_formatted_document.html';
      
      // Append to the body, click and remove
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Release the URL
      URL.revokeObjectURL(url);
      
      return true;
    } catch (error) {
      console.error('Error exporting document:', error);
      alert('Failed to export document. Please try again.');
      return false;
    }
  },
  
  // Document processing status
  processingState: {
    isUploading: false,
    isAnalyzing: false,
    isApplyingFix: false,
    lastError: null,
    progress: 0,
    currentFixId: null
  },
  
  // Upload a document and convert it to HTML
  uploadDocument: async (file) => {
    try {
      // Set processing state
      set({
        processingState: {
          ...get().processingState,
          isUploading: true,
          lastError: null,
          progress: 10
        }
      });
      
      console.log('Upload document started for file:', file.name);
      // Update document name first for better UX feedback
      set({ documentName: file.name });
      
      // Read the file
      const arrayBuffer = await file.arrayBuffer();
      console.log('File read as array buffer');
      
      // Update progress
      set({
        processingState: {
          ...get().processingState,
          progress: 30
        }
      });
      
      // Convert docx to HTML
      const result = await mammoth.convertToHtml({ arrayBuffer });
      const html = result.value;
      console.log('HTML conversion complete, length:', html?.length);
      
      // Update progress
      set({
        processingState: {
          ...get().processingState,
          progress: 60
        }
      });
      
      // Extract text (for analysis)
      const textResult = await mammoth.extractRawText({ arrayBuffer });
      const text = textResult.value;
      console.log('Text extraction complete, length:', text?.length);
      
      // Check that we have valid content before proceeding
      if (!html || !text) {
        throw new Error('Failed to extract content from document');
      }
      
      // Calculate stats
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      const chars = text.length;
      
      // Update progress
      set({
        processingState: {
          ...get().processingState,
          progress: 90
        }
      });
      
      // Update state in a single batch for consistency
      console.log('Updating document store state with HTML and text');
      set(state => ({
        documentHtml: html,
        documentText: text,
        documentStats: {
          wordCount: words,
          charCount: chars
        },
        issues: [], // Clear previous issues
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          isUploading: false,
          progress: 100
        }
      }));
      
      console.log('Document store state updated successfully');
      return true;
    } catch (error) {
      console.error('Error uploading document:', error);
      
      // Set error state but don't clear existing document if there is one
      set(state => ({
        processingState: {
          ...state.processingState,
          isUploading: false,
          lastError: error.message || 'Failed to process document',
          progress: 0
        }
      }));
      
      return false;
    }
  },
  
  // Analyze the document for APA issues
  analyzeDocument: async () => {
    const { documentText, documentHtml } = get();
    
    if (!documentText) {
      console.warn('Cannot analyze document: No document text available');
      return;
    }
    
    try {
      // Update state to indicate analysis has started
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null
        }
      }));
      
      // Run our APA analysis (wrapped in Promise for better error handling)
      const analysisResults = await new Promise((resolve, reject) => {
        try {
          // Use setTimeout to prevent UI freeze during analysis
          setTimeout(() => {
            try {
              const results = analyzeAPAGuidelines(documentText || '', documentHtml || '');
              resolve(results);
            } catch (error) {
              reject(error);
            }
          }, 0);
        } catch (error) {
          reject(error);
        }
      });
      
      // Map results to our issues format
      const issues = analysisResults.map(issue => ({
        id: uuidv4(),
        title: issue.title,
        description: issue.description,
        text: issue.text,
        severity: issue.severity,
        location: issue.location,
        hasFix: issue.hasFix,
        fixAction: issue.fixAction
      }));
      
      // Calculate compliance score (weighted by severity)
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;
      
      const totalIssues = criticalCount + majorCount + minorCount;
      const analysisScore = totalIssues === 0 
        ? 100 
        : Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 5 + majorCount * 3 + minorCount))));
      
      // Update state in a single batch
      set(state => ({
        issues,
        analysisScore,
        processingState: {
          ...state.processingState,
          isAnalyzing: false
        }
      }));
      
      return { success: true, issueCount: issues.length };
    } catch (error) {
      console.error('Error analyzing document:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          lastError: error.message || 'An error occurred during document analysis'
        }
      }));
      
      return { success: false, error: error.message };
    }
  },
  
  // Set active issue (for navigation and highlighting)
  setActiveIssue: (issueId) => {
    set({ activeIssueId: issueId });
    
    // Safely handle DOM operations in browser environment
    if (typeof document !== 'undefined') {
      // Scroll to the issue in the document
      const { issues } = get();
      const issue = issues?.find(i => i.id === issueId);
      
      if (issue && issue.location) {
        // Find the element with the issue
        const mark = document.querySelector(`mark[data-issue-id="${issueId}"]`);
        if (mark) {
          mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }
  },
  
  // Apply a fix for an issue
  applyFix: async (issueId) => {
    const { issues, documentHtml, documentText } = get();
    const issue = issues.find(i => i.id === issueId);
    
    if (!issue || !issue.hasFix || !issue.fixAction) return;
    
    // Set applying fix state
    set(state => ({
      processingState: {
        ...state.processingState,
        isApplyingFix: true,
        currentFixId: issueId
      }
    }));
    
    // Create a small artificial delay for better UX feedback
    await new Promise(resolve => setTimeout(resolve, 300));
    
    let updatedHtml = documentHtml;
    let updatedText = documentText;
    
    // Apply the fix based on the issue type
    switch (issue.fixAction) {
      case 'addPageNumber':
        // Add page number to direct quote citation
        if (issue.text) {
          const citationMatch = issue.text.match(/\(([^)]+?),\s*(\d{4})\)/);
          if (citationMatch) {
            // Add page number to citation
            const authors = citationMatch[1];
            const year = citationMatch[2];
            const fixedText = issue.text.replace(
              `(${authors}, ${year})`, 
              `(${authors}, ${year}, p. 1)` // Default to p. 1, would be customizable in a real app
            );
            
            // Use safer replacements with exact matches only
            try {
              // Create a RegExp that matches the exact text (without global flag)
              const exactMatchRegex = new RegExp(escapeRegExp(issue.text));
              updatedText = documentText.replace(exactMatchRegex, fixedText);
              updatedHtml = documentHtml.replace(exactMatchRegex, fixedText);
            } catch (error) {
              console.error('Error replacing text:', error);
              // Fallback to simple replace if regex fails
              updatedText = documentText.replace(issue.text, fixedText);
              updatedHtml = documentHtml.replace(issue.text, fixedText);
            }
          }
        }
        break;
        
      case 'fixCitationFormat':
        // Fix citation format issues
        if (issue.text) {
          const citationMatch = issue.text.match(/\(([^)]+?) (\d{4})\)/);
          if (citationMatch) {
            // Add comma between author and year
            const authors = citationMatch[1];
            const year = citationMatch[2];
            const fixedText = issue.text.replace(
              `(${authors} ${year})`, 
              `(${authors}, ${year})`
            );
            
            // Use safer replacements with exact matches only
            try {
              // Create a RegExp that matches the exact text (without global flag)
              const exactMatchRegex = new RegExp(escapeRegExp(issue.text));
              updatedText = documentText.replace(exactMatchRegex, fixedText);
              updatedHtml = documentHtml.replace(exactMatchRegex, fixedText);
            } catch (error) {
              console.error('Error replacing text:', error);
              // Fallback to simple replace if regex fails
              updatedText = documentText.replace(issue.text, fixedText);
              updatedHtml = documentHtml.replace(issue.text, fixedText);
            }
          }
        }
        break;
        
      case 'fixAmpersand':
        // Fix ampersand vs. 'and' in citations
        if (issue.text) {
          // For narrative citations, 'and' is correct
          if (issue.text.includes(' and ')) {
            // This is already correct, but if we need to fix parenthetical citation:
            const fixedText = issue.text.replace(' and ', ' & ');
            // Use safer replacements with exact matches only
            try {
              // Create a RegExp that matches the exact text (without global flag)
              const exactMatchRegex = new RegExp(escapeRegExp(issue.text));
              updatedText = documentText.replace(exactMatchRegex, fixedText);
              updatedHtml = documentHtml.replace(exactMatchRegex, fixedText);
            } catch (error) {
              console.error('Error replacing text:', error);
              // Fallback to simple replace if regex fails
              updatedText = documentText.replace(issue.text, fixedText);
              updatedHtml = documentHtml.replace(issue.text, fixedText);
            }
          }
        }
        break;
        
      case 'addReferencesHeader':
        // Add References header
        updatedText = documentText + '\n\nReferences\n';
        updatedHtml = documentHtml + '<h2>References</h2>';
        break;
        
      case 'reorderReferences':
        // For demo purposes, just mark as fixed
        // In real implementation, this would reorder the references alphabetically
        break;
        
      case 'addTitlePage':
        // Add title page template
        const titlePage = 'Title: APA Formatted Document\nAuthor: Student Name\nInstitution: University Name\nCourse: Course Name\nInstructor: Instructor Name\nDate: ' + new Date().toLocaleDateString();
        updatedText = titlePage + '\n\n' + documentText;
        updatedHtml = '<div style="text-align: center; margin-bottom: 2em;">' +
          '<h1>APA Formatted Document</h1>' +
          '<p>Student Name</p>' +
          '<p>University Name</p>' +
          '<p>Course Name</p>' +
          '<p>Instructor Name</p>' +
          '<p>' + new Date().toLocaleDateString() + '</p>' +
          '</div>' + documentHtml;
        break;
        
      case 'addAbstract':
        // Add abstract template after title page (if exists) or at beginning
        const abstractText = '\n\nAbstract\n\nThis is an abstract placeholder. An abstract should be a brief, comprehensive summary of the contents of the paper, typically 150-250 words.\n\n';
        const abstractHtml = '<h2>Abstract</h2><p>This is an abstract placeholder. An abstract should be a brief, comprehensive summary of the contents of the paper, typically 150-250 words.</p>';
        
        if (documentText.includes('Title:') && documentText.includes('Author:')) {
          // If there's a title page, add after it
          const titlePageEnd = documentText.indexOf('Date:');
          if (titlePageEnd !== -1) {
            const endIndex = documentText.indexOf('\n', titlePageEnd);
            updatedText = documentText.substring(0, endIndex + 1) + abstractText + documentText.substring(endIndex + 1);
            
            // For HTML, add after the first div (assuming first div is title page)
            const firstDivEnd = documentHtml.indexOf('</div>');
            if (firstDivEnd !== -1) {
              updatedHtml = documentHtml.substring(0, firstDivEnd + 6) + abstractHtml + documentHtml.substring(firstDivEnd + 6);
            }
          }
        } else {
          // Add at beginning
          updatedText = abstractText + documentText;
          updatedHtml = abstractHtml + documentHtml;
        }
        break;
        
      case 'fixHeadingLevel':
        // For demo purposes, just mark as fixed
        // In a real implementation, this would fix heading hierarchy
        break;
        
      case 'fixFont':
        // Update the document to use Times New Roman
        updatedHtml = documentHtml.replace(/font-family:[^;]+;/g, 'font-family: "Times New Roman", Times, serif;');
        if (!documentHtml.includes('font-family:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="font-family: \'Times New Roman\', Times, serif;"');
        }
        break;
        
      case 'fixFontSize':
        // Update font size to 12pt
        updatedHtml = documentHtml.replace(/font-size:[^;]+;/g, 'font-size: 12pt;');
        if (!documentHtml.includes('font-size:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="font-size: 12pt;"');
        }
        break;
        
      case 'fixLineSpacing':
        // Update line spacing to double
        updatedHtml = documentHtml.replace(/line-height:[^;]+;/g, 'line-height: 2;');
        if (!documentHtml.includes('line-height:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="line-height: 2;"');
        }
        break;
        
      case 'fixMargins':
        // Set 1-inch margins
        updatedHtml = documentHtml.replace(/margin:[^;]+;/g, 'margin: 1in;');
        if (!documentHtml.includes('margin:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="margin: 1in;"');
        }
        break;
        
      case 'fixIndentation':
        // Set 0.5-inch paragraph indentation
        updatedHtml = documentHtml.replace(/text-indent:[^;]+;/g, 'text-indent: 0.5in;');
        if (!documentHtml.includes('text-indent:')) {
          // Add text-indent to all paragraphs
          updatedHtml = updatedHtml.replace(/<p/g, '<p style="text-indent: 0.5in;"');
        }
        break;
        
      case 'addPageNumbers':
        // Add page numbers - for HTML export, we'll add it in the header
        updatedHtml = documentHtml.replace(/<body/, '<body style="position: relative;"');
        updatedHtml = updatedHtml.replace(/<body([^>]*)>/, 
          '<body$1><div style="position: absolute; top: 0.5in; right: 0.5in; font-family: \'Times New Roman\', Times, serif; font-size: 12pt;">1</div>');
        break;
        
      default:
        // For any other fix actions, just mark as fixed without changing content
        break;
    }
    
    // Remove the fixed issue from issues list
    const updatedIssues = issues.filter(i => i.id !== issueId);
    
    // Update state with modified document and recalculated score
    set(state => ({ 
      documentText: updatedText,
      documentHtml: updatedHtml,
      issues: updatedIssues,
      // Recalculate compliance score
      analysisScore: updatedIssues.length === 0 
        ? 100 
        : Math.max(0, Math.min(100, Math.round(100 - (
            updatedIssues.filter(i => i.severity === 'Critical').length * 5 + 
            updatedIssues.filter(i => i.severity === 'Major').length * 3 + 
            updatedIssues.filter(i => i.severity === 'Minor').length
          )))),
      // Reset the applying fix state
      processingState: {
        ...state.processingState,
        isApplyingFix: false,
        currentFixId: null
      }
    }));
  }
}));


// File: c:\Users\Taimoor\apa-document-checker\src\utils\apaAnalyzer.js
'use client';

// APA 7th Edition Guidelines Analyzer
// This module analyzes documents for compliance with APA 7th Edition guidelines

// Main analysis function
export function analyzeAPAGuidelines(text, html) {
  const issues = [];
  
  // Ensure we have valid inputs
  if (!text || typeof text !== 'string') {
    console.warn('Invalid text provided to APA analyzer');
    return issues;
  }
  
  // Analyze different aspects of the document
  issues.push(...analyzeCitations(text));
  issues.push(...analyzeReferenceList(text));
  issues.push(...analyzeDocumentStructure(text, html || ''));
  issues.push(...analyzeFormatting(html || ''));
  
  return issues;
}

// Analyze in-text citations
function analyzeCitations(text) {
  const issues = [];
  
  // Regular expressions for common citation patterns
  const citationRegex = /\(([^)]+?,\s*\d{4}[^)]*)\)/g;
  const directQuoteRegex = /[""][^""]+?[""]\s*\([^)]+?,\s*\d{4}(?:,\s*p\.?\s*\d+)?\)/g;
  const multipleAuthorsRegex = /\(([^)]+?)\s*&\s*([^)]+?),\s*(\d{4})\)/g;
  
  // Check for citations without page numbers in direct quotes
  let match;
  const quotesWithoutPages = [];
  
  // Find direct quotes
  const directQuotes = [];
  while ((match = directQuoteRegex.exec(text)) !== null) {
    directQuotes.push(match[0]);
  }
  
  // Check if direct quotes have page numbers
  for (const quote of directQuotes) {
    if (!quote.match(/p\.?\s*\d+/i)) {
      quotesWithoutPages.push(quote);
    }
  }
  
  // Add issues for quotes without page numbers
  for (const quote of quotesWithoutPages) {
    issues.push({
      title: "Missing page number in direct quote",
      description: "Direct quotes must include a page number in the citation",
      text: quote,
      severity: "Major",
      location: { text: quote },
      hasFix: true,
      fixAction: "addPageNumber"
    });
  }
  
  // Check for incorrect citation format
  while ((match = citationRegex.exec(text)) !== null) {
    const citation = match[0];
    const contents = match[1];
    
    // Check for missing comma between author and year
    if (!contents.includes(",")) {
      issues.push({
        title: "Incorrect citation format",
        description: "Citation should have a comma between author and year",
        text: citation,
        severity: "Minor",
        location: { text: citation },
        hasFix: true,
        fixAction: "fixCitationFormat"
      });
    }
  }
  
  // Check for ampersand usage in parenthetical citations
  while ((match = multipleAuthorsRegex.exec(text)) !== null) {
    // This is correct format for parenthetical citations
  }
  
  // Check for ampersand vs. 'and' in narrative citations
  const narrativeCitationRegex = /([A-Z][a-z]+) and ([A-Z][a-z]+) \((\d{4})\)/g;
  while ((match = narrativeCitationRegex.exec(text)) !== null) {
    issues.push({
      title: "Incorrect use of 'and' in citation",
      description: "Use ampersand (&) in parenthetical citations, 'and' in narrative citations",
      text: match[0],
      severity: "Minor",
      location: { text: match[0] },
      hasFix: true,
      fixAction: "fixAmpersand"
    });
  }
  
  // Check for et al. usage with 3+ authors
  const etAlRegex = /\(([^)]+?)\s*et\s*al\.,\s*(\d{4}[^)]*)\)/g;
  while ((match = etAlRegex.exec(text)) !== null) {
    // This is generally correct, but we'd need to check the author count
    // in a real implementation
  }
  
  return issues;
}

// Analyze reference list
function analyzeReferenceList(text) {
  const issues = [];
  
  // Check if References header exists
  if (!text.match(/References/i)) {
    issues.push({
      title: "Missing References section",
      description: "Document should include a References section with proper heading",
      text: null,
      severity: "Critical",
      location: null,
      hasFix: true,
      fixAction: "addReferencesHeader"
    });
    
    // If no references section, return early
    return issues;
  }
  
  // Extract references section
  const referencesMatch = text.match(/References([\s\S]+)(?:$|^#)/i);
  if (!referencesMatch || !referencesMatch[1]) return issues;
  
  const referencesText = referencesMatch[1].trim();
  const referenceEntries = referencesText.split(/\n\s*\n/).filter(Boolean);
  
  // Check for alphabetical ordering
  const authorLastNames = referenceEntries.map(entry => {
    const match = entry.match(/^([^,]+)/);
    return match ? match[1].trim() : '';
  });
  
  const sortedLastNames = [...authorLastNames].sort((a, b) => 
    a.localeCompare(b, undefined, { sensitivity: 'base' })
  );
  
  for (let i = 0; i < authorLastNames.length; i++) {
    if (authorLastNames[i] !== sortedLastNames[i]) {
      issues.push({
        title: "References not in alphabetical order",
        description: "Reference list must be in alphabetical order by first author's last name",
        text: referenceEntries[i],
        severity: "Major",
        location: { text: referenceEntries[i] },
        hasFix: true,
        fixAction: "reorderReferences"
      });
      break;
    }
  }
  
  // Check each reference entry format
  for (const entry of referenceEntries) {
    // Check for DOI if available
    if ((entry.includes('journal') || entry.includes('Journal')) && !entry.includes('doi.org') && !entry.includes('DOI:')) {
      issues.push({
        title: "Missing DOI in journal reference",
        description: "Journal references should include DOI when available",
        text: entry,
        severity: "Minor",
        location: { text: entry },
        hasFix: false
      });
    }
    
    // Check for incorrect italicization in journal titles
    if (entry.includes('journal') || entry.includes('Journal')) {
      // In a real implementation, we would check for proper italics
      // but this would require HTML analysis
    }
    
    // Check for hanging indentation (would need HTML analysis in real implementation)
  }
  
  return issues;
}

// Analyze document structure
function analyzeDocumentStructure(text, html) {
  const issues = [];
  
  // Check for title page elements
  if (!text.match(/^[\s\S]{0,500}Title:/im)) {
    issues.push({
      title: "Missing title page",
      description: "APA papers should include a title page with paper title, author name, institution, course, instructor, and date",
      text: null,
      severity: "Critical",
      location: { position: 0 },
      hasFix: true,
      fixAction: "addTitlePage"
    });
  }
  
  // Check for abstract
  if (!text.match(/Abstract[\s\n]/i)) {
    issues.push({
      title: "Missing abstract",
      description: "APA papers should include an abstract after the title page",
      text: null,
      severity: "Major",
      location: null,
      hasFix: true,
      fixAction: "addAbstract"
    });
  }
  
  // Check for heading levels
  const headingRegex = /^(#{1,6})\s+(.+)$/gm;
  const headings = [];
  let match;
  
  while ((match = headingRegex.exec(text)) !== null) {
    headings.push({
      level: match[1].length,
      text: match[2]
    });
  }
  
  // Check for proper heading hierarchy
  for (let i = 1; i < headings.length; i++) {
    if (headings[i].level > headings[i-1].level + 1) {
      issues.push({
        title: "Improper heading hierarchy",
        description: "Headings should not skip levels (e.g., from H1 to H3)",
        text: `${headings[i-1].text}  ${headings[i].text}`,
        severity: "Major",
        location: { text: headings[i].text },
        hasFix: true,
        fixAction: "fixHeadingLevel"
      });
    }
  }
  
  return issues;
}

// Analyze formatting
function analyzeFormatting(html) {
  const issues = [];
  
  // Ensure html is a string
  if (!html || typeof html !== 'string') {
    return issues;
  }
  
  // Check font family
  const fontCheck = html.match(/font-family:\s*['"]([^'"]+)['"]/i);
  if (fontCheck && !fontCheck[1].toLowerCase().includes('times new roman')) {
    issues.push({
      title: "Incorrect font",
      description: "APA 7th edition requires 12-point Times New Roman font",
      text: `Font found: ${fontCheck[1]}`,
      severity: "Minor",
      location: { position: html.indexOf(fontCheck[0]) },
      hasFix: true,
      fixAction: "fixFont"
    });
  } else if (!fontCheck) {
    issues.push({
      title: "Font not specified",
      description: "APA 7th edition requires 12-point Times New Roman font",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "fixFont"
    });
  }
  
  // Check font size
  const fontSizeCheck = html.match(/font-size:\s*(\d+(?:\.\d+)?)(pt|px|em|rem)/i);
  if (fontSizeCheck) {
    const size = parseFloat(fontSizeCheck[1]);
    const unit = fontSizeCheck[2].toLowerCase();
    
    // Convert to pt for comparison
    let ptSize;
    switch (unit) {
      case 'px': ptSize = size * 0.75; break; // Approximate px to pt conversion
      case 'em': ptSize = size * 12; break;   // Assuming 1em = 12pt
      case 'rem': ptSize = size * 12; break;  // Assuming 1rem = 12pt
      case 'pt': ptSize = size; break;
      default: ptSize = 0;
    }
    
    if (Math.abs(ptSize - 12) > 0.5) { // Allow some tolerance
      issues.push({
        title: "Incorrect font size",
        description: "APA 7th edition requires 12-point Times New Roman font",
        text: `Font size found: ${fontSizeCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(fontSizeCheck[0]) },
        hasFix: true,
        fixAction: "fixFontSize"
      });
    }
  }
  
  // Check line spacing
  const lineSpacingCheck = html.match(/line-height:\s*([^\s;]+)/i);
  if (lineSpacingCheck) {
    const lineHeight = lineSpacingCheck[1];
    // Check if line spacing is approximately double
    // Double spacing typically ranges from 1.9 to 2.1, or 200%
    if (lineHeight !== '2' && lineHeight !== '2.0' && 
        lineHeight !== 'double' && lineHeight !== '200%') {
      issues.push({
        title: "Incorrect line spacing",
        description: "APA 7th edition requires double-spaced text",
        text: `Line spacing found: ${lineSpacingCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(lineSpacingCheck[0]) },
        hasFix: true,
        fixAction: "fixLineSpacing"
      });
    }
  } else {
    issues.push({
      title: "Line spacing not specified",
      description: "APA 7th edition requires double-spaced text",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "fixLineSpacing"
    });
  }
  
  // Check margins
  const marginCheck = html.match(/margin:\s*([^;]+)/i);
  if (marginCheck) {
    // Check if any margin is less than 1 inch (approximately 72px or 6em)
    const margins = marginCheck[1].split(/\s+/);
    const hasSmallMargin = margins.some(margin => {
      const value = parseFloat(margin);
      const unit = margin.match(/[a-z%]+$/i)?.[0] || '';
      
      if (unit === 'in' && value < 1) return true;
      if (unit === 'cm' && value < 2.54) return true;
      if (unit === 'mm' && value < 25.4) return true;
      if (unit === 'pt' && value < 72) return true;
      if (unit === 'px' && value < 96) return true;
      if ((unit === 'em' || unit === 'rem') && value < 6) return true;
      
      return false;
    });
    
    if (hasSmallMargin) {
      issues.push({
        title: "Insufficient margins",
        description: "APA 7th edition requires 1-inch margins on all sides",
        text: `Margins found: ${marginCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(marginCheck[0]) },
        hasFix: true,
        fixAction: "fixMargins"
      });
    }
  }
  
  // Check paragraph indentation
  const textIndentCheck = html.match(/text-indent:\s*([^;]+)/i);
  if (textIndentCheck) {
    const indent = textIndentCheck[1];
    const value = parseFloat(indent);
    const unit = indent.match(/[a-z%]+$/i)?.[0] || '';
    
    let isCorrect = false;
    
    // Check if indent is approximately 0.5 inch
    if (unit === 'in' && Math.abs(value - 0.5) < 0.1) isCorrect = true;
    if (unit === 'cm' && Math.abs(value - 1.27) < 0.2) isCorrect = true;
    if (unit === 'mm' && Math.abs(value - 12.7) < 2) isCorrect = true;
    if (unit === 'pt' && Math.abs(value - 36) < 5) isCorrect = true;
    if (unit === 'px' && Math.abs(value - 48) < 5) isCorrect = true;
    if ((unit === 'em' || unit === 'rem') && Math.abs(value - 3) < 0.5) isCorrect = true;
    
    if (!isCorrect) {
      issues.push({
        title: "Incorrect paragraph indentation",
        description: "APA 7th edition requires 0.5-inch indentation for the first line of each paragraph",
        text: `Text indent found: ${textIndentCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(textIndentCheck[0]) },
        hasFix: true,
        fixAction: "fixIndentation"
      });
    }
  } else {
    // Check if paragraphs exist without indentation
    if (html.includes('<p') && !html.includes('text-indent')) {
      issues.push({
        title: "Missing paragraph indentation",
        description: "APA 7th edition requires 0.5-inch indentation for the first line of each paragraph",
        text: null,
        severity: "Minor",
        location: null,
        hasFix: true,
        fixAction: "fixIndentation"
      });
    }
  }
  
  // Check for page numbers
  if (!html.includes('page-number') && !html.includes('page number')) {
    issues.push({
      title: "Missing page numbers",
      description: "APA 7th edition requires page numbers in the top-right corner of each page",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "addPageNumbers"
    });
  }
  
  return issues;
}


