// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\server\docx-processor.js
// server/docx-processor.js
const express = require('express');
const multer = require('multer');
const { Document, Packer, Paragraph, TextRun } = require('docx');
const mammoth = require('mammoth');
const fs = require('fs').promises;

const app = express();
const upload = multer({ dest: 'uploads/' });

// Enhanced DOCX processor that extracts both content AND formatting
class DocxProcessor {
  async processDocument(filePath) {
    try {
      // Read the original DOCX file
      const buffer = await fs.readFile(filePath);
      
      // Extract content with mammoth
      const contentResult = await mammoth.convertToHtml({ buffer });
      
      // Extract raw text for analysis
      const textResult = await mammoth.extractRawText({ buffer });
      
      // CRITICAL: Extract formatting information directly from DOCX XML
      const formattingInfo = await this.extractFormattingDetails(buffer);
      
      // Extract document structure
      const structure = await this.extractDocumentStructure(buffer);
      
      return {
        html: contentResult.value,
        text: textResult.value,
        formatting: formattingInfo,
        structure: structure,
        messages: [...contentResult.messages, ...textResult.messages]
      };
      
    } catch (error) {
      console.error('Error processing DOCX:', error);
      throw error;
    }
  }
  
  async extractFormattingDetails(buffer) {
    // Use docx library to read document properties
    const JSZip = require('jszip');
    const xml2js = require('xml2js');
    
    try {
      const zip = await JSZip.loadAsync(buffer);
      
      // Parse document.xml for content formatting
      const documentXml = await zip.file('word/document.xml').async('text');
      const stylesXml = await zip.file('word/styles.xml').async('text');
      
      const parser = new xml2js.Parser();
      const documentData = await parser.parseStringPromise(documentXml);
      const stylesData = await parser.parseStringPromise(stylesXml);
      
      return this.parseFormattingFromXML(documentData, stylesData);
      
    } catch (error) {
      console.error('Error extracting formatting:', error);
      return this.getDefaultFormatting();
    }
  }
  
  parseFormattingFromXML(documentData, stylesData) {
    const formatting = {
      font: {
        family: null,
        size: null
      },
      spacing: {
        line: null,
        paragraph: null
      },
      margins: {
        top: null,
        bottom: null,
        left: null,
        right: null
      },
      indentation: {
        firstLine: null,
        hanging: null
      },
      paragraphs: []
    };
    
    try {
      // Extract page margins from sectPr
      const sectPr = documentData['w:document']['w:body'][0]['w:sectPr'];
      if (sectPr && sectPr[0]['w:pgMar']) {
        const margins = sectPr[0]['w:pgMar'][0]['$'];
        formatting.margins = {
          top: this.twipsToInches(parseInt(margins['w:top'] || 0)),
          bottom: this.twipsToInches(parseInt(margins['w:bottom'] || 0)),
          left: this.twipsToInches(parseInt(margins['w:left'] || 0)),
          right: this.twipsToInches(parseInt(margins['w:right'] || 0))
        };
      }
      
      // Extract paragraph formatting from each paragraph
      const paragraphs = documentData['w:document']['w:body'][0]['w:p'] || [];
      
      paragraphs.forEach((para, index) => {
        const paraFormatting = {
          index,
          font: { family: null, size: null },
          spacing: { line: null, before: null, after: null },
          indentation: { firstLine: null, hanging: null, left: null },
          alignment: null
        };
        
        // Check paragraph properties
        if (para['w:pPr']) {
          const pPr = para['w:pPr'][0];
          
          // Spacing
          if (pPr['w:spacing']) {
            const spacing = pPr['w:spacing'][0]['$'];
            paraFormatting.spacing.line = spacing['w:line'] ? 
              (parseInt(spacing['w:line']) / 240) : null; // Convert to "line" units
            paraFormatting.spacing.before = spacing['w:before'] ? 
              this.twipsToPoints(parseInt(spacing['w:before'])) : null;
            paraFormatting.spacing.after = spacing['w:after'] ? 
              this.twipsToPoints(parseInt(spacing['w:after'])) : null;
          }
          
          // Indentation
          if (pPr['w:ind']) {
            const ind = pPr['w:ind'][0]['$'];
            paraFormatting.indentation.firstLine = ind['w:firstLine'] ? 
              this.twipsToInches(parseInt(ind['w:firstLine'])) : null;
            paraFormatting.indentation.hanging = ind['w:hanging'] ? 
              this.twipsToInches(parseInt(ind['w:hanging'])) : null;
            paraFormatting.indentation.left = ind['w:left'] ? 
              this.twipsToInches(parseInt(ind['w:left'])) : null;
          }
          
          // Alignment
          if (pPr['w:jc']) {
            paraFormatting.alignment = pPr['w:jc'][0]['$']['w:val'];
          }
        }
        
        // Check run properties for font information
        if (para['w:r']) {
          const runs = para['w:r'];
          const firstRun = runs[0];
          
          if (firstRun && firstRun['w:rPr']) {
            const rPr = firstRun['w:rPr'][0];
            
            // Font family
            if (rPr['w:rFonts']) {
              paraFormatting.font.family = rPr['w:rFonts'][0]['$']['w:ascii'] || null;
            }
            
            // Font size
            if (rPr['w:sz']) {
              paraFormatting.font.size = parseInt(rPr['w:sz'][0]['$']['w:val']) / 2; // Convert half-points to points
            }
          }
        }
        
        formatting.paragraphs.push(paraFormatting);
      });
      
      // Set document-level defaults from first paragraph
      if (formatting.paragraphs.length > 0) {
        const firstPara = formatting.paragraphs[0];
        formatting.font = { ...firstPara.font };
        formatting.spacing.line = firstPara.spacing.line;
        formatting.indentation = { ...firstPara.indentation };
      }
      
    } catch (error) {
      console.error('Error parsing formatting XML:', error);
    }
    
    return formatting;
  }
  
  async extractDocumentStructure(buffer) {
    // Extract headings, sections, citations, references
    const JSZip = require('jszip');
    const xml2js = require('xml2js');
    
    try {
      const zip = await JSZip.loadAsync(buffer);
      const documentXml = await zip.file('word/document.xml').async('text');
      
      const parser = new xml2js.Parser();
      const documentData = await parser.parseStringPromise(documentXml);
      
      return this.parseDocumentStructure(documentData);
      
    } catch (error) {
      console.error('Error extracting structure:', error);
      return { headings: [], sections: [], citations: [], references: [] };
    }
  }
  
  parseDocumentStructure(documentData) {
    const structure = {
      headings: [],
      sections: [],
      citations: [],
      references: []
    };
    
    try {
      const paragraphs = documentData['w:document']['w:body'][0]['w:p'] || [];
      
      paragraphs.forEach((para, index) => {
        // Extract text content
        const textRuns = para['w:r'] || [];
        let text = '';
        
        textRuns.forEach(run => {
          if (run['w:t']) {
            if (Array.isArray(run['w:t'])) {
              text += run['w:t'].map(t => typeof t === 'string' ? t : t._).join('');
            } else {
              text += typeof run['w:t'] === 'string' ? run['w:t'] : (run['w:t']._ || '');
            }
          }
        });
        
        // Detect headings (by style or formatting)
        let isHeading = false;
        let headingLevel = 0;
        
        if (para['w:pPr'] && para['w:pPr'][0]['w:pStyle']) {
          const styleName = para['w:pPr'][0]['w:pStyle'][0]['$']['w:val'];
          const headingMatch = styleName.match(/Heading(\d+)/i);
          if (headingMatch) {
            isHeading = true;
            headingLevel = parseInt(headingMatch[1]);
          }
        }
        
        if (isHeading) {
          structure.headings.push({
            text: text.trim(),
            level: headingLevel,
            paragraphIndex: index
          });
        }
        
        // Detect citations (simple pattern matching)
        const citationPattern = /\(([^)]+),\s*(\d{4})[^)]*\)/g;
        let citationMatch;
        while ((citationMatch = citationPattern.exec(text)) !== null) {
          structure.citations.push({
            text: citationMatch[0],
            author: citationMatch[1],
            year: citationMatch[2],
            paragraphIndex: index
          });
        }
        
        // Detect if we're in References section
        if (text.trim().toLowerCase() === 'references') {
          structure.sections.push({
            type: 'references',
            startIndex: index,
            title: 'References'
          });
        }
      });
      
    } catch (error) {
      console.error('Error parsing document structure:', error);
    }
    
    return structure;
  }
  
  // Helper functions for unit conversion
  twipsToInches(twips) {
    return twips / 1440; // 1440 twips = 1 inch
  }
  
  twipsToPoints(twips) {
    return twips / 20; // 20 twips = 1 point
  }
  
  getDefaultFormatting() {
    return {
      font: { family: null, size: null },
      spacing: { line: null, paragraph: null },
      margins: { top: null, bottom: null, left: null, right: null },
      indentation: { firstLine: null, hanging: null },
      paragraphs: []
    };
  }
}

// API endpoint
app.post('/api/upload-docx', upload.single('document'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const processor = new DocxProcessor();
    const result = await processor.processDocument(req.file.path);
    
    // Clean up uploaded file
    await fs.unlink(req.file.path);
    
    res.json({
      success: true,
      document: result
    });
    
  } catch (error) {
    console.error('Error processing document:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to process document',
      details: error.message 
    });
  }
});

module.exports = { DocxProcessor, app };

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\server\index.js
// server/index.js - Fixed router import
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const path = require('path');
const fs = require('fs').promises;

const app = express();
const PORT = process.env.PORT || 3001;

// Security middleware
app.use(helmet({
  crossOriginEmbedderPolicy: false, // Needed for file uploads
}));

// CORS configuration
app.use(cors({
  origin: process.env.NODE_ENV === 'production' 
    ? ['https://your-domain.com'] // Replace with your domain
    : ['http://localhost:3000', 'http://127.0.0.1:3000'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Accept']
}));

// Body parsing middleware
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Create uploads directory if it doesn't exist
const uploadsDir = path.join(__dirname, 'uploads');
fs.mkdir(uploadsDir, { recursive: true }).catch(console.error);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'healthy', 
    timestamp: new Date().toISOString(),
    service: 'APA Document Checker Server'
  });
});

// Import and use document processing routes - FIXED
const docxRoutes = require('./routes/docx');
app.use('/api', docxRoutes);

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('Server Error:', error);
  
  // Handle multer errors (file upload errors)
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({
      success: false,
      error: 'File too large. Maximum size is 10MB.',
      code: 'FILE_TOO_LARGE'
    });
  }
  
  if (error.code === 'LIMIT_UNEXPECTED_FILE') {
    return res.status(400).json({
      success: false,
      error: 'Unexpected file field. Please upload a DOCX file.',
      code: 'UNEXPECTED_FILE'
    });
  }
  
  // Handle other errors
  res.status(500).json({
    success: false,
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong',
    code: 'INTERNAL_ERROR'
  });
});

// 404 handler for API routes
app.use('/api/*', (req, res) => {
  res.status(404).json({
    success: false,
    error: 'API endpoint not found',
    code: 'NOT_FOUND'
  });
});

// Start server
app.listen(PORT, (err) => {
  if (err) {
    console.error('Failed to start server:', err);
    process.exit(1);
  }
  
  console.log(`ðŸš€ APA Document Checker Server running on port ${PORT}`);
  console.log(`ðŸ“‹ Health check: http://localhost:${PORT}/api/health`);
  console.log(`ðŸ“„ Document upload: http://localhost:${PORT}/api/upload-docx`);
  console.log(`ðŸ  Environment: ${process.env.NODE_ENV || 'development'}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');  
  process.exit(0);
});

module.exports = app;



// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\server\processors\DocxProcessor.js
// server/processors/DocxProcessor.js - Fixed bracket notation
const JSZip = require('jszip');
const xml2js = require('xml2js');
const mammoth = require('mammoth');
const fs = require('fs').promises;

class DocxProcessor {
  constructor() {
    this.parser = new xml2js.Parser({
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false
    });
    
    // APA formatting standards for comparison
    this.apaStandards = {
      font: { family: 'Times New Roman', size: 12 },
      spacing: { line: 2.0 },
      margins: { top: 1.0, bottom: 1.0, left: 1.0, right: 1.0 },
      indentation: { firstLine: 0.5 }
    };
  }
  
  /**
   * Main processing function
   */
  async processDocument(filePath) {
    try {
      console.log('Starting DOCX processing for:', filePath);
      
      const buffer = await fs.readFile(filePath);
      
      // Extract content with mammoth (for clean HTML)
      const contentResult = await mammoth.convertToHtml({ buffer });
      const textResult = await mammoth.extractRawText({ buffer });
      
      // Extract rich formatting information
      const formattingInfo = await this.extractFormattingDetails(buffer);
      
      // Extract document structure
      const structure = await this.extractDocumentStructure(buffer);
      
      // Extract styles information
      const styles = await this.extractStyles(buffer);
      
      console.log('DOCX processing completed successfully');
      
      return {
        html: contentResult.value,
        text: textResult.value,
        formatting: formattingInfo,
        structure: structure,
        styles: styles,
        messages: [...contentResult.messages, ...textResult.messages],
        processingInfo: {
          timestamp: new Date().toISOString(),
          fileSize: buffer.length,
          wordCount: textResult.value.split(/\s+/).filter(Boolean).length
        }
      };
      
    } catch (error) {
      console.error('Error processing DOCX:', error);
      throw new Error(`DOCX processing failed: ${error.message}`);
    }
  }
  
  /**
   * Extract detailed formatting information from DOCX XML
   */
  async extractFormattingDetails(buffer) {
    try {
      const zip = await JSZip.loadAsync(buffer);
      
      // Read document.xml for content and formatting
      const documentXml = await zip.file('word/document.xml').async('text');
      const documentData = await this.parser.parseStringPromise(documentXml);
      
      // Read settings.xml for document-level settings
      let settingsData = null;
      const settingsFile = zip.file('word/settings.xml');
      if (settingsFile) {
        const settingsXml = await settingsFile.async('text');
        settingsData = await this.parser.parseStringPromise(settingsXml);
      }
      
      return this.parseFormattingFromXML(documentData, settingsData);
      
    } catch (error) {
      console.error('Error extracting formatting:', error);
      return this.getDefaultFormatting();
    }
  }
  
  /**
   * Parse formatting information from XML data
   */
  parseFormattingFromXML(documentData, settingsData) {
    const formatting = {
      document: {
        font: { family: null, size: null },
        spacing: { line: null, paragraph: null },
        margins: { top: null, bottom: null, left: null, right: null },
        indentation: { firstLine: null, hanging: null },
        pageSetup: {}
      },
      paragraphs: [],
      runs: [], // Individual text runs with their formatting
      compliance: {}
    };
    
    try {
      const body = documentData['w:document']['w:body'];
      
      // Extract page setup and margins from sectPr (Section Properties)
      const sectPr = body['w:sectPr'];
      if (sectPr) {
        // Page margins - FIXED bracket notation
        const pgMar = sectPr['w:pgMar'];
        if (pgMar && pgMar.$) {
          formatting.document.margins = {
            top: this.twipsToInches(parseInt(pgMar.$['w:top'] || 0)),
            bottom: this.twipsToInches(parseInt(pgMar.$['w:bottom'] || 0)),
            left: this.twipsToInches(parseInt(pgMar.$['w:left'] || 0)),
            right: this.twipsToInches(parseInt(pgMar.$['w:right'] || 0))
          };
        }
        
        // Page size - FIXED bracket notation
        const pgSz = sectPr['w:pgSz'];
        if (pgSz && pgSz.$) {
          formatting.document.pageSetup = {
            width: this.twipsToInches(parseInt(pgSz.$['w:w'] || 0)),
            height: this.twipsToInches(parseInt(pgSz.$['w:h'] || 0)),
            orientation: pgSz.$['w:orient'] || 'portrait'
          };
        }
      }
      
      // Extract paragraph-level formatting
      const paragraphs = Array.isArray(body['w:p']) ? body['w:p'] : [body['w:p']].filter(Boolean);
      
      paragraphs.forEach((para, index) => {
        if (!para) return;
        
        const paraFormatting = {
          index,
          text: '',
          font: { family: null, size: null, bold: false, italic: false },
          spacing: { line: null, before: null, after: null },
          indentation: { firstLine: null, hanging: null, left: null, right: null },
          alignment: null,
          style: null,
          runs: []
        };
        
        // Extract paragraph properties
        const pPr = para['w:pPr'];
        if (pPr) {
          // Paragraph style
          if (pPr['w:pStyle'] && pPr['w:pStyle'].$) {
            paraFormatting.style = pPr['w:pStyle'].$['w:val'];
          }
          
          // Spacing
          const spacing = pPr['w:spacing'];
          if (spacing && spacing.$) {
            const attrs = spacing.$;
            paraFormatting.spacing = {
              line: attrs['w:line'] ? this.lineSpacingToDecimal(attrs['w:line'], attrs['w:lineRule']) : null,
              before: attrs['w:before'] ? this.twipsToPoints(parseInt(attrs['w:before'])) : null,
              after: attrs['w:after'] ? this.twipsToPoints(parseInt(attrs['w:after'])) : null
            };
          }
          
          // Indentation - FIXED bracket notation
          const ind = pPr['w:ind'];
          if (ind && ind.$) {
            const attrs = ind.$;
            paraFormatting.indentation = {
              firstLine: attrs['w:firstLine'] ? this.twipsToInches(parseInt(attrs['w:firstLine'])) : null,
              hanging: attrs['w:hanging'] ? this.twipsToInches(parseInt(attrs['w:hanging'])) : null,
              left: attrs['w:left'] ? this.twipsToInches(parseInt(attrs['w:left'])) : null,
              right: attrs['w:right'] ? this.twipsToInches(parseInt(attrs['w:right'])) : null
            };
          }
          
          // Alignment
          const jc = pPr['w:jc'];
          if (jc && jc.$) {
            paraFormatting.alignment = jc.$['w:val'];
          }
        }
        
        // Extract run-level formatting (individual text pieces)
        const runs = Array.isArray(para['w:r']) ? para['w:r'] : [para['w:r']].filter(Boolean);
        let paragraphText = '';
        
        runs.forEach((run, runIndex) => {
          if (!run) return;
          
          const runFormatting = {
            index: runIndex,
            text: '',
            font: { family: null, size: null, bold: false, italic: false, underline: false },
            color: null
          };
          
          // Extract run properties
          const rPr = run['w:rPr'];
          if (rPr) {
            // Font family - FIXED bracket notation
            const rFonts = rPr['w:rFonts'];
            if (rFonts && rFonts.$) {
              runFormatting.font.family = rFonts.$['w:ascii'] || rFonts.$['w:hAnsi'] || null;
            }
            
            // Font size - FIXED bracket notation
            const sz = rPr['w:sz'];
            if (sz && sz.$) {
              runFormatting.font.size = parseInt(sz.$['w:val']) / 2; // Convert half-points to points
            }
            
            // Bold
            runFormatting.font.bold = !!rPr['w:b'];
            
            // Italic
            runFormatting.font.italic = !!rPr['w:i'];
            
            // Underline
            runFormatting.font.underline = !!rPr['w:u'];
            
            // Color - FIXED bracket notation
            const color = rPr['w:color'];
            if (color && color.$) {
              runFormatting.color = color.$['w:val'];
            }
          }
          
          // Extract text content
          const textElements = Array.isArray(run['w:t']) ? run['w:t'] : [run['w:t']].filter(Boolean);
          textElements.forEach(t => {
            if (t) {
              const text = typeof t === 'string' ? t : (t._ || '');
              runFormatting.text += text;
              paragraphText += text;
            }
          });
          
          // Handle line breaks
          if (run['w:br']) {
            runFormatting.text += '\n';
            paragraphText += '\n';
          }
          
          paraFormatting.runs.push(runFormatting);
        });
        
        paraFormatting.text = paragraphText;
        
        // Set paragraph-level font info from first run if not set in paragraph properties
        if (paraFormatting.runs.length > 0) {
          const firstRun = paraFormatting.runs[0];
          if (firstRun.font.family && !paraFormatting.font.family) {
            paraFormatting.font.family = firstRun.font.family;
          }
          if (firstRun.font.size && !paraFormatting.font.size) {
            paraFormatting.font.size = firstRun.font.size;
          }
        }
        
        formatting.paragraphs.push(paraFormatting);
      });
      
      // Set document-level defaults from most common paragraph settings
      if (formatting.paragraphs.length > 0) {
        const firstPara = formatting.paragraphs.find(p => p.font.family && p.font.size) || formatting.paragraphs[0];
        formatting.document.font = { ...firstPara.font };
        formatting.document.spacing.line = firstPara.spacing.line;
        formatting.document.indentation = { ...firstPara.indentation };
      }
      
      // Calculate APA compliance
      formatting.compliance = this.calculateAPACompliance(formatting);
      
    } catch (error) {
      console.error('Error parsing formatting XML:', error);
    }
    
    return formatting;
  }
  
  /**
   * Extract document structure (headings, sections, etc.)
   */
  async extractDocumentStructure(buffer) {
    try {
      const zip = await JSZip.loadAsync(buffer);
      const documentXml = await zip.file('word/document.xml').async('text');
      const documentData = await this.parser.parseStringPromise(documentXml);
      
      const structure = {
        headings: [],
        sections: [],
        citations: [],
        references: [],
        tables: [],
        figures: []
      };
      
      const body = documentData['w:document']['w:body'];
      const paragraphs = Array.isArray(body['w:p']) ? body['w:p'] : [body['w:p']].filter(Boolean);
      
      paragraphs.forEach((para, index) => {
        if (!para) return;
        
        // Extract text content
        let text = '';
        const runs = Array.isArray(para['w:r']) ? para['w:r'] : [para['w:r']].filter(Boolean);
        runs.forEach(run => {
          if (run && run['w:t']) {
            const textElements = Array.isArray(run['w:t']) ? run['w:t'] : [run['w:t']];
            textElements.forEach(t => {
              text += typeof t === 'string' ? t : (t._ || '');
            });
          }
        });
        
        text = text.trim();
        if (!text) return;
        
        // Detect headings by style
        let isHeading = false;
        let headingLevel = 0;
        
        const pPr = para['w:pPr'];
        if (pPr && pPr['w:pStyle'] && pPr['w:pStyle'].$) {
          const styleName = pPr['w:pStyle'].$['w:val'];
          
          // Check for heading styles
          const headingMatch = styleName.match(/(?:Heading|Title)(\d+)?/i);
          if (headingMatch) {
            isHeading = true;
            headingLevel = parseInt(headingMatch[1]) || 1;
          } else if (styleName.toLowerCase() === 'title') {
            isHeading = true;
            headingLevel = 1;
          }
        }
        
        // Detect headings by formatting (bold, larger font, etc.)
        if (!isHeading && runs.length > 0) {
          const firstRun = runs[0];
          if (firstRun && firstRun['w:rPr']) {
            const rPr = firstRun['w:rPr'];
            const isBold = !!rPr['w:b'];
            const fontSize = rPr['w:sz'] ? parseInt(rPr['w:sz'].$['w:val']) / 2 : 12;
            
            // Consider it a heading if it's bold and larger than normal text
            if (isBold && fontSize > 12 && text.length < 100) {
              isHeading = true;
              headingLevel = fontSize > 16 ? 1 : fontSize > 14 ? 2 : 3;
            }
          }
        }
        
        if (isHeading) {
          structure.headings.push({
            text,
            level: headingLevel,
            paragraphIndex: index
          });
        }
        
        // Detect citations
        const citationPattern = /\(([^)]+),\s*(\d{4})[^)]*\)/g;
        let citationMatch;
        while ((citationMatch = citationPattern.exec(text)) !== null) {
          structure.citations.push({
            text: citationMatch[0],
            author: citationMatch[1],
            year: citationMatch[2],
            paragraphIndex: index,
            position: citationMatch.index
          });
        }
        
        // Detect special sections
        const textLower = text.toLowerCase();
        if (textLower === 'references' || textLower === 'bibliography') {
          structure.sections.push({
            type: 'references',
            startIndex: index,
            title: text
          });
        } else if (textLower === 'abstract') {
          structure.sections.push({
            type: 'abstract',
            startIndex: index,
            title: text
          });
        } else if (textLower.includes('method') && text.length < 50) {
          structure.sections.push({
            type: 'method',
            startIndex: index,
            title: text
          });
        } else if (textLower.includes('result') && text.length < 50) {
          structure.sections.push({
            type: 'results',
            startIndex: index,
            title: text
          });
        } else if (textLower.includes('discussion') && text.length < 50) {
          structure.sections.push({
            type: 'discussion',
            startIndex: index,
            title: text
          });
        }
        
        // Detect reference entries (in References section)
        const referencesSection = structure.sections.find(s => s.type === 'references');
        if (referencesSection && index > referencesSection.startIndex) {
          // Check if this looks like a reference entry
          if (text.match(/^[A-Z][a-zA-Z-']+,\s+[A-Z].*\(\d{4}\)/)) {
            structure.references.push({
              text,
              paragraphIndex: index,
              type: this.detectReferenceType(text)
            });
          }
        }
      });
      
      return structure;
      
    } catch (error) {
      console.error('Error extracting document structure:', error);
      return {
        headings: [],
        sections: [],
        citations: [],
        references: [],
        tables: [],
        figures: []
      };
    }
  }
  
  /**
   * Extract styles information
   */
  async extractStyles(buffer) {
    try {
      const zip = await JSZip.loadAsync(buffer);
      const stylesFile = zip.file('word/styles.xml');
      
      if (!stylesFile) {
        return { styles: [], defaultStyle: null };
      }
      
      const stylesXml = await stylesFile.async('text');
      const stylesData = await this.parser.parseStringPromise(stylesXml);
      
      const styles = [];
      const stylesRoot = stylesData['w:styles'];
      
      if (stylesRoot && stylesRoot['w:style']) {
        const styleElements = Array.isArray(stylesRoot['w:style']) ? 
          stylesRoot['w:style'] : [stylesRoot['w:style']];
        
        styleElements.forEach(style => {
          if (style && style.$) {
            const styleInfo = {
              id: style.$.styleId,
              name: style['w:name'] ? style['w:name'].$['w:val'] : style.$.styleId,
              type: style.$.type,
              isDefault: style.$.default === '1',
              formatting: {}
            };
            
            // Extract style formatting
            const pPr = style['w:pPr'];
            const rPr = style['w:rPr'];
            
            if (pPr) {
              // Paragraph formatting
              if (pPr['w:spacing'] && pPr['w:spacing'].$) {
                styleInfo.formatting.spacing = pPr['w:spacing'].$;
              }
              if (pPr['w:ind'] && pPr['w:ind'].$) {
                styleInfo.formatting.indentation = pPr['w:ind'].$;
              }
            }
            
            if (rPr) {
              // Character formatting - FIXED bracket notation
              if (rPr['w:rFonts'] && rPr['w:rFonts'].$) {
                styleInfo.formatting.font = rPr['w:rFonts'].$;
              }
              if (rPr['w:sz'] && rPr['w:sz'].$) {
                styleInfo.formatting.fontSize = parseInt(rPr['w:sz'].$['w:val']) / 2;
              }
            }
            
            styles.push(styleInfo);
          }
        });
      }
      
      const defaultStyle = styles.find(s => s.isDefault && s.type === 'paragraph') || 
                          styles.find(s => s.name === 'Normal') ||
                          null;
      
      return { styles, defaultStyle };
      
    } catch (error) {
      console.error('Error extracting styles:', error);
      return { styles: [], defaultStyle: null };
    }
  }
  
  /**
   * Helper functions for unit conversion and analysis
   */
  twipsToInches(twips) {
    return twips / 1440; // 1440 twips = 1 inch
  }
  
  twipsToPoints(twips) {
    return twips / 20; // 20 twips = 1 point
  }
  
  lineSpacingToDecimal(value, rule) {
    if (rule === 'auto') {
      // Auto spacing - value is in 240ths of a line
      return value / 240;
    } else if (rule === 'atLeast' || rule === 'exact') {
      // Exact spacing - value is in twips
      return this.twipsToPoints(value) / 12; // Assuming 12pt base font
    }
    return null;
  }
  
  calculateAPACompliance(formatting) {
    const compliance = {
      font: {
        family: false,
        size: false,
        score: 0
      },
      spacing: {
        line: false,
        score: 0
      },
      margins: {
        all: false,
        individual: {},
        score: 0
      },
      indentation: {
        firstLine: false,
        score: 0
      },
      overall: 0
    };
    
    // Check font compliance
    if (formatting.document.font.family) {
      const fontFamily = formatting.document.font.family.toLowerCase();
      compliance.font.family = fontFamily.includes('times new roman') || 
                              fontFamily.includes('times') ||
                              fontFamily.includes('liberation serif');
    }
    
    if (formatting.document.font.size) {
      compliance.font.size = Math.abs(formatting.document.font.size - 12) < 0.5;
    }
    
    compliance.font.score = (compliance.font.family ? 50 : 0) + (compliance.font.size ? 50 : 0);
    
    // Check spacing compliance
    if (formatting.document.spacing.line) {
      compliance.spacing.line = Math.abs(formatting.document.spacing.line - 2.0) < 0.1;
      compliance.spacing.score = compliance.spacing.line ? 100 : 0;
    }
    
    // Check margins compliance
    if (formatting.document.margins) {
      let marginsCorrect = 0;
      Object.entries(formatting.document.margins).forEach(([side, value]) => {
        const isCorrect = value !== null && Math.abs(value - 1.0) < 0.1;
        compliance.margins.individual[side] = isCorrect;
        if (isCorrect) marginsCorrect++;
      });
      compliance.margins.all = marginsCorrect === 4;
      compliance.margins.score = (marginsCorrect / 4) * 100;
    }
    
    // Check indentation compliance
    const correctIndentation = formatting.paragraphs.filter(p => 
      p.indentation.firstLine !== null && Math.abs(p.indentation.firstLine - 0.5) < 0.05
    ).length;
    
    const totalParagraphs = formatting.paragraphs.filter(p => p.text.trim().length > 0).length;
    
    if (totalParagraphs > 0) {
      compliance.indentation.firstLine = correctIndentation / totalParagraphs > 0.8;
      compliance.indentation.score = (correctIndentation / totalParagraphs) * 100;
    }
    
    // Calculate overall compliance
    const scores = [
      compliance.font.score,
      compliance.spacing.score,
      compliance.margins.score,
      compliance.indentation.score
    ].filter(score => score !== null);
    
    compliance.overall = scores.length > 0 ? scores.reduce((a, b) => a + b) / scores.length : 0;
    
    return compliance;
  }
  
  detectReferenceType(text) {
    if (text.match(/\b(?:journal|quarterly|review|proceedings|bulletin)\b/i)) {
      return 'journal';
    }
    if (text.match(/\b(?:publisher|press|books|publication)\b/i)) {
      return 'book';
    }
    if (text.match(/\b(?:http|www\.|\.com|\.org|\.edu|retrieved)\b/i)) {
      return 'website';
    }
    if (text.match(/\b(?:in\s+[A-Z]|\(eds?\.\)|\(ed\.\))\b/i)) {
      return 'chapter';
    }
    return 'unknown';
  }
  
  getDefaultFormatting() {
    return {
      document: {
        font: { family: null, size: null },
        spacing: { line: null, paragraph: null },
        margins: { top: null, bottom: null, left: null, right: null },
        indentation: { firstLine: null, hanging: null },
        pageSetup: {}
      },
      paragraphs: [],
      runs: [],
      compliance: {
        font: { family: false, size: false, score: 0 },
        spacing: { line: false, score: 0 },
        margins: { all: false, individual: {}, score: 0 },
        indentation: { firstLine: false, score: 0 },
        overall: 0
      }
    };
  }
}

module.exports = DocxProcessor;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\server\routes\docx.js
// server/routes/docx.js - Ensure proper router export
const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs').promises;
const DocxProcessor = require('../processors/DocxProcessor');

// Create router instance - IMPORTANT: This must be the default export
const router = express.Router();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, path.join(__dirname, '../uploads/'));
  },
  filename: (req, file, cb) => {
    // Generate unique filename with timestamp
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const extension = path.extname(file.originalname);
    cb(null, `document-${uniqueSuffix}${extension}`);
  }
});

// File filter to only allow DOCX files
const fileFilter = (req, file, cb) => {
  const allowedMimes = [
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/octet-stream' // Some systems send DOCX as octet-stream
  ];
  
  const allowedExtensions = ['.docx'];
  const fileExtension = path.extname(file.originalname).toLowerCase();
  
  if (allowedMimes.includes(file.mimetype) || allowedExtensions.includes(fileExtension)) {
    cb(null, true);
  } else {
    cb(new Error('Only DOCX files are allowed'), false);
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 1 // Only one file at a time
  }
});

// Initialize DOCX processor
const docxProcessor = new DocxProcessor();

/**
 * POST /api/upload-docx
 * Upload and process a DOCX file
 */
router.post('/upload-docx', upload.single('document'), async (req, res) => {
  let filePath = null;
  
  try {
    // Validate file upload
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'No file uploaded',
        code: 'NO_FILE'
      });
    }
    
    filePath = req.file.path;
    console.log(`Processing uploaded file: ${req.file.originalname} (${req.file.size} bytes)`);
    
    // Validate file exists and is readable
    try {
      await fs.access(filePath, fs.constants.R_OK);
    } catch (error) {
      throw new Error('Uploaded file is not readable');
    }
    
    // Additional DOCX validation - check file header
    const fileBuffer = await fs.readFile(filePath);
    if (!isValidDocxFile(fileBuffer)) {
      throw new Error('File is not a valid DOCX document');
    }
    
    // Process the document
    console.log('Starting document processing...');
    const startTime = Date.now();
    
    const result = await docxProcessor.processDocument(filePath);
    
    const processingTime = Date.now() - startTime;
    console.log(`Document processing completed in ${processingTime}ms`);
    
    // Add processing metadata
    result.processingInfo = {
      ...result.processingInfo,
      processingTime: processingTime,
      originalFilename: req.file.originalname,
      fileSize: req.file.size
    };
    
    // Validate processing results
    if (!result.text || !result.html) {
      throw new Error('Document processing produced incomplete results');
    }
    
    // Clean up uploaded file
    await fs.unlink(filePath);
    filePath = null; // Mark as cleaned up
    
    // Return success response
    res.json({
      success: true,
      document: result,
      message: 'Document processed successfully'
    });
    
  } catch (error) {
    console.error('Error processing document:', error);
    
    // Clean up uploaded file if it exists
    if (filePath) {
      try {
        await fs.unlink(filePath);
      } catch (cleanupError) {
        console.error('Error cleaning up file:', cleanupError);
      }
    }
    
    // Determine error type and appropriate response
    let statusCode = 500;
    let errorCode = 'PROCESSING_ERROR';
    let errorMessage = 'Failed to process document';
    
    if (error.message.includes('not a valid DOCX')) {
      statusCode = 400;
      errorCode = 'INVALID_FILE';
      errorMessage = 'File is not a valid DOCX document';
    } else if (error.message.includes('DOCX processing failed')) {
      statusCode = 422;
      errorCode = 'PROCESSING_FAILED';
      errorMessage = 'Document could not be processed';
    } else if (error.message.includes('not readable')) {
      statusCode = 400;
      errorCode = 'FILE_UNREADABLE';
      errorMessage = 'Uploaded file could not be read';
    }
    
    res.status(statusCode).json({
      success: false,
      error: errorMessage,
      code: errorCode,
      details: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

/**
 * GET /api/processing-status
 * Health check for document processing capabilities
 */
router.get('/processing-status', (req, res) => {
  res.json({
    success: true,
    status: 'operational',
    capabilities: {
      docxProcessing: true,
      formattingExtraction: true,
      structureAnalysis: true,
      apaCompliance: true
    },
    limits: {
      maxFileSize: '10MB',
      allowedFormats: ['DOCX'],
      processingTimeout: '30s'
    },
    timestamp: new Date().toISOString()
  });
});

/**
 * Helper function to validate DOCX file
 */
function isValidDocxFile(buffer) {
  try {
    // DOCX files are ZIP archives, so they start with PK (ZIP signature)
    if (buffer.length < 4) return false;
    
    // Check ZIP signature
    const zipSignature = buffer.slice(0, 4);
    const isZip = zipSignature[0] === 0x50 && zipSignature[1] === 0x4B;
    
    if (!isZip) return false;
    
    return true;
  } catch (error) {
    return false;
  }
}

/**
 * Error handling middleware specific to this router
 */
router.use((error, req, res, next) => {
  console.error('DOCX Router Error:', error);
  
  // Handle multer-specific errors
  if (error instanceof multer.MulterError) {
    if (error.code === 'LIMIT_FILE_SIZE') {
      return res.status(413).json({
        success: false,
        error: 'File too large (max 10MB)',
        code: 'FILE_TOO_LARGE'
      });
    }
    
    if (error.code === 'LIMIT_UNEXPECTED_FILE') {
      return res.status(400).json({
        success: false,
        error: 'Unexpected file field',
        code: 'UNEXPECTED_FILE'
      });
    }
    
    return res.status(400).json({
      success: false,
      error: error.message,
      code: 'UPLOAD_ERROR'
    });
  }
  
  // Handle file filter errors
  if (error.message === 'Only DOCX files are allowed') {
    return res.status(400).json({
      success: false,
      error: 'Only DOCX files are allowed',
      code: 'INVALID_FILE_TYPE'
    });
  }
  
  // Pass other errors to main error handler
  next(error);
});

// IMPORTANT: Export the router properly
module.exports = router;

