// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\AppLayout.js
'use client';

import { usePathname } from 'next/navigation';
import LandingHeader from '@/components/LandingHeader';
import Footer from '@/components/Footer';

export default function AppLayout({ children }) {
  const pathname = usePathname();

  // Only show marketing Header/Footer on landing page
  // Exclude: dashboard, document viewer, login, signup, editor
  const showHeaderFooter = pathname === '/';

  return (
    <div className="flex flex-col min-h-screen">
      {showHeaderFooter && <LandingHeader />}
      <main className="flex-grow">
        {children}
      </main>
      {showHeaderFooter && <Footer />}
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\auth\callback\route.js
// src/app/auth/callback/route.js - Auth callback handler for email confirmation
import { NextResponse } from 'next/server';
import { createClient } from '@/lib/supabase/server';

/**
 * Handles authentication callback after email confirmation or OAuth
 * Exchanges code for session and redirects to dashboard
 */
export async function GET(request) {
  const requestUrl = new URL(request.url);
  const code = requestUrl.searchParams.get('code');
  const origin = requestUrl.origin;

  if (code) {
    const supabase = await createClient();

    // Exchange code for session
    const { error } = await supabase.auth.exchangeCodeForSession(code);

    if (error) {
      console.error('Auth callback error:', error);
      return NextResponse.redirect(`${origin}/login?error=auth_failed`);
    }
  }

  // Redirect to dashboard after successful authentication
  return NextResponse.redirect(`${origin}/dashboard`);
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\dashboard\DashboardClient.js
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { useToast } from '@/hooks/use-toast';
import Sidebar from '@/components/dashboard/Sidebar';
import MobileSidebar from '@/components/dashboard/MobileSidebar';
import Dashboard from '@/components/dashboard/Dashboard.jsx';

export default function DashboardClient({ user, profile, initialDocuments }) {
  const router = useRouter();
  const supabase = createClient();
  const { toast } = useToast();
  const [documents, setDocuments] = useState(initialDocuments);
  const [uploading, setUploading] = useState(false);
  const [uploadingFileName, setUploadingFileName] = useState('');
  const [error, setError] = useState('');

  const handleFileUpload = async (file) => {
    if (!file) return;

    setUploadingFileName(file.name);

    // Validate file type
    if (!file.name.endsWith('.docx')) {
      toast({
        variant: "destructive",
        title: "Invalid file type",
        description: "Please upload a .docx file",
      });
      return;
    }

    // Validate file size (50MB limit)
    if (file.size > 50 * 1024 * 1024) {
      toast({
        variant: "destructive",
        title: "File too large",
        description: "File size must be less than 50MB",
      });
      return;
    }

    setUploading(true);
    setError('');

    toast({
      title: "Uploading document",
      description: `Uploading ${file.name}...`,
    });

    try {
      // Upload to Supabase Storage
      const filePath = `${user.id}/${Date.now()}_${file.name}`;
      const { data: uploadData, error: uploadError } = await supabase.storage
        .from('user-documents')
        .upload(filePath, file);

      if (uploadError) throw uploadError;

      // Create document record in database
      const { data: documentData, error: documentError } = await supabase
        .from('documents')
        .insert({
          user_id: user.id,
          filename: file.name,
          file_path: filePath,
          file_size: file.size,
          status: 'uploaded',
        })
        .select()
        .single();

      if (documentError) throw documentError;

      // Add to local state
      setDocuments([documentData, ...documents]);

      // Get current session to extract JWT token
      const { data: { session } } = await supabase.auth.getSession();

      if (!session) {
        throw new Error('No active session');
      }

      // Trigger processing on backend
      const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001';
      const response = await fetch(`${apiUrl}/api/process-document`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`,
        },
        body: JSON.stringify({
          documentId: documentData.id,
        }),
      });

      if (!response.ok) {
        console.error('Processing failed:', await response.text());
        throw new Error('Failed to process document');
      }

      // Redirect to document viewer to see processing results
      toast({
        title: "Document uploaded successfully",
        description: "Analyzing document for APA compliance...",
      });
      router.push(`/document/${documentData.id}`);
    } catch (err) {
      console.error('Upload error:', err);
      toast({
        variant: "destructive",
        title: "Upload failed",
        description: err.message || 'Failed to upload document. Please try again.',
      });
      setError(err.message || 'Failed to upload document');
    } finally {
      setUploading(false);
      setUploadingFileName('');
    }
  };

  const handleDelete = async (documentId, filePath) => {
    if (!confirm('Are you sure you want to delete this document?')) return;

    try {
      // Delete from storage
      const { error: storageError } = await supabase.storage
        .from('user-documents')
        .remove([filePath]);

      if (storageError) throw storageError;

      // Delete from database (cascade will delete analysis_results)
      const { error: dbError } = await supabase
        .from('documents')
        .delete()
        .eq('id', documentId);

      if (dbError) throw dbError;

      // Update local state
      setDocuments(documents.filter((doc) => doc.id !== documentId));

      toast({
        title: "Document deleted",
        description: "Document has been permanently removed.",
      });
    } catch (err) {
      console.error('Delete error:', err);
      toast({
        variant: "destructive",
        title: "Delete failed",
        description: err.message || 'Failed to delete document. Please try again.',
      });
      setError(err.message || 'Failed to delete document');
    }
  };

  return (
    <div className="min-h-screen bg-slate-100 flex">
      <Sidebar user={user} profile={profile} />
      <MobileSidebar user={user} profile={profile} />
      <div className="flex-1 flex flex-col">
        <Dashboard
          user={user}
          profile={profile}
          documents={documents}
          onFileUpload={handleFileUpload}
          uploading={uploading}
          uploadingFileName={uploadingFileName}
          error={error}
          onDelete={handleDelete}
        />
      </div>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\dashboard\loading.js
import DashboardLoadingSkeleton from '@/components/loading/DashboardLoadingSkeleton';
import Sidebar from '@/components/dashboard/Sidebar';

export default function DashboardLoading() {
  return (
    <div className="min-h-screen bg-slate-100 flex">
      <div className="w-64 h-screen bg-white border-r border-slate-200 flex flex-col shadow-sm hidden md:flex">
        {/* Sidebar placeholder - empty skeleton */}
        <div className="p-6 border-b border-slate-200">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl"></div>
            <span className="text-2xl font-bold text-slate-800">APA Pro</span>
          </div>
        </div>
      </div>
      <div className="flex-1 p-6 sm:p-8">
        <DashboardLoadingSkeleton message="Loading your dashboard..." />
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\dashboard\page.js
import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getUserWithProfile } from '@/lib/profiles';
import DashboardClient from './DashboardClient';

// Disable caching to ensure fresh data after document updates
export const dynamic = 'force-dynamic';
export const revalidate = 0;

/**
 * Dashboard page (Server Component)
 * Fetches user data and documents, then renders client component
 */
export default async function DashboardPage() {
  const supabase = await createClient();

  // Get current user with profile data
  const { user, profile, error: userError } = await getUserWithProfile(supabase);

  // Redirect to login if not authenticated (fallback - middleware should handle this)
  if (userError || !user) {
    redirect('/login');
  }

  // Fetch user's documents with analysis results (using LEFT JOIN)
  const { data: documents, error: documentsError} = await supabase
    .from('documents')
    .select(`
      *,
      analysis_results (
        compliance_score,
        issue_count
      )
    `)
    .eq('user_id', user.id)
    .order('created_at', { ascending: false });

  if (documentsError) {
    console.error('Error fetching documents:', documentsError);
  }

  // Flatten analysis_results into document objects for easier access
  const documentsWithScores = (documents || []).map(doc => ({
    ...doc,
    compliance_score: doc.analysis_results?.[0]?.compliance_score || null,
    issue_count: doc.analysis_results?.[0]?.issue_count || null,
  }));

  return (
    <DashboardClient
      user={user}
      profile={profile}
      initialDocuments={documentsWithScores}
    />
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\document\[id]\DocumentViewerClient.js
'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { useUnifiedDocumentStore } from '@/store/unifiedDocumentStore';
import { indexedDBManager } from '@/utils/indexedDBManager';
import IssuesPanel from '@/components/IssuesPanel';
import NewDocumentEditor from '@/components/NewDocumentEditor';
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { LogOut } from "lucide-react";

/**
 * Client component for viewing and editing documents from Supabase
 */
export default function DocumentViewerClient({ user, profile, document: docData, analysisResult }) {
  const router = useRouter();
  const supabase = createClient();
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [splitRatio, setSplitRatio] = useState(60);
  const [isDragging, setIsDragging] = useState(false);

  const loadExistingDocument = useUnifiedDocumentStore(state => state.loadExistingDocument);
  const analyzeDocument = useUnifiedDocumentStore(state => state.analyzeDocument);

  useEffect(() => {
    // Load document into store when component mounts
    const loadDocument = async () => {
      try {
        setLoading(true);
        setError(null);

        // THREE-LAYER ARCHITECTURE: Check IndexedDB first for reload safety
        const localDraft = await indexedDBManager.loadFromIndexedDB(docData.id);

        let documentData;
        let useLocalDraft = false;

        if (localDraft && localDraft.tiptapContent) {
          // Calculate age of local draft
          const draftAge = Date.now() - localDraft.lastSaved;
          const draftAgeMinutes = Math.round(draftAge / 1000 / 60);

          console.log(`📂 Found local draft in IndexedDB (${draftAgeMinutes} minutes old)`);

          // Check if Supabase version is newer
          const supabaseTimestamp = analysisResult.content_saved_at
            ? new Date(analysisResult.content_saved_at).getTime()
            : 0;

          if (localDraft.lastSaved > supabaseTimestamp) {
            console.log('✅ Local draft is newer than Supabase - using local draft');
            useLocalDraft = true;

            // Use local draft with server document_data as base
            documentData = {
              ...analysisResult.document_data,
              tiptapContent: localDraft.tiptapContent
            };
          } else {
            console.log('⚠️ Supabase version is newer - discarding local draft');
            // Clear stale local draft
            await indexedDBManager.clearFromIndexedDB(docData.id);
          }
        }

        if (!useLocalDraft) {
          // No local draft or Supabase is newer - load from Supabase
          if (analysisResult.tiptap_content) {
            // Load from saved Tiptap JSON (includes manual edits)
            console.log('☁️ Loading from Supabase tiptap_content (edited version)');
            documentData = {
              ...analysisResult.document_data,
              tiptapContent: analysisResult.tiptap_content
            };
          } else {
            // Fallback to original document_data (first load)
            console.log('☁️ Loading from Supabase document_data (original version)');
            documentData = analysisResult.document_data;
          }
        }

        if (!documentData && !analysisResult.tiptap_content) {
          throw new Error('Document data is missing from analysis results');
        }

        // Add originalName to processingInfo for DocumentModel
        if (documentData.processingInfo && !documentData.processingInfo.originalName) {
          documentData.processingInfo.originalName = docData.filename;
        }

        // Load issues from analysis results
        const issues = analysisResult.issues || [];

        // Add Supabase metadata for fix application
        const supabaseMetadata = {
          documentId: docData.id,
          filePath: docData.file_path,
          userId: user.id
        };

        // Load document using store method
        await loadExistingDocument(documentData, issues, supabaseMetadata);

        if (useLocalDraft) {
          console.log('📝 Document loaded from IndexedDB (local unsaved changes restored)');
        } else {
          console.log('✅ Document loaded from Supabase');
        }

        // If no issues were found (backend skipped analysis), run full analysis now
        if (issues.length === 0) {
          console.log('🧠 Running full APA analysis on frontend...');
          await analyzeDocument({ force: true });
        }

        setLoading(false);
      } catch (err) {
        console.error('Error loading document:', err);
        setError(err.message || 'Failed to load document');
        setLoading(false);
      }
    };

    loadDocument();
  }, [docData.id, analysisResult, docData.filename, loadExistingDocument, analyzeDocument, user.id]);

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    router.push('/');
    router.refresh();
  };

  const handleBackToDashboard = () => {
    router.push('/dashboard');
  };

  const getInitials = (email) => {
    if (!email) return "U";
    const parts = email.split('@')[0].split('.');
    if (parts.length > 1) {
      return (parts[0][0] + parts[1][0]).toUpperCase();
    }
    return email.substring(0, 2).toUpperCase();
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="bg-white shadow rounded-lg p-8 max-w-md">
          <div className="animate-pulse">
            <div className="h-4 bg-gray-200 rounded w-3/4 mb-4"></div>
            <div className="h-4 bg-gray-200 rounded w-1/2"></div>
          </div>
          <p className="mt-4 text-sm text-gray-600">Loading document...</p>
        </div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gray-50 flex items-center justify-center">
        <div className="bg-white shadow rounded-lg p-8 max-w-md">
          <h1 className="text-2xl font-bold text-gray-900 mb-4">Error Loading Document</h1>
          <p className="text-red-600 mb-4">{error}</p>
          <button
            onClick={handleBackToDashboard}
            className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700"
          >
            Return to Dashboard
          </button>
        </div>
      </div>
    );
  }

  return (
    <main className="flex flex-col h-screen bg-white">
      {/* Header */}
      <header className="bg-white shadow border-b border-slate-200">
        <div className="max-w-full mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
          <div>
            <h1 className="text-xl font-bold text-slate-900">{docData.filename}</h1>
            <div className="flex items-center gap-4 mt-1">
              <span className="px-2.5 py-1 text-xs font-semibold rounded-full bg-emerald-100 text-emerald-700">
                Compliance: {analysisResult.compliance_score}%
              </span>
              <span className="text-sm text-slate-600">
                Issues: {analysisResult.issue_count}
              </span>
            </div>
          </div>
          <div className="flex items-center gap-2">
            <Button
              onClick={handleBackToDashboard}
              variant="outline"
              className="font-medium text-slate-700 hover:text-slate-900 hover:bg-slate-50 rounded-xl"
            >
              Dashboard
            </Button>
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button
                  variant="ghost"
                  className="gap-2.5 hover:bg-slate-100 rounded-xl px-3 py-2"
                >
                  <div className="text-right hidden sm:block">
                    <p className="text-sm font-semibold text-slate-800">{user.email?.split('@')[0]}</p>
                    <p className="text-xs text-slate-500">{user.email}</p>
                  </div>
                  <Avatar className="w-9 h-9 ring-2 ring-slate-200 ring-offset-2">
                    <AvatarFallback className="bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white text-xs font-bold">
                      {getInitials(user.email)}
                    </AvatarFallback>
                  </Avatar>
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className="w-64 p-2 bg-white shadow-xl border border-slate-200">
                <DropdownMenuLabel className="p-3">
                  <div className="flex items-center gap-3">
                    <Avatar className="w-10 h-10 ring-2 ring-slate-200">
                      <AvatarFallback className="bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white font-bold">
                        {getInitials(user.email)}
                      </AvatarFallback>
                    </Avatar>
                    <div className="flex flex-col">
                      <p className="text-sm font-semibold text-slate-900">{user.email?.split('@')[0]}</p>
                      <p className="text-xs text-slate-500">{user.email}</p>
                    </div>
                  </div>
                </DropdownMenuLabel>
                <DropdownMenuSeparator />
                <DropdownMenuItem
                  onClick={handleSignOut}
                  className="cursor-pointer text-red-600 focus:text-red-600 focus:bg-red-50 rounded-lg py-2.5"
                >
                  <LogOut className="mr-2 h-4 w-4" />
                  <span className="font-medium">Sign Out</span>
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
      </header>

      {/* Main Content - Split View */}
      <div className="flex-1 flex overflow-hidden relative">
        {/* Document Viewer (left panel) */}
        <div
          className="relative bg-white shadow-sm border-r border-slate-200 transition-all duration-300"
          style={{ width: `${splitRatio}%` }}
        >
          <NewDocumentEditor />
        </div>

        {/* Resize Handle */}
        <div
          className={`w-1.5 cursor-col-resize relative group transition-all duration-200 ${
            isDragging ? 'bg-emerald-500 shadow-lg shadow-emerald-500/50' : 'bg-slate-300 hover:bg-emerald-400 hover:shadow-lg hover:shadow-emerald-400/30'
          }`}
          onMouseDown={(e) => {
            setIsDragging(true);
            const startX = e.clientX;
            const startWidth = splitRatio;

            const handleMouseMove = (moveEvent) => {
              const containerWidth = document.body.clientWidth;
              const newWidth = startWidth + ((moveEvent.clientX - startX) / containerWidth * 100);

              // Constrain between 35% and 75%
              const constrainedWidth = Math.max(35, Math.min(75, newWidth));
              setSplitRatio(constrainedWidth);
            };

            const handleMouseUp = () => {
              setIsDragging(false);
              document.removeEventListener('mousemove', handleMouseMove);
              document.removeEventListener('mouseup', handleMouseUp);
              document.body.style.cursor = 'default';
              document.body.style.userSelect = 'auto';
            };

            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          }}
        >
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
            <div className={`flex flex-col space-y-1.5 px-1 py-3 rounded-full transition-all duration-200 ${
              isDragging ? 'bg-emerald-500 opacity-100' : 'bg-slate-400 opacity-0 group-hover:opacity-100'
            }`}>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
            </div>
          </div>
        </div>

        {/* Issues Panel (right panel) */}
        <div
          className="bg-white shadow-sm border-l border-slate-200 transition-all duration-300"
          style={{ width: `${100 - splitRatio}%` }}
        >
          <IssuesPanel />
        </div>
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\document\[id]\loading.js
import AnalysisLoadingSkeleton from '@/components/loading/AnalysisLoadingSkeleton';

export default function DocumentLoading() {
  return (
    <AnalysisLoadingSkeleton
      message="Loading document analysis..."
      fileName="Fetching document..."
    />
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\document\[id]\not-found.js
import Link from 'next/link';

/**
 * Custom 404 page for document viewer
 * Shows when a document is not found or has been deleted
 */
export default function DocumentNotFound() {
  return (
    <div className="min-h-screen bg-white flex items-center justify-center px-4">
      <div className="max-w-md w-full bg-white border border-gray-200 rounded-lg shadow-sm p-8">
        <div className="text-center">
          {/* Icon */}
          <div className="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-red-100">
            <svg
              className="h-8 w-8 text-red-600"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>

          {/* Title */}
          <h1 className="mt-6 text-3xl font-bold text-gray-900">
            Document Not Found
          </h1>

          {/* Description */}
          <p className="mt-4 text-sm text-gray-600">
            The document you&apos;re looking for doesn&apos;t exist or may have been deleted.
          </p>

          {/* Actions */}
          <div className="mt-8 space-y-3">
            <Link
              href="/dashboard"
              className="block w-full px-4 py-3 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-colors font-medium"
            >
              Return to Dashboard
            </Link>
            <Link
              href="/"
              className="block w-full px-4 py-3 bg-gray-100 text-gray-900 rounded-lg hover:bg-gray-200 transition-colors font-medium"
            >
              Go to Home
            </Link>
          </div>
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\document\[id]\page.js
// src/app/document/[id]/page.js - Server component to fetch and display document
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import { notFound, redirect } from 'next/navigation';
import { getUserProfile } from '@/lib/profiles';
import DocumentViewerClient from './DocumentViewerClient';

// Disable caching to ensure fresh data after fixes are applied
export const dynamic = 'force-dynamic';
export const revalidate = 0;

/**
 * Server component that fetches document from Supabase and passes to client
 */
export default async function DocumentPage({ params }) {
  // Await params as per Next.js 15 requirements
  const { id } = await params;

  // Create Supabase client with cookies
  const cookieStore = await cookies();
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        get(name) {
          return cookieStore.get(name)?.value;
        },
      },
    }
  );

  // Verify user is authenticated
  const { data: { user }, error: authError } = await supabase.auth.getUser();

  if (authError || !user) {
    redirect('/login');
  }

  // Fetch user profile
  const profile = await getUserProfile(supabase, user.id);

  // Fetch document metadata from documents table
  const { data: document, error: docError } = await supabase
    .from('documents')
    .select('*')
    .eq('id', id)
    .eq('user_id', user.id) // Ensure user owns this document
    .single();

  if (docError || !document) {
    console.error('Document not found:', docError);
    notFound();
  }

  // Check if document has been processed
  if (document.status !== 'completed') {
    return (
      <div className="min-h-screen bg-white flex items-center justify-center px-4">
        <div className="bg-white border border-gray-200 rounded-lg shadow-sm p-8 max-w-md w-full">
          <div className="text-center">
            {document.status === 'processing' && (
              <>
                <div className="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-emerald-600 mb-6">
                  <div className="w-8 h-8 border-4 border-white border-t-transparent rounded-full animate-spin"></div>
                </div>
                <h1 className="text-2xl font-bold text-gray-900 mb-4">Processing Document</h1>
                <p className="text-gray-600 mb-4">Your document is currently being analyzed. This may take a moment...</p>
                <div className="w-full bg-gray-200 rounded-full h-2 overflow-hidden">
                  <div className="h-full bg-emerald-600 rounded-full animate-pulse"></div>
                </div>
              </>
            )}
            {document.status === 'uploaded' && (
              <>
                <div className="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-gray-100 mb-6">
                  <svg className="w-8 h-8 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <h1 className="text-2xl font-bold text-gray-900 mb-4">Queued for Processing</h1>
                <p className="text-gray-600">Your document is queued and will be processed shortly.</p>
              </>
            )}
            {document.status === 'failed' && (
              <>
                <div className="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-red-100 mb-6">
                  <svg className="w-8 h-8 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                  </svg>
                </div>
                <h1 className="text-2xl font-bold text-gray-900 mb-4">Processing Failed</h1>
                <p className="text-red-600 mb-6">Document processing failed. Please try uploading again.</p>
                <a
                  href="/dashboard"
                  className="inline-block px-6 py-3 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-colors font-medium"
                >
                  Return to Dashboard
                </a>
              </>
            )}
          </div>
        </div>
      </div>
    );
  }

  // Fetch analysis results from analysis_results table
  const { data: analysisResult, error: analysisError } = await supabase
    .from('analysis_results')
    .select('*')
    .eq('document_id', id)
    .single();

  if (analysisError || !analysisResult) {
    console.error('Analysis results not found:', analysisError);
    return (
      <div className="min-h-screen bg-white flex items-center justify-center px-4">
        <div className="bg-white border border-gray-200 rounded-lg shadow-sm p-8 max-w-md w-full">
          <div className="text-center">
            <div className="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-yellow-100 mb-6">
              <svg className="w-8 h-8 text-yellow-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
              </svg>
            </div>
            <h1 className="text-2xl font-bold text-gray-900 mb-4">Analysis Not Available</h1>
            <p className="text-gray-600 mb-6">Analysis results for this document could not be found.</p>
            <a
              href="/dashboard"
              className="inline-block px-6 py-3 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-colors font-medium"
            >
              Return to Dashboard
            </a>
          </div>
        </div>
      </div>
    );
  }

  // Pass document metadata and analysis data to client component
  return (
    <DocumentViewerClient
      user={user}
      profile={profile}
      document={document}
      analysisResult={analysisResult}
    />
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\editor\page.js
'use client';
import { useState } from 'react';
import IssuesPanel from '@/components/IssuesPanel';
import EditorHeader from '@/components/EditorHeader';
import NewDocumentEditor from '@/components/NewDocumentEditor';

export default function EditorPage() {
  const [splitRatio, setSplitRatio] = useState(60);
  const [isDragging, setIsDragging] = useState(false);

  return (
    <main className="flex flex-col h-screen bg-white">
      <EditorHeader />

      <div className="flex-1 flex overflow-hidden relative">
        {/* Document Viewer (left panel) */}
        <div
          className="relative bg-white shadow-sm border-r border-slate-200 transition-all duration-300"
          style={{ width: `${splitRatio}%` }}
        >
          <NewDocumentEditor />
        </div>

        {/* Modern Resize Handle */}
        <div
          className={`w-1.5 cursor-col-resize relative group transition-all duration-200 ${
            isDragging ? 'bg-emerald-500 shadow-lg shadow-emerald-500/50' : 'bg-slate-300 hover:bg-emerald-400 hover:shadow-lg hover:shadow-emerald-400/30'
          }`}
          onMouseDown={(e) => {
            setIsDragging(true);
            const startX = e.clientX;
            const startWidth = splitRatio;
            
            const handleMouseMove = (moveEvent) => {
              const containerWidth = document.body.clientWidth;
              const newWidth = startWidth + ((moveEvent.clientX - startX) / containerWidth * 100);
              
              // Constrain between 35% and 75%
              const constrainedWidth = Math.max(35, Math.min(75, newWidth));
              setSplitRatio(constrainedWidth);
            };
            
            const handleMouseUp = () => {
              setIsDragging(false);
              document.removeEventListener('mousemove', handleMouseMove);
              document.removeEventListener('mouseup', handleMouseUp);
              document.body.style.cursor = 'default';
              document.body.style.userSelect = 'auto';
            };
            
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          }}
        >
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
            <div className={`flex flex-col space-y-1.5 px-1 py-3 rounded-full transition-all duration-200 ${
              isDragging ? 'bg-emerald-500 opacity-100' : 'bg-slate-400 opacity-0 group-hover:opacity-100'
            }`}>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
            </div>
          </div>
        </div>
        
        {/* Issues Panel (right panel) */}
        <div
          className="bg-white shadow-sm border-l border-slate-200 transition-all duration-300"
          style={{ width: `${100 - splitRatio}%` }}
        >
          <IssuesPanel />
        </div>
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* Typography - Modern Font Stack */
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-outfit), system-ui, sans-serif;
  font-weight: 700;
  letter-spacing: -0.02em;
}

body {
  font-family: var(--font-inter), system-ui, sans-serif;
}

/* APA styling for document viewer */
.prose {
  font-family: 'Times New Roman', Times, serif;
  max-width: none;
}

/* Issue highlighting styles */
mark[data-issue-id] {
  border-radius: 2px;
  cursor: pointer;
  padding: 0 1px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

mark[data-issue-id]::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform 0.3s ease;
}

mark[data-issue-id]:hover::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

.bg-red-200 {
  background-color: rgba(254, 202, 202, 0.7);
  border-bottom: 2px solid var(--error);
}

.bg-red-200:hover {
  background-color: rgba(254, 202, 202, 0.9);
}

.bg-red-200::after {
  background-color: var(--error);
}

.bg-orange-200 {
  background-color: rgba(254, 215, 170, 0.7);
  border-bottom: 2px solid var(--warning);
}

.bg-orange-200:hover {
  background-color: rgba(254, 215, 170, 0.9);
}

.bg-orange-200::after {
  background-color: var(--warning);
}

.bg-blue-200 {
  background-color: rgba(191, 219, 254, 0.7);
  border-bottom: 2px solid var(--primary);
}

.bg-blue-200:hover {
  background-color: rgba(191, 219, 254, 0.9);
}

.bg-blue-200::after {
  background-color: var(--primary);
}

/* Active issue highlighting */
.active-issue {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  animation: pulse 2s infinite;
}

/* Custom animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
  100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes progress {
  0% { width: 0%; }
  100% { width: 100%; }
}

/* Animation utilities (fallback for older Tailwind versions) */
.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 0.3s ease-out forwards;
}

.animate-pulse-blue {
  animation: pulse 2s infinite;
}

.animate-progress {
  animation: progress 2s ease-out infinite;
}

/* Apply animations to components */
.issue-category {
  animation: fadeIn 0.4s ease-out;
}

.issue-item {
  animation: slideIn 0.3s ease-out;
}

/* Staggered animations for issue items */
.issue-item:nth-child(1) { animation-delay: 0.05s; }
.issue-item:nth-child(2) { animation-delay: 0.1s; }
.issue-item:nth-child(3) { animation-delay: 0.15s; }
.issue-item:nth-child(4) { animation-delay: 0.2s; }
.issue-item:nth-child(5) { animation-delay: 0.25s; }

/* Custom utility classes */
.hover-shadow:hover {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-grow:hover {
  transform: scale(1.02);
}

/* Loading spinner */
.loading-spinner {
  border: 3px solid rgba(99, 102, 241, 0.1);
  border-radius: 50%;
  border-top: 3px solid var(--primary);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
}

/* Modern button styles */
.btn-primary {
  @apply bg-gradient-to-r from-indigo-500 to-indigo-600 text-white font-medium px-5 py-2.5 rounded-lg shadow-md hover:shadow-lg transform transition-all duration-200 hover:-translate-y-0.5 active:translate-y-0;
}

.btn-secondary {
  @apply bg-white text-gray-700 font-medium px-5 py-2.5 rounded-lg border border-gray-200 shadow-sm hover:shadow-md hover:bg-gray-50 transform transition-all duration-200 hover:-translate-y-0.5 active:translate-y-0;
}

.btn-success {
  @apply bg-gradient-to-r from-emerald-500 to-emerald-600 text-white font-medium px-4 py-2 rounded-lg shadow-sm hover:shadow-md transform transition-all duration-200 hover:-translate-y-0.5;
}

.btn-danger {
  @apply bg-gradient-to-r from-rose-500 to-rose-600 text-white font-medium px-4 py-2 rounded-lg shadow-sm hover:shadow-md transform transition-all duration-200 hover:-translate-y-0.5;
}

/* Card styles */
.card {
  @apply bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden transition-all duration-200 hover:shadow-md;
}

.card-header {
  @apply px-6 py-4 bg-gradient-to-r from-gray-50 to-gray-100 border-b border-gray-100;
}

.card-body {
  @apply p-6;
}

/* Modern input styles */
.input-modern {
  @apply w-full px-4 py-2.5 bg-white border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-200 text-gray-700 placeholder-gray-400;
}

/* Glass morphism effects */
.glass {
  @apply bg-white bg-opacity-70 backdrop-blur-lg border border-white border-opacity-20;
}

.glass-dark {
  @apply bg-gray-900 bg-opacity-70 backdrop-blur-lg border border-gray-700 border-opacity-20;
}

/* APA Document Base Styling */
.apa-document {
  max-width: 100%;
  overflow-wrap: break-word;
  /* font-family removed to preserve original document fonts */
}

.apa-document h1,
.apa-document h2,
.apa-document h3,
.apa-document h4,
.apa-document h5,
.apa-document h6 {
  text-indent: 0;
}

.apa-document strong,
.apa-document b {
  font-weight: bold;
}

.apa-document em,
.apa-document i {
  font-style: italic;
}

.apa-document u {
  text-decoration: underline;
}

/* References section specific styling */
.apa-document .hanging-indent {
  padding-left: 0.5in;
  text-indent: -0.5in;
}

/* APA Issue Highlighting in Editor */
.active-issue {
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
  border-radius: 2px;
}

/* Custom animations for issue highlighting in panel */
@keyframes issueHighlight {
  0% {
    background-color: transparent;
  }
  25% {
    background-color: rgba(99, 102, 241, 0.2);
    transform: scale(1.01);
  }
  50% {
    background-color: rgba(99, 102, 241, 0.3);
  }
  75% {
    background-color: rgba(99, 102, 241, 0.2);
    transform: scale(1.01);
  }
  100% {
    background-color: transparent;
    transform: scale(1);
  }
}

.issue-highlight-animation {
  animation: issueHighlight 2s ease-in-out;
}

/* Issue severity styles for editor */
mark[data-issue-id] {
  cursor: pointer;
  padding: 1px 2px;
  border-radius: 2px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}



// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\layout.js
import './globals.css'
import '@/styles/tiptap.css'
import ErrorBoundary from '@/components/ErrorBoundary'
import { Analytics } from '@vercel/analytics/react'
import { Toaster } from '@/components/ui/toaster'
import { Inter, Outfit } from 'next/font/google'
import AppLayout from './AppLayout'

const inter = Inter({
  subsets: ['latin'],
  variable: '--font-inter',
  display: 'swap',
});

const outfit = Outfit({
  subsets: ['latin'],
  variable: '--font-outfit',
  display: 'swap',
});

export const metadata = {
  title: 'APA 7th Edition Document Checker',
  description: 'Validate academic documents against APA 7th edition guidelines',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en" className={`${inter.variable} ${outfit.variable}`}>
      <body className="font-sans antialiased text-slate-800 bg-slate-50">
        <ErrorBoundary showDetails={process.env.NODE_ENV === 'development'}>
          <AppLayout>{children}</AppLayout>
        </ErrorBoundary>
        <Toaster />
        <Analytics />
      </body>
    </html>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\login\page.js
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import Link from 'next/link';
import { FileCheck, ArrowRight, LogIn, Loader2 } from 'lucide-react';
import { motion } from 'framer-motion';

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleLogin = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    const supabase = createClient();

    try {
      const { error } = await supabase.auth.signInWithPassword({
        email,
        password,
      });

      if (error) {
        setError(error.message);
        setLoading(false);
        return;
      }

      router.push('/dashboard');
      router.refresh();
    } catch (err) {
      setError('An unexpected error occurred. Please try again.');
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-100 px-4">
      <motion.div 
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="max-w-md w-full space-y-8"
      >
        <div className="text-center">
          <Link href="/" className="inline-block mb-6">
            <div className="w-16 h-16 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-2xl flex items-center justify-center shadow-lg mx-auto">
              <FileCheck className="h-8 w-8 text-white" />
            </div>
          </Link>
          <h2 className="text-4xl font-extrabold text-slate-900">
            Welcome Back
          </h2>
          <p className="mt-2 text-slate-600">
            Sign in to continue to APA Pro.
          </p>
        </div>

        <motion.div 
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
          className="bg-white p-8 rounded-2xl shadow-xl border border-slate-200/80"
        >
          <form className="space-y-6" onSubmit={handleLogin} method="POST" action="#">
            <div className="space-y-4">
              <div>
                <label htmlFor="email" className="block text-sm font-bold text-slate-700 mb-2">
                  Email address
                </label>
                <input
                  id="email"
                  name="email"
                  type="email"
                  autoComplete="email"
                  required
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full px-4 py-3 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                  placeholder="you@example.com"
                />
              </div>

              <div>
                <label htmlFor="password" className="block text-sm font-bold text-slate-700 mb-2">
                  Password
                </label>
                <input
                  id="password"
                  name="password"
                  type="password"
                  autoComplete="current-password"
                  required
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full px-4 py-3 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                  placeholder="••••••••"
                />
              </div>
            </div>

            {error && (
              <div className="bg-red-100 border border-red-300 text-red-800 px-4 py-3 rounded-lg text-sm">
                <span className="font-medium">Error:</span> {error}
              </div>
            )}

            <div>
              <button
                type="submit"
                disabled={loading}
                className="w-full flex justify-center items-center space-x-2 py-3 px-4 border border-transparent rounded-lg font-bold text-white bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
              >
                {loading ? (
                  <>
                    <Loader2 className="h-5 w-5 animate-spin" />
                    <span>Signing in...</span>
                  </>
                ) : (
                  <>
                    <LogIn className="h-5 w-5"/>
                    <span>Sign In</span>
                  </>
                )}
              </button>
            </div>
          </form>

          <div className="text-center mt-6 text-sm">
            <span className="text-slate-600">Don&apos;t have an account? </span>
            <Link href="/signup" className="font-semibold text-blue-600 hover:text-blue-700 transition-colors">
              Sign up for free
            </Link>
          </div>
        </motion.div>
      </motion.div>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\not-found.js
import Link from 'next/link';

/**
 * Global 404 page
 * Shows when any page is not found in the application
 */
export default function NotFound() {
  return (
    <div className="min-h-screen bg-white flex items-center justify-center px-4">
      <div className="max-w-md w-full bg-white border border-gray-200 rounded-lg shadow-sm p-8">
        <div className="text-center">
          {/* 404 Icon */}
          <div className="mx-auto flex items-center justify-center h-20 w-20 rounded-full bg-gray-100 mb-6">
            <span className="text-3xl font-bold text-gray-600">404</span>
          </div>

          {/* Title */}
          <h1 className="text-3xl font-bold text-gray-900 mb-4">
            Page Not Found
          </h1>

          {/* Description */}
          <p className="text-gray-600 mb-8">
            The page you&apos;re looking for doesn&apos;t exist or has been moved.
          </p>

          {/* Actions */}
          <div className="space-y-3">
            <Link
              href="/dashboard"
              className="block w-full px-4 py-3 bg-emerald-600 text-white rounded-lg hover:bg-emerald-700 transition-colors font-medium"
            >
              Go to Dashboard
            </Link>
            <Link
              href="/"
              className="block w-full px-4 py-3 bg-gray-100 text-gray-900 rounded-lg hover:bg-gray-200 transition-colors font-medium"
            >
              Go to Home
            </Link>
          </div>
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\page.js
"use client";
import Link from "next/link";
import { useState } from "react";
import {
  FileCheck,
  CheckCircle2,
  Sparkles,
  ArrowRight,
  Zap,
  BookOpen,
  Award,
  Menu,
  X,
  ChevronRight,
} from "lucide-react";
import { motion } from "framer-motion";
import DisclaimerModal from "@/components/DisclaimerModal";

const FeatureCard = ({ icon, title, children, delay }) => (
  <motion.div
    initial={{ opacity: 0, y: 50 }}
    whileInView={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.5, delay }}
    viewport={{ once: true }}
    className="bg-white p-8 rounded-2xl shadow-lg hover:shadow-xl transition-shadow duration-300"
  >
    <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-indigo-600 text-white rounded-xl flex items-center justify-center mb-6">
      {icon}
    </div>
    <h3 className="text-xl font-bold text-slate-800 mb-3">{title}</h3>
    <p className="text-slate-500 leading-relaxed">{children}</p>
  </motion.div>
);

const Step = ({ number, title, children, delay }) => (
  <motion.div
    initial={{ opacity: 0, y: 50 }}
    whileInView={{ opacity: 1, y: 0 }}
    transition={{ duration: 0.5, delay }}
    viewport={{ once: true }}
    className="text-center"
  >
    <div className="relative mb-6">
      <div className="w-16 h-16 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full mx-auto flex items-center justify-center shadow-lg">
        <span className="text-2xl font-bold text-white">{number}</span>
      </div>
    </div>
    <h3 className="text-2xl font-bold text-slate-800 mb-3">{title}</h3>
    <p className="text-slate-500 max-w-xs mx-auto">{children}</p>
  </motion.div>
);

export default function LandingPage() {
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  return (
    <div className="min-h-screen bg-slate-50 font-sans">
      {/* Disclaimer Modal - Shows once for new visitors */}
      <DisclaimerModal />

      {/* Hero Section */}
      <main>
        <section className="relative pt-24 pb-32">
          <div className="absolute inset-0 bg-gradient-to-b from-white to-slate-100"></div>
          <div className="relative max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
            <motion.div
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.8 }}
            >
              <div className="inline-flex items-center space-x-2 px-4 py-2 bg-blue-100 text-blue-800 rounded-full text-sm font-semibold mb-8">
                <Award className="h-5 w-5" />
                <span>APA 7th Edition Compliant</span>
              </div>

              <h1 className="text-5xl md:text-7xl font-extrabold text-slate-900 mb-6 leading-tight">
                Flawless APA Formatting,
                <span className="block text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-indigo-700 mt-2">
                  Instantly.
                </span>
              </h1>

              <p className="text-lg md:text-xl text-slate-600 mb-12 max-w-3xl mx-auto leading-relaxed">
                Upload your DOCX file and let our AI-powered engine identify and
                help you fix every APA 7th edition formatting error.
              </p>

              <div className="flex flex-col sm:flex-row gap-4 justify-center">
                <Link
                  href="/signup"
                  className="inline-flex items-center justify-center space-x-2 px-8 py-4 bg-gradient-to-r from-blue-600 to-indigo-700 text-white font-bold rounded-xl hover:shadow-lg transition-shadow duration-300 text-lg"
                >
                  <span>Analyze Your Document</span>
                  <ArrowRight className="h-5 w-5" />
                </Link>
                <Link
                  href="/signup"
                  className="inline-flex items-center justify-center space-x-2 px-8 py-4 bg-white text-slate-700 font-semibold rounded-xl border border-slate-300 hover:border-slate-400 hover:bg-slate-100 transition-all duration-200 text-lg"
                >
                  <span>Try the Editor</span>
                </Link>
              </div>
            </motion.div>

            <motion.div
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ duration: 0.8, delay: 0.3 }}
              className="relative mx-auto max-w-4xl mt-20"
            >
              <div className="bg-white rounded-2xl shadow-2xl border border-slate-200/80 overflow-hidden">
                <div className="bg-slate-100 px-6 py-4 border-b border-slate-200 flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <div className="w-3 h-3 bg-red-400 rounded-full"></div>
                    <div className="w-3 h-3 bg-yellow-400 rounded-full"></div>
                    <div className="w-3 h-3 bg-green-400 rounded-full"></div>
                  </div>
                  <div className="text-sm text-slate-600 font-medium">
                    document_final_draft.docx
                  </div>
                  <div className="w-12"></div>
                </div>
                <div className="p-8 text-left">
                  <div className="space-y-4">
                    <div className="flex items-start space-x-4">
                      <CheckCircle2 className="h-6 w-6 text-green-500 flex-shrink-0 mt-0.5" />
                      <div>
                        <h4 className="font-semibold text-slate-800">
                          Title Page
                        </h4>
                        <p className="text-slate-500">
                          Formatting validated and compliant.
                        </p>
                      </div>
                    </div>
                    <div className="flex items-start space-x-4">
                      <CheckCircle2 className="h-6 w-6 text-green-500 flex-shrink-0 mt-0.5" />
                      <div>
                        <h4 className="font-semibold text-slate-800">
                          In-text Citations
                        </h4>
                        <p className="text-slate-500">
                          All 47 citations verified against reference list.
                        </p>
                      </div>
                    </div>
                    <div className="flex items-start space-x-4">
                      <div className="w-6 h-6 bg-yellow-100 rounded-full flex items-center justify-center flex-shrink-0 mt-0.5">
                        <div className="w-2.5 h-2.5 bg-yellow-500 rounded-full"></div>
                      </div>
                      <div>
                        <h4 className="font-semibold text-slate-800">
                          Reference List
                        </h4>
                        <p className="text-slate-500">
                          3 formatting suggestions available.
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </motion.div>
          </div>
        </section>

        {/* Features Section */}
        <section id="features" className="py-24 bg-slate-100">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center mb-16">
              <h2 className="text-4xl md:text-5xl font-extrabold text-slate-900 mb-4">
                The Ultimate APA Toolkit
              </h2>
              <p className="text-lg text-slate-600 max-w-3xl mx-auto">
                Go beyond basic spell-checking. Our AI understands the nuances
                of academic writing and APA guidelines.
              </p>
            </div>

            <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
              <FeatureCard
                icon={<Zap className="h-6 w-6" />}
                title="Comprehensive Analysis"
                delay={0.1}
              >
                From title page to references, we check every detail:
                citations, formatting, structure, and bias-free language.
              </FeatureCard>
              <FeatureCard
                icon={<Sparkles className="h-6 w-6" />}
                title="Smart Corrections"
                delay={0.2}
              >
                Get one-click fixes for common APA errors and receive
                context-aware suggestions for more complex issues.
              </FeatureCard>
              <FeatureCard
                icon={<BookOpen className="h-6 w-6" />}
                title="Educational Insights"
                delay={0.3}
              >
                Learn as you go. Each suggestion is linked to detailed
                explanations and official APA guidelines.
              </FeatureCard>
            </div>
          </div>
        </section>

        {/* How It Works Section */}
        <section id="how-it-works" className="py-24 bg-white">
          <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div className="text-center mb-20">
              <h2 className="text-4xl md:text-5xl font-extrabold text-slate-900 mb-4">
                Get Feedback in Three Simple Steps
              </h2>
              <p className="text-lg text-slate-600">
                Our streamlined process makes APA compliance effortless.
              </p>
            </div>

            <div className="grid md:grid-cols-3 gap-12 relative">
              {/* Dashed Line Connector */}
              <div className="hidden md:block absolute top-1/2 left-0 w-full h-px -translate-y-20">
                <svg
                  width="100%"
                  height="100%"
                  className="text-slate-300"
                >
                  <line
                    x1="0"
                    y1="50%"
                    x2="100%"
                    y2="50%"
                    strokeWidth="2"
                    strokeDasharray="8, 8"
                  />
                </svg>
              </div>

              <Step number="1" title="Upload Document" delay={0.1}>
                Securely drag and drop or select your DOCX file. Your work is
                always private and protected.
              </Step>
              <Step number="2" title="Instant Analysis" delay={0.3}>
                Our AI scans your document in seconds, cross-referencing every
                line with APA 7th edition rules.
              </Step>
              <Step number="3" title="Review & Correct" delay={0.5}>
                Explore the interactive report, understand the issues, and
                apply one-click fixes.
              </Step>
            </div>
          </div>
        </section>

        {/* CTA Section */}
        <section className="bg-gradient-to-br from-blue-600 to-indigo-700">
          <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-20 text-center">
            <h2 className="text-4xl md:text-5xl font-extrabold text-white mb-6">
              Ready to Elevate Your Writing?
            </h2>
            <p className="text-xl text-blue-100 mb-10">
              Stop worrying about formatting and focus on your ideas. Get
              started for free today.
            </p>
            <Link
              href="/signup"
              className="inline-flex items-center space-x-2 px-8 py-4 bg-white text-blue-600 font-bold rounded-xl hover:bg-slate-100 transition-colors duration-300 shadow-2xl text-lg"
            >
              <span>Sign Up and Start Checking</span>
              <ChevronRight className="h-5 w-5" />
            </Link>
          </div>
        </section>
      </main>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\profile\loading.js
import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardContent, CardHeader } from "@/components/ui/card";

export default function ProfileLoading() {
  return (
    <div className="min-h-screen bg-slate-100 flex">
      {/* Sidebar placeholder */}
      <div className="w-64 h-screen bg-white border-r border-slate-200 flex flex-col shadow-sm hidden md:flex">
        <div className="p-6 border-b border-slate-200">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl"></div>
            <span className="text-2xl font-bold text-slate-800">APA Pro</span>
          </div>
        </div>
      </div>

      <div className="flex-1 p-6 sm:p-8">
        <div className="max-w-4xl mx-auto space-y-6">
          {/* Loading Message */}
          <div className="flex items-center gap-3 text-slate-600">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
            <p className="text-sm font-medium">Loading your profile...</p>
          </div>

          {/* Header Skeleton */}
          <div className="flex items-center gap-4">
            <Skeleton className="h-10 w-10 rounded-lg" />
            <div className="space-y-2">
              <Skeleton className="h-9 w-48" />
              <Skeleton className="h-5 w-64" />
            </div>
          </div>

          {/* Profile Card Skeleton */}
          <Card>
            <CardHeader>
              <Skeleton className="h-6 w-48" />
              <Skeleton className="h-4 w-64 mt-2" />
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="flex items-center gap-6">
                <Skeleton className="w-24 h-24 rounded-full" />
                <div className="space-y-2">
                  <Skeleton className="h-6 w-32" />
                  <Skeleton className="h-4 w-24" />
                </div>
              </div>
              <div className="space-y-4">
                {[1, 2, 3].map((i) => (
                  <div key={i} className="flex items-center gap-3">
                    <Skeleton className="w-10 h-10 rounded-lg" />
                    <div className="flex-1 space-y-2">
                      <Skeleton className="h-4 w-32" />
                      <Skeleton className="h-4 w-48" />
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\profile\page.js
import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getUserWithProfile } from '@/lib/profiles';
import ProfileClient from './ProfileClient';

export const dynamic = 'force-dynamic';

export default async function ProfilePage() {
  const supabase = await createClient();

  // Get current user with profile data
  const { user, profile, error: userError } = await getUserWithProfile(supabase);

  if (userError || !user) {
    redirect('/login');
  }

  return <ProfileClient user={user} profile={profile} />;
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\profile\ProfileClient.js
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { updateUserProfile } from '@/lib/profiles';
import { useToast } from '@/hooks/use-toast';
import Sidebar from '@/components/dashboard/Sidebar';
import MobileSidebar from '@/components/dashboard/MobileSidebar';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Label } from '@/components/ui/label';
import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { Separator } from '@/components/ui/separator';
import { User, Mail, Calendar, ArrowLeft, Loader2, Phone, UserCircle } from 'lucide-react';

export default function ProfileClient({ user, profile }) {
  const router = useRouter();
  const { toast } = useToast();
  const supabase = createClient();
  const [loading, setLoading] = useState(false);
  const [editing, setEditing] = useState(false);

  // Form state
  const [formData, setFormData] = useState({
    display_name: profile?.display_name || '',
    full_name: profile?.full_name || '',
    phone: profile?.phone || '',
    bio: profile?.bio || '',
  });

  const getInitials = (email) => {
    if (!email) return "U";
    const parts = email.split('@')[0].split('.');
    if (parts.length > 1) {
      return (parts[0][0] + parts[1][0]).toUpperCase();
    }
    return email.substring(0, 2).toUpperCase();
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  const handleSaveProfile = async () => {
    setLoading(true);

    try {
      const { data, error } = await updateUserProfile(supabase, user.id, formData);

      if (error) {
        toast({
          variant: "destructive",
          title: "Update failed",
          description: error.message || "Failed to update profile. Please try again.",
        });
        setLoading(false);
        return;
      }

      toast({
        title: "Profile updated",
        description: "Your profile has been updated successfully.",
      });

      setEditing(false);
      setLoading(false);

      // Refresh the page to show updated data
      router.refresh();
    } catch (err) {
      toast({
        variant: "destructive",
        title: "Update failed",
        description: "An unexpected error occurred. Please try again.",
      });
      setLoading(false);
    }
  };

  const handleCancel = () => {
    // Reset form to original profile data
    setFormData({
      display_name: profile?.display_name || '',
      full_name: profile?.full_name || '',
      phone: profile?.phone || '',
      bio: profile?.bio || '',
    });
    setEditing(false);
  };

  return (
    <div className="min-h-screen bg-slate-100 flex">
      <Sidebar user={user} profile={profile} />
      <MobileSidebar user={user} profile={profile} />

      <div className="flex-1 p-6 sm:p-8">
        <div className="max-w-4xl mx-auto space-y-6">
          {/* Header */}
          <div className="flex items-center gap-4">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => router.push('/dashboard')}
            >
              <ArrowLeft className="h-5 w-5" />
            </Button>
            <div>
              <h1 className="text-3xl font-bold text-slate-900">Profile</h1>
              <p className="text-slate-500">Manage your account information</p>
            </div>
          </div>

          {/* Profile Overview Card */}
          <Card>
            <CardHeader className="flex flex-row items-center justify-between">
              <div>
                <CardTitle>Account Information</CardTitle>
                <CardDescription>Your personal account details</CardDescription>
              </div>
              {!editing && (
                <Button onClick={() => setEditing(true)} variant="outline">
                  Edit Profile
                </Button>
              )}
            </CardHeader>
            <CardContent className="space-y-6">
              {/* Avatar Section */}
              <div className="flex items-center gap-6">
                <Avatar className="w-24 h-24">
                  <AvatarFallback className="bg-gradient-to-br from-blue-500 to-indigo-600 text-white text-2xl font-semibold">
                    {getInitials(user?.email)}
                  </AvatarFallback>
                </Avatar>
                <div className="space-y-1">
                  <h3 className="text-xl font-semibold text-slate-900">
                    {profile?.display_name || user?.email?.split('@')[0] || 'User'}
                  </h3>
                  <p className="text-sm text-slate-500">{user?.email}</p>
                </div>
              </div>

              <Separator />

              {/* Editable Profile Fields */}
              <div className="space-y-4">
                <div className="space-y-2">
                  <Label htmlFor="display_name" className="flex items-center gap-2">
                    <UserCircle className="h-4 w-4 text-slate-600" />
                    Display Name
                  </Label>
                  <Input
                    id="display_name"
                    value={formData.display_name}
                    onChange={(e) => setFormData({...formData, display_name: e.target.value})}
                    disabled={!editing}
                    placeholder="Enter display name"
                    className={!editing ? "bg-slate-50" : ""}
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="full_name" className="flex items-center gap-2">
                    <User className="h-4 w-4 text-slate-600" />
                    Full Name
                  </Label>
                  <Input
                    id="full_name"
                    value={formData.full_name}
                    onChange={(e) => setFormData({...formData, full_name: e.target.value})}
                    disabled={!editing}
                    placeholder="Enter full name"
                    className={!editing ? "bg-slate-50" : ""}
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="phone" className="flex items-center gap-2">
                    <Phone className="h-4 w-4 text-slate-600" />
                    Phone Number
                  </Label>
                  <Input
                    id="phone"
                    value={formData.phone}
                    onChange={(e) => setFormData({...formData, phone: e.target.value})}
                    disabled={!editing}
                    placeholder="Enter phone number"
                    className={!editing ? "bg-slate-50" : ""}
                  />
                </div>

                <div className="space-y-2">
                  <Label htmlFor="bio">Bio</Label>
                  <Textarea
                    id="bio"
                    value={formData.bio}
                    onChange={(e) => setFormData({...formData, bio: e.target.value})}
                    disabled={!editing}
                    placeholder="Tell us about yourself"
                    className={!editing ? "bg-slate-50" : ""}
                    rows={4}
                  />
                </div>

                {editing && (
                  <div className="flex gap-2 pt-4">
                    <Button onClick={handleSaveProfile} disabled={loading}>
                      {loading ? (
                        <>
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                          Saving...
                        </>
                      ) : (
                        'Save Changes'
                      )}
                    </Button>
                    <Button variant="outline" onClick={handleCancel} disabled={loading}>
                      Cancel
                    </Button>
                  </div>
                )}
              </div>

              <Separator />

              {/* Read-Only Account Info */}
              <div className="space-y-4">
                <div className="flex items-center gap-3">
                  <div className="w-10 h-10 rounded-lg bg-slate-100 flex items-center justify-center">
                    <Mail className="h-5 w-5 text-slate-600" />
                  </div>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-slate-700">Email Address</p>
                    <p className="text-sm text-slate-900">{user?.email}</p>
                  </div>
                </div>

                <div className="flex items-center gap-3">
                  <div className="w-10 h-10 rounded-lg bg-slate-100 flex items-center justify-center">
                    <Calendar className="h-5 w-5 text-slate-600" />
                  </div>
                  <div className="flex-1">
                    <p className="text-sm font-medium text-slate-700">Member Since</p>
                    <p className="text-sm text-slate-900">
                      {profile?.created_at ? formatDate(profile.created_at) : 'N/A'}
                    </p>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>


          {/* Account Actions */}
          <Card className="border-red-200">
            <CardHeader>
              <CardTitle className="text-red-600">Danger Zone</CardTitle>
              <CardDescription>Irreversible account actions</CardDescription>
            </CardHeader>
            <CardContent>
              <Button
                variant="destructive"
                onClick={() => {
                  toast({
                    variant: "destructive",
                    title: "Feature coming soon",
                    description: "Account deletion will be available in a future update.",
                  });
                }}
              >
                Delete Account
              </Button>
              <p className="text-xs text-slate-500 mt-2">
                This action cannot be undone and will permanently delete your account and all associated data.
              </p>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\settings\loading.js
import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardContent, CardHeader } from "@/components/ui/card";

export default function SettingsLoading() {
  return (
    <div className="min-h-screen bg-slate-100 flex">
      {/* Sidebar placeholder */}
      <div className="w-64 h-screen bg-white border-r border-slate-200 flex flex-col shadow-sm hidden md:flex">
        <div className="p-6 border-b border-slate-200">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl"></div>
            <span className="text-2xl font-bold text-slate-800">APA Pro</span>
          </div>
        </div>
      </div>

      <div className="flex-1 p-6 sm:p-8">
        <div className="max-w-4xl mx-auto space-y-6">
          {/* Loading Message */}
          <div className="flex items-center gap-3 text-slate-600">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
            <p className="text-sm font-medium">Loading your settings...</p>
          </div>

          {/* Header Skeleton */}
          <div className="flex items-center gap-4">
            <Skeleton className="h-10 w-10 rounded-lg" />
            <div className="space-y-2">
              <Skeleton className="h-9 w-32" />
              <Skeleton className="h-5 w-64" />
            </div>
          </div>

          {/* Settings Cards Skeleton */}
          {[1, 2, 3, 4].map((i) => (
            <Card key={i}>
              <CardHeader>
                <div className="flex items-center gap-2">
                  <Skeleton className="h-5 w-5 rounded" />
                  <Skeleton className="h-6 w-40" />
                </div>
                <Skeleton className="h-4 w-64 mt-2" />
              </CardHeader>
              <CardContent className="space-y-6">
                {[1, 2].map((j) => (
                  <div key={j} className="flex items-center justify-between">
                    <div className="space-y-2 flex-1">
                      <Skeleton className="h-5 w-48" />
                      <Skeleton className="h-4 w-full max-w-md" />
                    </div>
                    <Skeleton className="h-6 w-11 rounded-full" />
                  </div>
                ))}
              </CardContent>
            </Card>
          ))}
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\settings\page.js
import { createClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import SettingsClient from './SettingsClient';

export const dynamic = 'force-dynamic';

export default async function SettingsPage() {
  const supabase = await createClient();

  const {
    data: { user },
    error: userError,
  } = await supabase.auth.getUser();

  if (userError || !user) {
    redirect('/login');
  }

  return <SettingsClient user={user} />;
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\settings\SettingsClient.js
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useToast } from '@/hooks/use-toast';
import Sidebar from '@/components/dashboard/Sidebar';
import MobileSidebar from '@/components/dashboard/MobileSidebar';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Switch } from '@/components/ui/switch';
import { Separator } from '@/components/ui/separator';
import { ArrowLeft, Bell, Eye, FileText, Zap, Shield } from 'lucide-react';

export default function SettingsClient({ user }) {
  const router = useRouter();
  const { toast } = useToast();

  // Settings state
  const [settings, setSettings] = useState({
    emailNotifications: true,
    analysisNotifications: true,
    autoAnalysis: false,
    showLineNumbers: true,
    highlightIssues: true,
    strictMode: false,
  });

  const handleToggle = (setting) => {
    setSettings(prev => ({
      ...prev,
      [setting]: !prev[setting],
    }));
    toast({
      title: "Setting updated",
      description: "Your preferences have been saved.",
    });
  };

  return (
    <div className="min-h-screen bg-slate-100 flex">
      <Sidebar user={user} />
      <MobileSidebar user={user} />

      <div className="flex-1 p-6 sm:p-8">
        <div className="max-w-4xl mx-auto space-y-6">
          {/* Header */}
          <div className="flex items-center gap-4">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => router.push('/dashboard')}
            >
              <ArrowLeft className="h-5 w-5" />
            </Button>
            <div>
              <h1 className="text-3xl font-bold text-slate-900">Settings</h1>
              <p className="text-slate-500">Customize your APA Pro experience</p>
            </div>
          </div>

          {/* Notifications Settings */}
          <Card>
            <CardHeader>
              <div className="flex items-center gap-2">
                <Bell className="h-5 w-5 text-slate-600" />
                <CardTitle>Notifications</CardTitle>
              </div>
              <CardDescription>Manage how you receive notifications</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <p className="font-medium text-slate-900">Email Notifications</p>
                  <p className="text-sm text-slate-500">
                    Receive email updates about your documents
                  </p>
                </div>
                <Switch
                  checked={settings.emailNotifications}
                  onCheckedChange={() => handleToggle('emailNotifications')}
                />
              </div>

              <Separator />

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <p className="font-medium text-slate-900">Analysis Completion</p>
                  <p className="text-sm text-slate-500">
                    Get notified when document analysis is complete
                  </p>
                </div>
                <Switch
                  checked={settings.analysisNotifications}
                  onCheckedChange={() => handleToggle('analysisNotifications')}
                />
              </div>
            </CardContent>
          </Card>

          {/* Editor Settings */}
          <Card>
            <CardHeader>
              <div className="flex items-center gap-2">
                <FileText className="h-5 w-5 text-slate-600" />
                <CardTitle>Editor Preferences</CardTitle>
              </div>
              <CardDescription>Customize your document editing experience</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <p className="font-medium text-slate-900">Auto-Analysis</p>
                  <p className="text-sm text-slate-500">
                    Automatically analyze documents when changes are made
                  </p>
                </div>
                <Switch
                  checked={settings.autoAnalysis}
                  onCheckedChange={() => handleToggle('autoAnalysis')}
                />
              </div>

              <Separator />

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <p className="font-medium text-slate-900">Show Line Numbers</p>
                  <p className="text-sm text-slate-500">
                    Display line numbers in the editor
                  </p>
                </div>
                <Switch
                  checked={settings.showLineNumbers}
                  onCheckedChange={() => handleToggle('showLineNumbers')}
                />
              </div>

              <Separator />

              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <p className="font-medium text-slate-900">Highlight Issues</p>
                  <p className="text-sm text-slate-500">
                    Highlight APA compliance issues in the document
                  </p>
                </div>
                <Switch
                  checked={settings.highlightIssues}
                  onCheckedChange={() => handleToggle('highlightIssues')}
                />
              </div>
            </CardContent>
          </Card>

          {/* Analysis Settings */}
          <Card>
            <CardHeader>
              <div className="flex items-center gap-2">
                <Shield className="h-5 w-5 text-slate-600" />
                <CardTitle>Analysis Settings</CardTitle>
              </div>
              <CardDescription>Configure APA compliance checking behavior</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="flex items-center justify-between">
                <div className="space-y-0.5">
                  <p className="font-medium text-slate-900">Strict Mode</p>
                  <p className="text-sm text-slate-500">
                    Enable stricter APA 7th edition compliance checking
                  </p>
                </div>
                <Switch
                  checked={settings.strictMode}
                  onCheckedChange={() => handleToggle('strictMode')}
                />
              </div>
            </CardContent>
          </Card>

          {/* Performance Settings */}
          <Card>
            <CardHeader>
              <div className="flex items-center gap-2">
                <Zap className="h-5 w-5 text-slate-600" />
                <CardTitle>Performance</CardTitle>
              </div>
              <CardDescription>Optimize application performance</CardDescription>
            </CardHeader>
            <CardContent>
              <Button
                variant="outline"
                onClick={() => {
                  toast({
                    title: "Cache cleared",
                    description: "Application cache has been cleared successfully.",
                  });
                }}
              >
                Clear Cache
              </Button>
              <p className="text-xs text-slate-500 mt-2">
                Clear cached data to free up storage space
              </p>
            </CardContent>
          </Card>

          {/* Save Button */}
          <div className="flex justify-end">
            <Button
              onClick={() => {
                toast({
                  title: "Settings saved",
                  description: "All your preferences have been saved successfully.",
                });
                router.push('/dashboard');
              }}
            >
              Save All Settings
            </Button>
          </div>
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\signup\page.js
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import Link from 'next/link';
import { FileCheck, ArrowRight, UserPlus, MailCheck, Loader2 } from 'lucide-react';
import { motion } from 'framer-motion';

// Feature flag: Set to true when email verification is enabled in Supabase
const EMAIL_VERIFICATION_ENABLED = false;

export default function SignupPage() {
  const router = useRouter();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [success, setSuccess] = useState(false);

  const handleSignup = async (e) => {
    e.preventDefault();
    setError('');
    setLoading(true);

    // Validate passwords match
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      setLoading(false);
      return;
    }

    // Validate password strength
    if (password.length < 6) {
      setError('Password must be at least 6 characters');
      setLoading(false);
      return;
    }

    const supabase = createClient();

    try {
      const { data, error } = await supabase.auth.signUp({
        email,
        password,
        options: {
          emailRedirectTo: `${window.location.origin}/auth/callback`,
        },
      });

      if (error) {
        setError(error.message);
        setLoading(false);
        return;
      }

      // Check if email confirmation is required
      if (data?.user?.identities?.length === 0) {
        setError('This email is already registered. Please sign in instead.');
        setLoading(false);
        return;
      }

      // Successful signup
      setLoading(false);

      // If email confirmation is disabled, redirect to dashboard immediately
      if (data.session || !EMAIL_VERIFICATION_ENABLED) {
        router.push('/dashboard');
        router.refresh();
      } else {
        // Show email verification screen only if verification is enabled
        setSuccess(true);
      }
    } catch (err) {
      setError('An unexpected error occurred. Please try again.');
      setLoading(false);
    }
  };

  // Only show email verification screen if the feature is enabled
  if (success && EMAIL_VERIFICATION_ENABLED) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-slate-100 px-4">
        <motion.div 
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="max-w-md w-full text-center bg-white p-8 rounded-2xl shadow-xl border border-slate-200/80"
        >
          <div className="mx-auto flex items-center justify-center h-16 w-16 rounded-full bg-gradient-to-br from-blue-500 to-indigo-600">
            <MailCheck className="h-8 w-8 text-white" />
          </div>
          <h2 className="mt-6 text-3xl font-extrabold text-slate-900">
            Confirm Your Email
          </h2>
          <p className="mt-2 text-slate-600">
            We&apos;ve sent a confirmation link to <strong>{email}</strong>. Please check your inbox to activate your account.
          </p>
          <p className="mt-6 text-sm text-slate-500">
            Already confirmed? <Link href="/login" className="font-semibold text-blue-600 hover:text-blue-700">Sign in</Link>
          </p>
        </motion.div>
      </div>
    );
  }

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-100 px-4">
      <motion.div 
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="max-w-md w-full space-y-8"
      >
        <div className="text-center">
          <Link href="/" className="inline-block mb-6">
            <div className="w-16 h-16 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-2xl flex items-center justify-center shadow-lg mx-auto">
              <FileCheck className="h-8 w-8 text-white" />
            </div>
          </Link>
          <h2 className="text-4xl font-extrabold text-slate-900">
            Create Your Account
          </h2>
          <p className="mt-2 text-slate-600">
            Get started with the most powerful APA tool.
          </p>
        </div>

        <motion.div 
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
          className="bg-white p-8 rounded-2xl shadow-xl border border-slate-200/80"
        >
          <form className="space-y-6" onSubmit={handleSignup} method="POST" action="#">
            <div className="space-y-4">
              <div>
                <label htmlFor="email" className="block text-sm font-bold text-slate-700 mb-2">
                  Email address
                </label>
                <input
                  id="email"
                  name="email"
                  type="email"
                  autoComplete="email"
                  required
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="w-full px-4 py-3 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                  placeholder="you@example.com"
                />
              </div>

              <div>
                <label htmlFor="password" className="block text-sm font-bold text-slate-700 mb-2">
                  Password
                </label>
                <input
                  id="password"
                  name="password"
                  type="password"
                  autoComplete="new-password"
                  required
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="w-full px-4 py-3 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                  placeholder="••••••••"
                />
                 <p className="mt-2 text-xs text-slate-500">
                  Must be at least 6 characters long.
                </p>
              </div>

              <div>
                <label htmlFor="confirmPassword" className="block text-sm font-bold text-slate-700 mb-2">
                  Confirm Password
                </label>
                <input
                  id="confirmPassword"
                  name="confirmPassword"
                  type="password"
                  autoComplete="new-password"
                  required
                  value={confirmPassword}
                  onChange={(e) => setConfirmPassword(e.target.value)}
                  className="w-full px-4 py-3 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all"
                  placeholder="••••••••"
                />
              </div>
            </div>

            {error && (
              <div className="bg-red-100 border border-red-300 text-red-800 px-4 py-3 rounded-lg text-sm">
                <span className="font-medium">Error:</span> {error}
              </div>
            )}

            <div>
              <button
                type="submit"
                disabled={loading}
                className="w-full flex justify-center items-center space-x-2 py-3 px-4 border border-transparent rounded-lg font-bold text-white bg-gradient-to-r from-blue-600 to-indigo-700 hover:from-blue-700 hover:to-indigo-800 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-all duration-300"
              >
                {loading ? (
                  <>
                    <Loader2 className="h-5 w-5 animate-spin" />
                    <span>Creating Account...</span>
                  </>
                ) : (
                  <>
                    <UserPlus className="h-5 w-5"/>
                    <span>Sign Up</span>
                  </>
                )}
              </button>
            </div>
          </form>

          <div className="text-center mt-6 text-sm">
            <span className="text-slate-600">Already have an account? </span>
            <Link href="/login" className="font-semibold text-blue-600 hover:text-blue-700 transition-colors">
              Sign in
            </Link>
          </div>
        </motion.div>
      </motion.div>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\AnalysisErrorBoundary.js
'use client';

import React from 'react';
import { AlertCircle, RefreshCw, CheckCircle2 } from 'lucide-react';

class AnalysisErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });

    if (process.env.NODE_ENV === 'development') {
      console.error('Analysis Error Boundary caught an error:', error, errorInfo);
    }
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });

    // Trigger a retry if onRetry prop is provided
    if (this.props.onRetry) {
      this.props.onRetry();
    }
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="bg-orange-50 border border-orange-200 rounded-lg p-6">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-orange-500 rounded-full flex items-center justify-center flex-shrink-0">
              <AlertCircle className="h-5 w-5 text-white" />
            </div>
            <div className="flex-1">
              <h4 className="text-orange-800 font-semibold">Analysis Error</h4>
              <p className="text-orange-700 text-sm mt-1">
                The document analysis encountered an error. The document is still editable, but some features may not work correctly.
              </p>
            </div>
            <button
              onClick={this.handleRetry}
              className="px-4 py-2 bg-orange-600 text-white rounded-md hover:bg-orange-700 transition-colors text-sm font-medium flex items-center space-x-2"
            >
              <RefreshCw className="h-4 w-4" />
              <span>Retry Analysis</span>
            </button>
          </div>

          {process.env.NODE_ENV === 'development' && this.state.error && (
            <details className="mt-4">
              <summary className="text-xs text-orange-600 cursor-pointer">
                Error Details (Development)
              </summary>
              <div className="mt-2 bg-orange-100 border border-orange-300 rounded p-3 text-xs text-orange-800 font-mono">
                {this.state.error.toString()}
              </div>
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}

export default AnalysisErrorBoundary;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\Dashboard.jsx
'use client';

import { DashboardHeader } from './DashboardHeader';
import { DashboardOverview } from './DashboardOverview';
import { UploadSection } from './UploadSection';
import { RecentDocuments } from './RecentDocuments';

export default function Dashboard({ user, profile, documents, onFileUpload, uploading, uploadingFileName, error, onDelete }) {
  return (
    <main className="flex-1 p-6 sm:p-8 space-y-8">
      <DashboardHeader user={user} profile={profile} />

      <div className="space-y-8">
        <DashboardOverview documents={documents} />

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          <div className="lg:col-span-2">
            <RecentDocuments documents={documents} onDelete={onDelete} />
          </div>
          <div className="lg:col-span-1">
            <UploadSection onFileUpload={onFileUpload} uploading={uploading} uploadingFileName={uploadingFileName} />
          </div>
        </div>

        {error && (
          <div className="bg-red-100 border border-red-300 text-red-800 px-4 py-3 rounded-lg text-sm">
            <span className="font-medium">Error:</span> {error}
          </div>
        )}
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\DashboardHeader.jsx
'use client';

import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { LogOut } from "lucide-react";

export function DashboardHeader({ user, profile }) {
  const router = useRouter();
  const supabase = createClient();

  // Get user initials for avatar
  const getInitials = (email) => {
    if (!email) return "U";
    const parts = email.split('@')[0].split('.');
    if (parts.length > 1) {
      return (parts[0][0] + parts[1][0]).toUpperCase();
    }
    return email.substring(0, 2).toUpperCase();
  };

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    router.push('/');
    router.refresh();
  };

  return (
    <div className="flex items-center justify-between">
      <div>
        <h1 className="text-3xl font-bold text-slate-900">Welcome back, {user?.email?.split('@')[0] || 'User'}!</h1>
        <p className="text-slate-500">Here&apos;s a summary of your documents and their compliance.</p>
      </div>
      <div className="flex items-center gap-3">
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              variant="ghost"
              className="gap-2.5 hover:bg-slate-100 rounded-xl px-3 py-2"
            >
              <div className="text-right hidden sm:block">
                <p className="text-sm font-semibold text-slate-800">{user?.email?.split('@')[0] || 'User'}</p>
                <p className="text-xs text-slate-500">{user?.email || ''}</p>
              </div>
              <Avatar className="w-10 h-10 ring-2 ring-slate-200 ring-offset-2">
                <AvatarFallback className="bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white font-bold">
                  {getInitials(user?.email)}
                </AvatarFallback>
              </Avatar>
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end" className="w-64 p-2 bg-white shadow-xl border border-slate-200">
            <DropdownMenuLabel className="p-3">
              <div className="flex items-center gap-3">
                <Avatar className="w-10 h-10 ring-2 ring-slate-200">
                  <AvatarFallback className="bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white font-bold">
                    {getInitials(user?.email)}
                  </AvatarFallback>
                </Avatar>
                <div className="flex flex-col">
                  <p className="text-sm font-semibold text-slate-900">{user?.email?.split('@')[0] || 'User'}</p>
                  <p className="text-xs text-slate-500">{user?.email || ''}</p>
                </div>
              </div>
            </DropdownMenuLabel>
            <DropdownMenuSeparator />
            <DropdownMenuItem
              onClick={handleSignOut}
              className="cursor-pointer text-red-600 focus:text-red-600 focus:bg-red-50 rounded-lg py-2.5"
            >
              <LogOut className="mr-2 h-4 w-4" />
              <span className="font-medium">Sign Out</span>
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\DashboardOverview.jsx
'use client';

import { Card } from "@/components/ui/card";
import { FileText, CheckCircle2, Clock, AlertCircle } from "lucide-react";

export function DashboardOverview({ documents }) {
  // Calculate stats from documents
  const totalDocuments = documents.length;
  const completedDocuments = documents.filter(doc => doc.status === 'completed').length;
  const processingDocuments = documents.filter(doc => doc.status === 'processing').length;

  const averageCompliance = documents.length > 0
    ? Math.round(
        documents
          .filter(doc => doc.compliance_score !== null)
          .reduce((sum, doc) => sum + (doc.compliance_score || 0), 0) /
        (documents.filter(doc => doc.compliance_score !== null).length || 1)
      )
    : 0;

  const stats = [
    {
      title: "Total Documents",
      value: totalDocuments.toString(),
      icon: FileText,
      color: "text-blue-600",
      bgColor: "bg-blue-100"
    },
    {
      title: "Completed Analyses",
      value: completedDocuments.toString(),
      icon: CheckCircle2,
      color: "text-green-600",
      bgColor: "bg-green-100"
    },
    {
      title: "Processing Now",
      value: processingDocuments.toString(),
      icon: Clock,
      color: "text-purple-600",
      bgColor: "bg-purple-100"
    },
    {
      title: "Average Score",
      value: `${averageCompliance}%`,
      icon: AlertCircle,
      color: "text-orange-600",
      bgColor: "bg-orange-100"
    }
  ];

  return (
    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
      {stats.map((stat, index) => (
        <Card key={index} className="p-6 border-none shadow-lg hover:shadow-xl transition-shadow duration-300">
          <div className="flex items-center gap-5">
            <div className={`w-14 h-14 rounded-xl flex items-center justify-center ${stat.bgColor}`}>
              <stat.icon className={`w-7 h-7 ${stat.color}`} />
            </div>
            <div>
              <p className="text-2xl font-bold text-slate-800">{stat.value}</p>
              <p className="text-sm font-medium text-slate-500">{stat.title}</p>
            </div>
          </div>
        </Card>
      ))}
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\MobileSidebar.jsx
'use client';

import { useState } from 'react';
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { Menu } from "lucide-react";
import Sidebar from './Sidebar';

export default function MobileSidebar({ user, profile }) {
  const [open, setOpen] = useState(false);

  return (
    <Sheet open={open} onOpenChange={setOpen}>
      <SheetTrigger asChild>
        <Button
          variant="ghost"
          size="icon"
          className="md:hidden fixed top-4 left-4 z-40 bg-white shadow-md border border-slate-200"
        >
          <Menu className="h-5 w-5" />
        </Button>
      </SheetTrigger>
      <SheetContent side="left" className="p-0 w-64">
        <Sidebar user={user} profile={profile} onNavigate={() => setOpen(false)} />
      </SheetContent>
    </Sheet>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\RecentDocuments.jsx
'use client';

import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { FileText, Trash2, Loader2, AlertTriangle, CheckCircle } from "lucide-react";
import { useRouter } from "next/navigation";

export function RecentDocuments({ documents, onDelete }) {
  const router = useRouter();

  const formatDate = (dateString) => {
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
  };

  const formatFileSize = (bytes) => {
    if (!bytes) return "0 B";
    if (bytes < 1024) return bytes + ' B';
    if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
    return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
  };

  const getStatusInfo = (status) => {
    const styles = {
      uploaded: { bg: 'bg-slate-100', text: 'text-slate-600', icon: <Loader2 className="w-4 h-4 animate-spin" /> },
      processing: { bg: 'bg-yellow-100', text: 'text-yellow-700', icon: <Loader2 className="w-4 h-4 animate-spin" /> },
      completed: { bg: 'bg-green-100', text: 'text-green-700', icon: <CheckCircle className="w-4 h-4" /> },
      failed: { bg: 'bg-red-100', text: 'text-red-700', icon: <AlertTriangle className="w-4 h-4" /> },
    };
    return styles[status] || styles.uploaded;
  };

  return (
    <Card className="shadow-lg border-none">
      <CardHeader>
        <CardTitle className="text-2xl font-bold text-slate-800">Recent Documents</CardTitle>
      </CardHeader>
      <CardContent>
        {documents.length === 0 ? (
          <div className="text-center py-12 text-slate-500">
            <FileText className="w-12 h-12 mx-auto mb-4 text-slate-400" />
            <h3 className="text-lg font-semibold">No Documents Yet</h3>
            <p>Upload your first document to see it here.</p>
          </div>
        ) : (
          <div className="space-y-3">
            {documents.map((doc) => {
              const statusInfo = getStatusInfo(doc.status);
              return (
                <div
                  key={doc.id}
                  className="grid grid-cols-6 items-center gap-4 p-4 rounded-xl hover:bg-slate-50 transition-colors duration-200 cursor-pointer"
                  onClick={() => router.push(`/document/${doc.id}`)}
                >
                  <div className="col-span-3 flex items-center gap-4">
                    <div className="w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center">
                      <FileText className="w-6 h-6 text-blue-600" />
                    </div>
                    <div className="min-w-0">
                      <p className="font-semibold text-slate-800 truncate">{doc.filename}</p>
                      <p className="text-sm text-slate-500">{formatDate(doc.created_at)}</p>
                    </div>
                  </div>

                  <div className="text-sm text-slate-500 text-center">{formatFileSize(doc.file_size)}</div>

                  <div className="flex justify-center">
                    <Badge className={`flex items-center gap-2 ${statusInfo.bg} ${statusInfo.text} font-semibold py-1 px-3 rounded-full`}>
                      {statusInfo.icon}
                      <span>{doc.status.charAt(0).toUpperCase() + doc.status.slice(1)}</span>
                    </Badge>
                  </div>

                  <div className="flex justify-end gap-2" onClick={(e) => e.stopPropagation()}>
                    <Button
                      variant="ghost"
                      size="icon"
                      className="w-9 h-9 text-slate-500 hover:text-red-600 hover:bg-red-100"
                      onClick={() => onDelete(doc.id, doc.file_path)}
                    >
                      <Trash2 className="w-5 h-5" />
                    </Button>
                  </div>
                </div>
              );
            })}
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\Sidebar.jsx
'use client';

import { Button } from "@/components/ui/button";
import {
  LayoutGrid,
  LogOut,
  FileCheck2,
  User,
  Settings
} from "lucide-react";
import { useRouter, usePathname } from "next/navigation";
import { createClient } from "@/lib/supabase/client";
import Link from "next/link";

const navItems = [
  { icon: LayoutGrid, label: "Dashboard", href: "/dashboard" },
  { icon: User, label: "Profile", href: "/profile" },
  { icon: Settings, label: "Settings", href: "/settings" },
];

export default function Sidebar({ user, profile, onNavigate }) {
  const router = useRouter();
  const pathname = usePathname();
  const supabase = createClient();

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    router.push('/');
    router.refresh();
  };

  const handleNavigation = (href) => {
    router.push(href);
    if (onNavigate) onNavigate();
  };

  return (
    <div className="w-64 h-screen bg-white border-r border-slate-200 flex flex-col shadow-sm hidden md:flex">
      {/* Logo */}
      <div className="p-6 border-b border-slate-200">
        <Link href="/" className="flex items-center space-x-3 group">
          <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-md group-hover:shadow-lg transition-shadow">
            <FileCheck2 className="h-5 w-5 text-white" />
          </div>
          <span className="text-2xl font-bold text-slate-800">
            APA Pro
          </span>
        </Link>
      </div>

      {/* Navigation */}
      <nav className="flex-1 p-4">
        <div className="space-y-2">
          {navItems.map((item, index) => {
            const isActive = pathname === item.href || pathname.startsWith(item.href + '/');
            return (
              <Button
                key={index}
                variant={isActive ? "secondary" : "ghost"}
                className={`w-full justify-start gap-3 h-12 text-md font-semibold ${isActive ? 'text-blue-600 bg-blue-100' : 'text-slate-600 hover:bg-slate-100 hover:text-slate-800'}`}
                onClick={() => handleNavigation(item.href)}
              >
                <item.icon className="w-6 h-6" />
                {item.label}
              </Button>
            );
          })}
        </div>
      </nav>

      {/* Sign Out */}
      <div className="p-4 border-t border-slate-200">
        <Button
          variant="ghost"
          className="w-full justify-start gap-3 h-12 text-md font-semibold text-red-600 hover:text-red-700 hover:bg-red-50"
          onClick={handleSignOut}
        >
          <LogOut className="w-5 h-5" />
          Sign Out
        </Button>
      </div>
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\dashboard\UploadSection.jsx
'use client';

import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { UploadCloud, FilePlus2, Loader2 } from "lucide-react";
import { useRef } from "react";
import { useDropzone } from 'react-dropzone';

export function UploadSection({ onFileUpload, uploading, uploadingFileName }) {
  const fileInputRef = useRef(null);

  const onDrop = (acceptedFiles) => {
    if (onFileUpload && acceptedFiles.length > 0) {
      onFileUpload(acceptedFiles[0]);
    }
  };

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
    },
    multiple: false,
    disabled: uploading,
  });

  return (
    <Card 
      {...getRootProps()} 
      className={`border-2 border-dashed transition-colors duration-300 h-full flex items-center justify-center ${isDragActive ? 'border-blue-500 bg-blue-50' : 'border-slate-300 hover:border-blue-400'}`}>
      <input {...getInputProps()} ref={fileInputRef} />
      <CardContent className="p-8 text-center">
        {uploading ? (
          <div className="flex flex-col items-center justify-center space-y-4">
            <div className="w-20 h-20 rounded-full bg-blue-100 flex items-center justify-center">
              <Loader2 className="w-10 h-10 text-blue-600 animate-spin" />
            </div>
            <div>
              <h3 className="text-xl font-bold text-slate-800 mb-2">
                Uploading Document...
              </h3>
              <p className="text-slate-500 mb-2">
                {uploadingFileName || 'Processing your file'}
              </p>
              <p className="text-sm text-slate-400">
                Please wait while we upload and prepare your document for analysis
              </p>
            </div>
            <div className="w-full max-w-xs bg-slate-200 rounded-full h-2 overflow-hidden">
              <div className="h-full bg-gradient-to-r from-blue-600 to-indigo-600 rounded-full animate-pulse" style={{ width: '66%' }}></div>
            </div>
          </div>
        ) : (
          <div className="flex flex-col items-center justify-center space-y-4">
            <div className={`w-20 h-20 rounded-full flex items-center justify-center transition-colors duration-300 ${isDragActive ? 'bg-blue-100' : 'bg-slate-100'}`}>
              <UploadCloud className={`w-10 h-10 transition-colors duration-300 ${isDragActive ? 'text-blue-600' : 'text-slate-500'}`} />
            </div>
            <div>
              <h3 className="text-xl font-bold text-slate-800 mb-2">
                {isDragActive ? "Drop it here!" : "Upload New Document"}
              </h3>
              <p className="text-slate-500 mb-4">
                Drag & drop or click to select a DOCX file.
              </p>
            </div>
            <Button
              type="button"
              className="gap-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold"
              onClick={() => fileInputRef.current?.click()}
              disabled={uploading}
            >
              <FilePlus2 className="w-5 h-5" />
              Choose File
            </Button>
          </div>
        )}
      </CardContent>
    </Card>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\DisclaimerModal.js
"use client";

import { useState, useEffect } from "react";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { AlertCircle } from "lucide-react";

const DISCLAIMER_STORAGE_KEY = "apa-pro-disclaimer-shown";

export default function DisclaimerModal() {
  const [isOpen, setIsOpen] = useState(false);
  const [countdown, setCountdown] = useState(5);

  useEffect(() => {
    // Check if disclaimer has been shown before
    const hasSeenDisclaimer = localStorage.getItem(DISCLAIMER_STORAGE_KEY);

    if (!hasSeenDisclaimer) {
      // Show modal for first-time visitors
      setIsOpen(true);

      // Countdown timer
      const timer = setInterval(() => {
        setCountdown((prev) => {
          if (prev <= 1) {
            clearInterval(timer);
            return 0;
          }
          return prev - 1;
        });
      }, 1000);

      return () => clearInterval(timer);
    }
  }, []);

  const handleClose = () => {
    // Mark disclaimer as shown in localStorage
    localStorage.setItem(DISCLAIMER_STORAGE_KEY, "true");
    setIsOpen(false);
  };

  return (
    <Dialog
      open={isOpen}
      onOpenChange={(open) => {
        // Only allow closing if countdown is finished
        if (!open && countdown === 0) {
          handleClose();
        }
      }}
    >
      <DialogContent
        className="sm:max-w-[600px]"
        hideCloseButton={countdown > 0}
      >
        <DialogHeader>
          <div className="flex items-center gap-3 mb-2">
            <div className="w-12 h-12 rounded-full bg-blue-100 flex items-center justify-center">
              <AlertCircle className="h-6 w-6 text-blue-600" />
            </div>
            <DialogTitle className="text-2xl">Welcome to APA Pro!</DialogTitle>
          </div>
        </DialogHeader>

        <div className="space-y-5 pt-2">
          <div className="text-slate-700 leading-relaxed text-base">
            Thank you for visiting! Before you continue:
          </div>

          <div className="bg-blue-50 border border-blue-200 rounded-lg p-5 space-y-3">
            <div className="text-slate-700 font-semibold text-base">
              🚧 This website is currently in active development and testing
            </div>
            <div className="text-slate-600 text-sm leading-relaxed">
              Ensuring accuracy and a smooth experience is our priority, but you may
              encounter bugs or features under construction. Your patience is appreciated!
            </div>

            <div className="pt-2 border-t border-blue-200">
              <div className="text-slate-700 font-semibold text-base mb-1">
                ✨ Get started today
              </div>
              <div className="text-slate-600 text-sm leading-relaxed">
                Create a free account to access our APA 7th edition document
                checker and editor.
              </div>
            </div>
          </div>

          <div className="text-xs text-slate-500 leading-relaxed">
            We only show this once using your browser&apos;s memory—no tracking, no data collection.
          </div>
        </div>

        <div className="flex justify-end pt-4">
          {countdown > 0 ? (
            <div className="flex items-center gap-2 text-sm text-slate-500">
              <div className="w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full animate-spin"></div>
              <span>You can continue in {countdown} second{countdown !== 1 ? 's' : ''}...</span>
            </div>
          ) : (
            <Button onClick={handleClose}>
              Got it!
            </Button>
          )}
        </div>
      </DialogContent>
    </Dialog>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\DocumentControls.js
'use client';

import { memo, useState } from 'react';
import {
  CheckCircle2,
  Eye,
  EyeOff,
  AlertCircle,
  Download,
  FileText,
  File
} from 'lucide-react';
import { useUnifiedDocumentStore } from '@/store/unifiedDocumentStore';

const DocumentControls = memo(({
  lastFixAppliedAt,
  documentText,
  documentFormatting,
  handleManualAnalysis,
  isLoading,
  processingState,
  showIssueHighlighting,
  toggleIssueHighlighting,
  issues,
  editor,
  tiptapConverter
}) => {
  const { documentModel, exportDocument } = useUnifiedDocumentStore();
  const [isExporting, setIsExporting] = useState(false);

  const handleExport = async (format) => {
    if (!documentModel) {
      alert('No document loaded');
      return;
    }

    setIsExporting(true);
    try {
      const result = await exportDocument(format);

      if (result.success) {
        // Create blob and download
        const blob = format === 'html' || format === 'text'
          ? new Blob([result.content], { type: format === 'html' ? 'text/html' : 'text/plain' })
          : new Blob([result.content], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });

        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = result.filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log(`✅ Exported as ${format}${result.method ? ` (${result.method})` : ''}`);
      }
    } catch (error) {
      console.error('Export failed:', error);
      alert(`Export failed: ${error.message}`);
    } finally {
      setIsExporting(false);
    }
  };

  return (
    <div className="bg-white border-b border-slate-200 flex-shrink-0">
      <div className="px-6 py-4 border-b border-slate-100">
        <div className="flex justify-between items-center">
          <div className="flex items-center space-x-4">
            <h3 className="text-lg font-semibold text-slate-900">Document Editor</h3>
            {lastFixAppliedAt && (
              <span className="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-emerald-100 text-emerald-800">
                <div className="w-1.5 h-1.5 bg-emerald-400 rounded-full mr-1.5"></div>
                Recently Updated
              </span>
            )}
          </div>
          <div className="flex items-center space-x-3">

            {/* Export Buttons */}
            {documentModel && (
              <>
                <button
                  onClick={() => handleExport('docx')}
                  disabled={isExporting}
                  className="flex items-center space-x-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 bg-blue-600 text-white hover:bg-blue-700 shadow-lg shadow-blue-600/25 disabled:bg-slate-300 disabled:cursor-not-allowed"
                >
                  <Download className="h-4 w-4" />
                  <span>{isExporting ? 'Exporting...' : 'Export DOCX'}</span>
                </button>

                <button
                  onClick={() => handleExport('html')}
                  disabled={isExporting}
                  className="flex items-center space-x-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 bg-slate-100 text-slate-700 hover:bg-slate-200 shadow-sm disabled:bg-slate-100 disabled:cursor-not-allowed"
                >
                  <FileText className="h-4 w-4" />
                  <span>HTML</span>
                </button>
              </>
            )}

            {/* Run Check Button */}
            <button
              onClick={handleManualAnalysis}
              disabled={isLoading || processingState.isAnalyzing}
              title="Run APA analysis on current document (Ctrl+Shift+C)"
              className={`flex items-center space-x-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 ${
                isLoading || processingState.isAnalyzing
                  ? 'bg-slate-100 text-slate-400 cursor-not-allowed'
                  : 'bg-emerald-600 text-white hover:bg-emerald-700 shadow-lg shadow-emerald-600/25'
              }`}
            >
              {processingState.isAnalyzing ? (
                <>
                  <div className="loading-spinner w-4 h-4"></div>
                  <span>Checking...</span>
                </>
              ) : (
                <>
                  <CheckCircle2 className="h-4 w-4" />
                  <span>Run Check</span>
                </>
              )}
            </button>

            {/* Toggle Highlighting */}
            <button
              onClick={() => toggleIssueHighlighting()}
              className={`flex items-center space-x-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 ${
                showIssueHighlighting
                  ? 'bg-amber-100 text-amber-700 hover:bg-amber-200 shadow-sm'
                  : 'bg-slate-100 text-slate-600 hover:bg-slate-200 shadow-sm'
              }`}
            >
              {showIssueHighlighting ? (
                <>
                  <EyeOff className="h-4 w-4" />
                  <span>Hide Issues</span>
                </>
              ) : (
                <>
                  <Eye className="h-4 w-4" />
                  <span>Show Issues</span>
                </>
              )}
            </button>

            {/* Issue Count */}
            {issues.length > 0 && (
              <div className="flex items-center space-x-2 px-3 py-1.5 bg-slate-50 rounded-xl border border-slate-200 shadow-sm">
                <AlertCircle className="h-4 w-4 text-slate-500" />
                <span className="text-sm text-slate-600">
                  {issues.length} {issues.length === 1 ? 'issue' : 'issues'}
                </span>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
});

DocumentControls.displayName = 'DocumentControls';

export default DocumentControls;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\DocumentIssuesBanner.js
'use client';

import { memo, useMemo } from 'react';
import { AlertCircle } from 'lucide-react';

const DocumentIssuesBanner = memo(({ issues, showIssueHighlighting, setActiveIssue }) => {
  const documentLevelIssues = useMemo(() => {
    return issues.filter(issue =>
      issue.location?.type === 'document' &&
      ['formatting'].includes(issue.category)
    );
  }, [issues]);

  if (documentLevelIssues.length === 0 || !showIssueHighlighting) {
    return null;
  }

  return (
    <div className="bg-amber-50 border-b border-amber-200 px-6 py-4">
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <div className="w-10 h-10 bg-amber-500 rounded-xl flex items-center justify-center shadow-lg shadow-amber-500/25">
            <AlertCircle className="h-5 w-5 text-white" />
          </div>
          <div>
            <p className="text-sm font-semibold text-amber-900 mb-1">
              Document-wide formatting issues detected
            </p>
            <div className="flex flex-wrap gap-2">
              {documentLevelIssues.map(issue => (
                <span
                  key={issue.id}
                  className="inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-800 cursor-pointer hover:bg-amber-200 transition-colors duration-200"
                  onClick={() => setActiveIssue(issue.id)}
                >
                  {issue.title}
                </span>
              ))}
            </div>
          </div>
        </div>
        <button
          onClick={() => {
            const firstIssue = documentLevelIssues[0];
            if (firstIssue) setActiveIssue(firstIssue.id);
          }}
          className="text-sm text-amber-700 hover:text-amber-900 font-semibold hover:underline transition-all duration-200"
        >
          View in Issues Panel →
        </button>
      </div>
    </div>
  );
});

DocumentIssuesBanner.displayName = 'DocumentIssuesBanner';

export default DocumentIssuesBanner;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\EditorContent.js
'use client';

import { memo } from 'react';
import { EditorContent as TiptapEditorContent } from '@tiptap/react';
import { AlertCircle } from 'lucide-react';
import ErrorBoundary from './ErrorBoundary';

const EditorContent = memo(({
  editor,
  editorInitialized,
  editorError,
  setEditorError,
  setEditorInitialized,
  documentText
}) => {
  if (editorError) {
    return (
      <div className="p-8 min-h-[500px] bg-red-50 border border-red-200 rounded-lg">
        <div className="text-center">
          <AlertCircle className="h-12 w-12 text-red-500 mx-auto mb-4" />
          <h3 className="text-lg font-semibold text-red-700 mb-2">Editor Error</h3>
          <p className="text-sm text-red-600 mb-4">
            The document editor encountered an error and could not load properly.
          </p>
          <p className="text-xs text-red-500 mb-4 font-mono">
            {editorError.message}
          </p>
          <div className="space-y-3">
            <button
              onClick={() => {
                setEditorError(null);
                setEditorInitialized(false);
                window.location.reload();
              }}
              className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
            >
              Reload Editor
            </button>
            {documentText && (
              <div className="mt-4 p-4 bg-white rounded border text-left max-h-60 overflow-auto">
                <h4 className="font-medium text-gray-700 mb-2">Document Text Preview:</h4>
                <pre className="text-xs text-gray-600 whitespace-pre-wrap">
                  {documentText.substring(0, 1000)}
                  {documentText.length > 1000 && '...'}
                </pre>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  }

  if (editor && editorInitialized) {
    return (
      <ErrorBoundary showDetails={process.env.NODE_ENV === 'development'}>
        <>
          <TiptapEditorContent editor={editor} />
          {/* Debug info - only in development */}
          {process.env.NODE_ENV === 'development' && (
            <div className="p-4 bg-gray-100 border-t text-xs text-gray-600">
              <div>Editor ready: {editor.isEditable ? 'Yes' : 'No'}</div>
              <div>Document text length: {documentText?.length || 0}</div>
              <div>Editor HTML length: {editor.getHTML()?.length || 0}</div>
              <div>First 100 chars: {documentText?.substring(0, 100)}</div>
            </div>
          )}
        </>
      </ErrorBoundary>
    );
  }

  return (
    <div className="p-8 min-h-[500px]">
      <div className="text-center">
        <div className="loading-spinner mb-4"></div>
        <p className="text-gray-600">Initializing editor...</p>
        {documentText && process.env.NODE_ENV === 'development' && (
          <div className="mt-4 p-4 bg-yellow-50 rounded text-left">
            <p className="text-sm font-semibold text-yellow-800 mb-2">Document loaded but editor not ready</p>
            <p className="text-xs text-gray-700">Document preview: {documentText.substring(0, 200)}...</p>
          </div>
        )}
      </div>
    </div>
  );
});

EditorContent.displayName = 'EditorContent';

export default EditorContent;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\EditorErrorBoundary.js
'use client';

import React from 'react';
import { AlertTriangle, RefreshCw, FileText } from 'lucide-react';

class EditorErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: 0
    };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    this.setState({
      error: error,
      errorInfo: errorInfo
    });

    // Log error only in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Editor Error Boundary caught an error:', error, errorInfo);
    }
  }

  handleRetry = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      retryCount: this.state.retryCount + 1
    });
  };

  handleReload = () => {
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      return (
        <div className="p-8 min-h-[400px] bg-red-50 border-2 border-red-200 rounded-lg flex items-center justify-center">
          <div className="text-center max-w-md">
            <div className="w-16 h-16 bg-red-500 rounded-full mx-auto mb-4 flex items-center justify-center">
              <AlertTriangle className="h-8 w-8 text-white" />
            </div>

            <h3 className="text-xl font-semibold text-red-800 mb-3">
              Editor Encountered an Error
            </h3>

            <p className="text-red-700 mb-6 text-sm leading-relaxed">
              The document editor has encountered an unexpected error and cannot display properly.
              This might be due to corrupted document data or a temporary issue.
            </p>

            <div className="space-y-3">
              <button
                onClick={this.handleRetry}
                className="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors font-medium flex items-center justify-center space-x-2"
                disabled={this.state.retryCount >= 3}
              >
                <RefreshCw className="h-4 w-4" />
                <span>
                  {this.state.retryCount >= 3 ? 'Max retries reached' : `Retry ${this.state.retryCount > 0 ? `(${this.state.retryCount}/3)` : ''}`}
                </span>
              </button>

              <button
                onClick={this.handleReload}
                className="w-full px-4 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors font-medium flex items-center justify-center space-x-2"
              >
                <FileText className="h-4 w-4" />
                <span>Reload Page</span>
              </button>
            </div>

            {process.env.NODE_ENV === 'development' && this.state.error && (
              <details className="mt-6 text-left">
                <summary className="text-xs text-red-600 cursor-pointer font-medium mb-2">
                  Error Details (Development)
                </summary>
                <div className="bg-red-100 border border-red-300 rounded p-3 text-xs text-red-800 font-mono overflow-auto max-h-32">
                  <div className="mb-2 font-bold">Error: {this.state.error.toString()}</div>
                  <div className="whitespace-pre-wrap">{this.state.errorInfo.componentStack}</div>
                </div>
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default EditorErrorBoundary;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\EditorHeader.js
"use client";
import Link from "next/link";
import { FileCheck, Home } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function EditorHeader() {
  return (
    <header className="sticky top-0 bg-white border-b border-slate-200 z-50">
      <div className="px-4 sm:px-6 lg:px-8">
        <div className="h-16 flex items-center justify-between">
          {/* Logo */}
          <Link href="/" className="flex items-center space-x-3 group">
            <div className="w-9 h-9 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-sm group-hover:shadow-md transition-shadow">
              <FileCheck className="h-4 w-4 text-white" />
            </div>
            <span className="text-xl font-bold text-slate-800">
              APA Pro
            </span>
          </Link>

          {/* Right Actions */}
          <div className="flex items-center gap-4">
            <Link href="/dashboard">
              <Button variant="ghost" size="sm" className="gap-2">
                <Home className="h-4 w-4" />
                Dashboard
              </Button>
            </Link>
            <Link href="/login">
              <Button variant="outline" size="sm">
                Sign In
              </Button>
            </Link>
          </div>
        </div>
      </div>
    </header>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\EmptyDocumentState.js
'use client';

import { memo } from 'react';
import {
  FileText,
  CheckCircle2,
  FileSearch,
  Sparkles
} from 'lucide-react';

const EmptyDocumentState = memo(() => {
  const handleDragOver = (e) => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e) => {
    e.preventDefault();
    e.stopPropagation();

    const files = Array.from(e.dataTransfer.files);
    const docxFile = files.find(file => file.name.endsWith('.docx'));

    if (docxFile) {
      // Create a file input event to trigger upload
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.docx';

      // Create a FileList-like object
      Object.defineProperty(input, 'files', {
        value: files,
        writable: false,
      });

      // Trigger the upload
      input.dispatchEvent(new Event('change', { bubbles: true }));
    }
  };

  return (
    <div className="h-full flex flex-col bg-white">
      {/* Hero Section */}
      <div className="flex-1 flex flex-col items-center justify-center p-8">
        <div className="text-center max-w-2xl">
          {/* Main Visual */}
          <div className="relative inline-block mb-8">
            <div className="w-24 h-24 bg-gradient-to-br from-emerald-500 to-teal-600 rounded-2xl mx-auto flex items-center justify-center shadow-2xl">
              <FileText className="h-12 w-12 text-white" />
            </div>
            <div className="absolute -bottom-1 -right-1 w-8 h-8 bg-amber-500 rounded-xl flex items-center justify-center border-4 border-white shadow-lg">
              <Sparkles className="h-4 w-4 text-white" />
            </div>
          </div>

          <h1 className="text-4xl font-bold text-slate-900 mb-4">
            Perfect Your APA Document
          </h1>
          <p className="text-xl text-slate-600 mb-12 leading-relaxed">
            Get instant feedback on APA 7th edition compliance as you write and edit
          </p>

          {/* Upload Area */}
          <div
            className="bg-slate-50 border-2 border-dashed border-slate-300 rounded-2xl p-12 hover:border-emerald-300 hover:bg-emerald-50/50 transition-all duration-300 cursor-pointer group card-hover focus-ring-smooth"
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            onClick={() => document.querySelector('input[type="file"]')?.click()}
            tabIndex="0"
          >
            <div className="text-center">
              <div className="w-16 h-16 bg-white rounded-xl mx-auto mb-4 flex items-center justify-center group-hover:scale-110 transition-transform duration-300 shadow-lg">
                <FileText className="h-8 w-8 text-emerald-500" />
              </div>
              <h3 className="text-lg font-semibold text-slate-900 mb-2">
                Drop your DOCX file here
              </h3>
              <p className="text-slate-600 mb-4">
                Or click to browse and select your document
              </p>
              <button className="inline-flex items-center space-x-2 px-6 py-3 bg-gradient-to-r from-emerald-500 to-teal-600 text-white font-semibold rounded-xl hover:from-emerald-600 hover:to-teal-700 transition-all duration-200 shadow-lg shadow-emerald-500/25 button-lift button-press focus-ring-smooth">
                <span>Choose File</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Features Section */}
      <div className="border-t border-slate-200 bg-slate-50 px-8 py-8">
        <div className="max-w-4xl mx-auto">
          <h3 className="text-lg font-semibold text-slate-900 mb-6 text-center">
            Powered by Advanced APA Analysis
          </h3>
          <div className="grid md:grid-cols-3 gap-6">
            <div className="text-center">
              <div className="w-12 h-12 bg-emerald-500 rounded-xl mx-auto mb-3 flex items-center justify-center card-hover">
                <CheckCircle2 className="h-6 w-6 text-white" />
              </div>
              <h4 className="font-semibold text-slate-900 mb-1">Real-time Feedback</h4>
              <p className="text-sm text-slate-600">Instant validation as you type and edit</p>
            </div>
            <div className="text-center">
              <div className="w-12 h-12 bg-slate-500 rounded-xl mx-auto mb-3 flex items-center justify-center card-hover">
                <FileSearch className="h-6 w-6 text-white" />
              </div>
              <h4 className="font-semibold text-slate-900 mb-1">Comprehensive Analysis</h4>
              <p className="text-sm text-slate-600">Citations, references, formatting & more</p>
            </div>
            <div className="text-center">
              <div className="w-12 h-12 bg-amber-500 rounded-xl mx-auto mb-3 flex items-center justify-center card-hover">
                <Sparkles className="h-6 w-6 text-white" />
              </div>
              <h4 className="font-semibold text-slate-900 mb-1">Smart Corrections</h4>
              <p className="text-sm text-slate-600">One-click fixes for common issues</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
});

EmptyDocumentState.displayName = 'EmptyDocumentState';

export default EmptyDocumentState;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ErrorBoundary.js
'use client';

import { Component } from 'react';
import { AlertTriangle } from 'lucide-react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // You can log the error to an error reporting service
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
    this.setState({
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <div className="flex flex-col items-center justify-center p-6 bg-red-50 border border-red-200 rounded-lg shadow-sm text-center">
          <div className="bg-red-100 p-3 rounded-full mb-4">
            <AlertTriangle className="h-8 w-8 text-red-500" />
          </div>
          <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-sm text-red-600 mb-4">
            {this.state.error ? this.state.error.toString() : 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
          >
            Reload Page
          </button>
          {this.props.showDetails && this.state.errorInfo && (
            <div className="mt-6 w-full">
              <details className="text-left">
                <summary className="text-sm font-medium text-red-800 cursor-pointer">Error Details</summary>
                <pre className="mt-2 p-3 text-xs text-red-800 bg-red-100 overflow-auto rounded-md">
                  {this.state.errorInfo.componentStack}
                </pre>
              </details>
            </div>
          )}
        </div>
      );
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\Footer.js
import Link from "next/link";
import { FileCheck, Github, Twitter, Linkedin, Mail } from "lucide-react";

export default function Footer() {
  return (
    <footer className="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 text-white border-t border-slate-700/50">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
        <div className="grid grid-cols-1 md:grid-cols-4 gap-12 mb-12">
          {/* Brand Column */}
          <div className="md:col-span-2">
            <div className="flex items-center space-x-3 mb-4">
              <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-lg">
                <FileCheck className="h-5 w-5 text-white" />
              </div>
              <span className="text-2xl font-bold">APA Pro</span>
            </div>
            <p className="text-slate-400 leading-relaxed max-w-md mb-6">
              Professional APA 7th edition document analysis and compliance checking.
              Elevate your academic writing with intelligent formatting insights.
            </p>
            <div className="flex space-x-4">
              <a href="#" className="w-10 h-10 rounded-lg bg-slate-800 hover:bg-slate-700 flex items-center justify-center transition-colors group">
                <Twitter className="h-4 w-4 text-slate-400 group-hover:text-blue-400 transition-colors" />
              </a>
              <a href="#" className="w-10 h-10 rounded-lg bg-slate-800 hover:bg-slate-700 flex items-center justify-center transition-colors group">
                <Github className="h-4 w-4 text-slate-400 group-hover:text-white transition-colors" />
              </a>
              <a href="#" className="w-10 h-10 rounded-lg bg-slate-800 hover:bg-slate-700 flex items-center justify-center transition-colors group">
                <Linkedin className="h-4 w-4 text-slate-400 group-hover:text-blue-500 transition-colors" />
              </a>
            </div>
          </div>

          {/* Product Column */}
          <div>
            <h3 className="font-bold text-white mb-4 text-sm uppercase tracking-wider">Product</h3>
            <ul className="space-y-3">
              <li>
                <Link href="/#features" className="text-slate-400 hover:text-white transition-colors text-sm">
                  Features
                </Link>
              </li>
              <li>
                <Link href="/#how-it-works" className="text-slate-400 hover:text-white transition-colors text-sm">
                  How it Works
                </Link>
              </li>
              <li>
                <Link href="/signup" className="text-slate-400 hover:text-white transition-colors text-sm">
                  Editor
                </Link>
              </li>
              <li>
                <Link href="/dashboard" className="text-slate-400 hover:text-white transition-colors text-sm">
                  Dashboard
                </Link>
              </li>
            </ul>
          </div>

          {/* Company Column */}
          <div>
            <h3 className="font-bold text-white mb-4 text-sm uppercase tracking-wider">Company</h3>
            <ul className="space-y-3">
              <li>
                <Link href="#" className="text-slate-400 hover:text-white transition-colors text-sm">
                  About Us
                </Link>
              </li>
              <li>
                <Link href="#" className="text-slate-400 hover:text-white transition-colors text-sm flex items-center gap-2">
                  <Mail className="h-3 w-3" />
                  Contact
                </Link>
              </li>
              <li>
                <Link href="#" className="text-slate-400 hover:text-white transition-colors text-sm">
                  Privacy Policy
                </Link>
              </li>
              <li>
                <Link href="#" className="text-slate-400 hover:text-white transition-colors text-sm">
                  Terms of Service
                </Link>
              </li>
            </ul>
          </div>
        </div>

        {/* Bottom Bar */}
        <div className="pt-8 border-t border-slate-700/50">
          <div className="flex flex-col md:flex-row justify-between items-center gap-4">
            <p className="text-slate-500 text-sm">
              &copy; {new Date().getFullYear()} APA Pro. All rights reserved.
            </p>
            <div className="flex items-center gap-6 text-xs text-slate-500">
              <span>Built with precision for academic excellence</span>
            </div>
          </div>
        </div>
      </div>
    </footer>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\FormattingToolbar.js
'use client';

import { memo } from 'react';
import {
  Bold,
  Italic,
  Underline as UnderlineIcon,
  Undo,
  Redo
} from 'lucide-react';

const FormattingToolbar = memo(({ editor }) => {
  return (
    <div className="px-6 py-3 flex items-center space-x-1 bg-slate-50 border-b border-slate-200">
      <div className="flex items-center space-x-1 pr-3 border-r border-slate-300">
        <button
          className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg transition-colors duration-200"
          title="Undo"
          onClick={() => editor?.chain().focus().undo().run()}
          disabled={!editor?.can().undo()}
        >
          <Undo className="h-4 w-4" />
        </button>
        <button
          className="p-2 text-slate-600 hover:bg-slate-100 rounded-lg transition-colors duration-200"
          title="Redo"
          onClick={() => editor?.chain().focus().redo().run()}
          disabled={!editor?.can().redo()}
        >
          <Redo className="h-4 w-4" />
        </button>
      </div>

      <div className="flex items-center space-x-1 px-3">
        <button
          className={`p-2 rounded-lg transition-colors duration-200 ${
            editor?.isActive('bold') ? 'bg-emerald-100 text-emerald-700' : 'text-slate-600 hover:bg-slate-100'
          }`}
          title="Bold"
          onClick={() => editor?.chain().focus().toggleBold().run()}
        >
          <Bold className="h-4 w-4" />
        </button>
        <button
          className={`p-2 rounded-lg transition-colors duration-200 ${
            editor?.isActive('italic') ? 'bg-emerald-100 text-emerald-700' : 'text-slate-600 hover:bg-slate-100'
          }`}
          title="Italic"
          onClick={() => editor?.chain().focus().toggleItalic().run()}
        >
          <Italic className="h-4 w-4" />
        </button>
        <button
          className={`p-2 rounded-lg transition-colors duration-200 ${
            editor?.isActive('underline') ? 'bg-emerald-100 text-emerald-700' : 'text-slate-600 hover:bg-slate-100'
          }`}
          title="Underline"
          onClick={() => editor?.chain().focus().toggleUnderline().run()}
        >
          <UnderlineIcon className="h-4 w-4" />
        </button>
      </div>
    </div>
  );
});

FormattingToolbar.displayName = 'FormattingToolbar';

export default FormattingToolbar;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\Header.js
"use client";
import Link from "next/link";
import { useState } from "react";
import { FileCheck, Menu, X, ArrowRight } from "lucide-react";
import { motion } from "framer-motion";

export default function Header() {
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  return (
    <header className="sticky top-0 bg-white/80 backdrop-blur-lg z-50 border-b border-slate-200">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="h-20 flex items-center justify-between">
          {/* Logo */}
          <Link href="/" className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-xl flex items-center justify-center shadow-md">
              <FileCheck className="h-5 w-5 text-white" />
            </div>
            <span className="text-2xl font-bold text-slate-800">
              APA Pro
            </span>
          </Link>

          {/* Desktop Navigation */}
          <nav className="hidden md:flex items-center space-x-10">
            <Link
              href="/#features"
              className="text-slate-600 hover:text-blue-600 transition-colors font-medium"
            >
              Features
            </Link>
            <Link
              href="/#how-it-works"
              className="text-slate-600 hover:text-blue-600 transition-colors font-medium"
            >
              Process
            </Link>
            <Link
              href="/dashboard"
              className="text-slate-600 hover:text-blue-600 transition-colors font-medium"
            >
              Dashboard
            </Link>
          </nav>

          {/* Auth Buttons */}
          <div className="hidden md:flex items-center space-x-4">
            <Link
              href="/login"
              className="text-slate-600 hover:text-blue-600 font-semibold transition-colors"
            >
              Sign In
            </Link>
            <Link
              href="/signup"
              className="inline-flex items-center space-x-2 px-5 py-2.5 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors shadow-sm"
            >
              <span>Get Started</span>
              <ArrowRight className="h-4 w-4" />
            </Link>
          </div>

          {/* Mobile Menu Button */}
          <div className="md:hidden">
            <button onClick={() => setIsMenuOpen(!isMenuOpen)}>
              {isMenuOpen ? (
                <X className="h-6 w-6 text-slate-800" />
              ) : (
                <Menu className="h-6 w-6 text-slate-800" />
              )}
            </button>
          </div>
        </div>
      </div>

      {/* Mobile Menu */}
      {isMenuOpen && (
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          className="md:hidden bg-white border-t border-slate-200"
        >
          <div className="px-2 pt-2 pb-3 space-y-1 sm:px-3">
            <Link
              href="/#features"
              className="block px-3 py-2 rounded-md text-base font-medium text-slate-700 hover:text-blue-600 hover:bg-slate-100"
              onClick={() => setIsMenuOpen(false)}
            >
              Features
            </Link>
            <Link
              href="/#how-it-works"
              className="block px-3 py-2 rounded-md text-base font-medium text-slate-700 hover:text-blue-600 hover:bg-slate-100"
              onClick={() => setIsMenuOpen(false)}
            >
              Process
            </Link>
            <Link
              href="/dashboard"
              className="block px-3 py-2 rounded-md text-base font-medium text-slate-700 hover:text-blue-600 hover:bg-slate-100"
              onClick={() => setIsMenuOpen(false)}
            >
              Dashboard
            </Link>
          </div>
          <div className="pt-4 pb-3 border-t border-slate-200">
            <div className="px-5 flex flex-col space-y-3">
              <Link
                href="/login"
                className="text-center text-slate-600 bg-slate-100 hover:bg-slate-200 w-full font-semibold transition-colors py-2 rounded-lg"
              >
                Sign In
              </Link>
              <Link
                href="/signup"
                className="inline-flex items-center justify-center space-x-2 px-5 py-2.5 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition-colors shadow-sm"
              >
                <span>Get Started</span>
                <ArrowRight className="h-4 w-4" />
              </Link>
            </div>
          </div>
        </motion.div>
      )}
    </header>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\IssuesPanel.js
'use client';

import { useState, useMemo, useCallback, useEffect, useRef } from 'react';
import { useUnifiedDocumentStore } from '@/store/unifiedDocumentStore';
import React from 'react';
import {
  ClipboardList,
  AlertTriangle,
  AlertCircle,
  AlertOctagon,
  Check,
  ChevronDown,
  FileText,
  Info,
  Zap,
  BarChart3,
  Activity,
  Target,
  BookOpen,
  FileSearch,
  Clock,
  Sparkles,
  FileDown
} from 'lucide-react';

export default function IssuesPanel() {
  const {
    getIssues,
    uiState,
    setActiveIssue,
    applyFix,
    processingState,
    getDocumentStats,
    getComplianceScore,
    documentFormatting
  } = useUnifiedDocumentStore();

  const issues = getIssues();
  const activeIssueId = uiState?.activeIssueId;
  const documentStats = getDocumentStats();
  const analysisScore = getComplianceScore();
  
  const [expandedCategories, setExpandedCategories] = useState({
    Critical: true,
    Major: true,
    Minor: false
  });
  
  const [activeTab, setActiveTab] = useState('issues'); // 'issues' or 'stats'
  const [fixError, setFixError] = useState(null);

  // Refs for tracking issue elements
  const issueRefs = useRef({});
  const panelContentRef = useRef(null);

  // Wrapper for applyFix to handle errors
  const handleApplyFix = async (issueId) => {
    setFixError(null);
    const result = await applyFix(issueId);
    if (!result.success) {
      setFixError(result.error || 'Fix failed');
      setTimeout(() => setFixError(null), 5000); // Clear after 5 seconds
    }
  };
  
  // Group issues by severity and separate document formatting issues
  const { groupedIssues, documentFormattingIssues } = useMemo(() => {
    const grouped = {};
    const docFormatting = [];

    (issues || []).forEach(issue => {
      // Check if it's a document-wide formatting issue
      if (issue.location?.type === 'document' && issue.category === 'formatting') {
        docFormatting.push(issue);
      }

      // Group ALL issues by severity (including document formatting)
      if (!grouped[issue.severity]) {
        grouped[issue.severity] = [];
      }
      grouped[issue.severity].push(issue);
    });

    return { groupedIssues: grouped, documentFormattingIssues: docFormatting };
  }, [issues]);
  
  // Count issues by severity
  const issueCounts = useMemo(() => ({
    Critical: groupedIssues.Critical?.length || 0,
    Major: groupedIssues.Major?.length || 0,
    Minor: groupedIssues.Minor?.length || 0
  }), [groupedIssues]);
  
  const totalIssues = issueCounts.Critical + issueCounts.Major + issueCounts.Minor;
  
  // Toggle category expansion
  const toggleCategory = useCallback((category) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  }, []);
  
  // Auto-scroll and auto-expand when activeIssueId changes
  useEffect(() => {
    if (!activeIssueId || !issues || issues.length === 0) return;
    
    // Find the issue and its severity
    const activeIssue = issues.find(issue => issue.id === activeIssueId);
    if (!activeIssue) return;
    
    const severity = activeIssue.severity;
    
    // Auto-expand the category if it's collapsed
    setExpandedCategories(prev => {
      if (!prev[severity]) {
        if (process.env.NODE_ENV === 'development') {
          console.log(`📂 Auto-expanding ${severity} category for issue: ${activeIssueId}`);
        }
        return { ...prev, [severity]: true };
      }
      return prev;
    });
    
    // Delay scrolling to allow for category expansion animation
    const scrollTimer = setTimeout(() => {
      // Only switch to issues tab if we're currently scrolling to show an issue
      // Don't force tab switch if user is viewing statistics
      const shouldScrollToIssue = activeTab === 'issues';

      if (shouldScrollToIssue) {
        // Scroll to the issue element
        const issueElement = issueRefs.current[activeIssueId];
        if (issueElement) {
          if (process.env.NODE_ENV === 'development') {
            console.log(`📍 Auto-scrolling to issue: ${activeIssueId}`);
          }

          // Calculate the position relative to the panel content
          const panelContent = panelContentRef.current;
          if (panelContent) {
            // Get the issue element's position relative to the panel
            const issueRect = issueElement.getBoundingClientRect();
            const panelRect = panelContent.getBoundingClientRect();

            // Calculate scroll position to center the issue in view
            const scrollTop = issueElement.offsetTop - panelRect.height / 2 + issueElement.offsetHeight / 2;

            // Smooth scroll to the issue
            panelContent.scrollTo({
              top: Math.max(0, scrollTop),
              behavior: 'smooth'
            });
          }

          // Add a highlight animation to draw attention
          issueElement.classList.add('issue-highlight-animation');
          setTimeout(() => {
            issueElement.classList.remove('issue-highlight-animation');
          }, 2000);
        }
      }
    }, expandedCategories[severity] ? 100 : 400); // Longer delay if category needs to expand
    
    return () => clearTimeout(scrollTimer);
  }, [activeIssueId, issues, activeTab, expandedCategories]);
  
  return (
    <div className="h-full bg-white flex flex-col">
      {/* Streamlined Header */}
      <div className="bg-white border-b border-slate-200 px-6 py-5">
        <div className="flex justify-between items-center">
          <div>
            <h2 className="text-xl font-bold text-slate-900 tracking-tight">Analysis Results</h2>
            <p className="text-sm text-slate-500 mt-1">APA 7th Edition Compliance Check</p>
          </div>
          
          {/* Compliance Badge */}
          {analysisScore !== null && (
            <div className={`px-4 py-2 rounded-xl font-semibold text-sm shadow-sm ${
              analysisScore >= 80 ? 'bg-gradient-to-r from-emerald-50 to-emerald-100 text-emerald-700 border border-emerald-200' :
              analysisScore >= 60 ? 'bg-gradient-to-r from-amber-50 to-amber-100 text-amber-700 border border-amber-200' :
              'bg-gradient-to-r from-red-50 to-red-100 text-red-700 border border-red-200'
            }`}>
              {analysisScore >= 80 ? '✨ Excellent' : analysisScore >= 60 ? '⚡ Good' : '🎯 Needs Work'}
            </div>
          )}
        </div>
        
        {/* Quick Overview */}
        {(totalIssues > 0 || documentFormattingIssues.length > 0) && (
          <div className="space-y-3 mt-3">
            {/* Document Formatting Issues */}
            {documentFormattingIssues.length > 0 && (
              <div className="flex flex-wrap items-center gap-2 p-3 bg-amber-50 rounded-lg border border-amber-200">
                <div className="flex items-center space-x-2">
                  <AlertCircle className="h-4 w-4 text-amber-600" />
                  <span className="text-sm font-medium text-amber-700">Document formatting:</span>
                </div>
                {documentFormattingIssues.map((issue, index) => (
                  <button
                    key={issue.id || `doc-format-${index}`}
                    onClick={() => setActiveIssue(issue.id)}
                    className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-amber-100 text-amber-800 hover:bg-amber-200 transition-colors duration-200 cursor-pointer"
                  >
                    {issue.title}
                  </button>
                ))}
              </div>
            )}

            {/* Severity Counts */}
            {totalIssues > 0 && (
              <div className="flex items-center space-x-3">
                <div className="flex items-center space-x-2 px-3 py-1.5 bg-red-50 rounded-lg border border-red-200">
                  <div className="w-2 h-2 bg-red-500 rounded-full"></div>
                  <span className="text-sm font-medium text-red-700">{issueCounts.Critical} Critical</span>
                </div>
                <div className="flex items-center space-x-2 px-3 py-1.5 bg-amber-50 rounded-lg border border-amber-200">
                  <div className="w-2 h-2 bg-amber-500 rounded-full"></div>
                  <span className="text-sm font-medium text-amber-700">{issueCounts.Major} Major</span>
                </div>
                <div className="flex items-center space-x-2 px-3 py-1.5 bg-blue-50 rounded-lg border border-blue-200">
                  <div className="w-2 h-2 bg-blue-500 rounded-full"></div>
                  <span className="text-sm font-medium text-blue-700">{issueCounts.Minor} Minor</span>
                </div>
              </div>
            )}
          </div>
        )}

        {/* Error Message */}
        {fixError && (
          <div className="mt-4 p-3 bg-amber-50 border border-amber-200 rounded-lg">
            <p className="text-sm text-amber-800">{fixError}</p>
          </div>
        )}

        {/* Tab Navigation */}
        <div className="flex items-center space-x-1 mt-4">
          <button
            onClick={() => setActiveTab('issues')}
            className={`flex items-center space-x-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 border ${
              activeTab === 'issues'
                ? 'bg-emerald-500 text-white shadow-lg shadow-emerald-500/25 border-emerald-500'
                : 'text-slate-600 hover:bg-slate-50 border-slate-200'
            }`}
          >
            <AlertCircle className="h-4 w-4" />
            <span>Issues</span>
            {totalIssues > 0 && (
              <span className="ml-1 px-1.5 py-0.5 text-xs bg-red-500 text-white rounded-full">{totalIssues}</span>
            )}
          </button>
          <button
            onClick={() => setActiveTab('stats')}
            className={`flex items-center space-x-2 px-4 py-2 rounded-xl text-sm font-medium transition-all duration-200 border ${
              activeTab === 'stats'
                ? 'bg-emerald-500 text-white shadow-lg shadow-emerald-500/25 border-emerald-500'
                : 'text-slate-600 hover:bg-slate-50 border-slate-200'
            }`}
          >
            <BarChart3 className="h-4 w-4" />
            <span>Overview</span>
          </button>
        </div>
      </div>
      
      {/* Content Area */}
      <div className="flex-1 overflow-auto" ref={panelContentRef}>
        {activeTab === 'issues' ? (
          <div className="flex-1 overflow-auto">
            {totalIssues > 0 ? (
              <div className="p-6 space-y-6">
                
                {/* Priority Issues First */}
                {issueCounts.Critical > 0 && (
                  <IssueCategory
                    title="Critical Issues"
                    count={issueCounts.Critical}
                    severity="Critical"
                    expanded={expandedCategories.Critical}
                    toggleExpanded={() => toggleCategory('Critical')}
                  >
                    {expandedCategories.Critical && groupedIssues.Critical.map((issue, index) => (
                      <IssueItem
                        key={issue.id || `critical-${index}`}
                        ref={el => issueRefs.current[issue.id] = el}
                        issue={issue}
                        isActive={activeIssueId === issue.id}
                        onSelect={() => setActiveIssue(issue.id)}
                        onApplyFix={() => handleApplyFix(issue.id)}
                        isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                      />
                    ))}
                  </IssueCategory>
                )}
                
                {issueCounts.Major > 0 && (
                  <IssueCategory 
                    title="Major Issues" 
                    count={issueCounts.Major} 
                    severity="Major"
                    expanded={expandedCategories.Major}
                    toggleExpanded={() => toggleCategory('Major')}
                  >
                    {expandedCategories.Major && groupedIssues.Major.map((issue, index) => (
                      <IssueItem
                        key={issue.id || `major-${index}`}
                        ref={el => issueRefs.current[issue.id] = el}
                        issue={issue}
                        isActive={activeIssueId === issue.id}
                        onSelect={() => setActiveIssue(issue.id)}
                        onApplyFix={() => handleApplyFix(issue.id)}
                        isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                      />
                    ))}
                  </IssueCategory>
                )}
                
                {issueCounts.Minor > 0 && (
                  <IssueCategory 
                    title="Minor Issues" 
                    count={issueCounts.Minor} 
                    severity="Minor"
                    expanded={expandedCategories.Minor}
                    toggleExpanded={() => toggleCategory('Minor')}
                  >
                    {expandedCategories.Minor && groupedIssues.Minor.map((issue, index) => (
                      <IssueItem
                        key={issue.id || `minor-${index}`}
                        ref={el => issueRefs.current[issue.id] = el}
                        issue={issue}
                        isActive={activeIssueId === issue.id}
                        onSelect={() => setActiveIssue(issue.id)}
                        onApplyFix={() => handleApplyFix(issue.id)}
                        isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                      />
                    ))}
                  </IssueCategory>
                )}
              </div>
            ) : (issues.length === 0 && documentFormattingIssues.length === 0) ? (
              <div className="flex flex-col items-center justify-center py-16 px-6">
                <div className="w-16 h-16 bg-slate-100 rounded-2xl mb-4 flex items-center justify-center">
                  <FileText className="h-8 w-8 text-slate-400" />
                </div>
                <h3 className="text-lg font-semibold text-slate-900 mb-2">No Document to Analyze</h3>
                <p className="text-slate-500 text-center text-sm">
                  Upload a document to see APA compliance analysis
                </p>
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center py-16 px-6">
                <div className="w-20 h-20 bg-gradient-to-br from-emerald-500 to-emerald-600 rounded-2xl flex items-center justify-center mb-6 shadow-lg">
                  <Check className="h-10 w-10 text-white" />
                </div>
                <h3 className="text-2xl font-bold text-slate-900 mb-3">Excellent Work!</h3>
                <p className="text-slate-600 text-center mb-2">
                  Your document meets all APA 7th Edition requirements.
                </p>
                <p className="text-sm text-slate-500 text-center">
                  No formatting or citation issues detected.
                </p>
              </div>
            )}
          </div>
        ) : (
          <div className="p-6">
            {/* Statistics Tab Content */}
            <div className="space-y-6">
              {/* Compliance Score Card */}
              {analysisScore !== null && (
                <div className="bg-white rounded-2xl shadow-lg border border-slate-200 p-6">
                  <div className="flex items-center justify-between mb-6">
                    <h3 className="text-lg font-bold text-slate-900 flex items-center">
                      <Target className="h-5 w-5 mr-2 text-emerald-500" />
                      Compliance Score
                    </h3>
                    <div className={`px-3 py-1 rounded-full text-xs font-medium ${
                      analysisScore >= 80 ? 'bg-emerald-100 text-emerald-700' :
                      analysisScore >= 60 ? 'bg-amber-100 text-amber-700' :
                      'bg-rose-100 text-rose-700'
                    }`}>
                      {analysisScore >= 80 ? 'Excellent' : analysisScore >= 60 ? 'Good' : 'Needs Improvement'}
                    </div>
                  </div>
                  
                  <div className="flex items-center space-x-6">
                    <div className="relative">
                      <svg className="w-32 h-32 transform -rotate-90">
                        <circle
                          cx="64"
                          cy="64"
                          r="56"
                          stroke="#e2e8f0"
                          strokeWidth="12"
                          fill="none"
                        />
                        <circle
                          cx="64"
                          cy="64"
                          r="56"
                          stroke={analysisScore >= 80 ? '#10b981' : analysisScore >= 60 ? '#f59e0b' : '#ef4444'}
                          strokeWidth="12"
                          fill="none"
                          strokeDasharray={`${(analysisScore / 100) * 351.86} 351.86`}
                          strokeLinecap="round"
                        />
                      </svg>
                      <div className="absolute inset-0 flex items-center justify-center">
                        <span className="text-3xl font-bold text-slate-900">{analysisScore}%</span>
                      </div>
                    </div>
                    
                    <div className="flex-1 space-y-3">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-slate-600">Critical Issues</span>
                        <span className="text-sm font-semibold text-red-600">{issueCounts.Critical}</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-slate-600">Major Issues</span>
                        <span className="text-sm font-semibold text-amber-600">{issueCounts.Major}</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-slate-600">Minor Issues</span>
                        <span className="text-sm font-semibold text-blue-600">{issueCounts.Minor}</span>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              
              {/* Document Statistics */}
              {documentStats && (
                <div className="bg-white rounded-2xl shadow-lg border border-slate-200 p-6">
                  <h3 className="text-lg font-bold text-slate-900 mb-4 flex items-center">
                    <Activity className="h-5 w-5 mr-2 text-emerald-500" />
                    Document Statistics
                  </h3>
                  
                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-gradient-to-br from-emerald-50 to-emerald-100 rounded-xl p-4 border border-emerald-200 shadow-sm">
                      <div className="flex items-center justify-between mb-2">
                        <BookOpen className="h-5 w-5 text-emerald-600" />
                        <span className="text-2xl font-bold text-emerald-700">{documentStats.wordCount}</span>
                      </div>
                      <p className="text-xs font-medium text-emerald-600">Total Words</p>
                    </div>
                    
                    <div className="bg-gradient-to-br from-slate-50 to-slate-100 rounded-xl p-4 border border-slate-200 shadow-sm">
                      <div className="flex items-center justify-between mb-2">
                        <FileText className="h-5 w-5 text-slate-600" />
                        <span className="text-2xl font-bold text-slate-700">{documentStats.paragraphCount}</span>
                      </div>
                      <p className="text-xs font-medium text-slate-600">Paragraphs</p>
                    </div>
                    
                    <div className="bg-gradient-to-br from-teal-50 to-teal-100 rounded-xl p-4 border border-teal-200 shadow-sm">
                      <div className="flex items-center justify-between mb-2">
                        <Zap className="h-5 w-5 text-teal-600" />
                        <span className="text-2xl font-bold text-teal-700">{documentStats.charCount}</span>
                      </div>
                      <p className="text-xs font-medium text-teal-600">Characters</p>
                    </div>
                    
                    <div className="bg-gradient-to-br from-amber-50 to-amber-100 rounded-xl p-4 border border-amber-200 shadow-sm">
                      <div className="flex items-center justify-between mb-2">
                        <Clock className="h-5 w-5 text-amber-600" />
                        <span className="text-2xl font-bold text-amber-700">{Math.round(documentStats.wordCount / 200)}</span>
                      </div>
                      <p className="text-xs font-medium text-amber-600">Min Read Time</p>
                    </div>
                  </div>
                </div>
              )}
              
              {/* Document Format Details */}
              {documentFormatting && (
                <div className="bg-white rounded-2xl shadow-lg border border-slate-200 p-6">
                  <h3 className="text-lg font-bold text-slate-900 mb-4 flex items-center">
                    <FileSearch className="h-5 w-5 mr-2 text-emerald-500" />
                    Format Analysis
                  </h3>
                  
                  <div className="space-y-3">
                    <div className="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                      <span className="text-sm font-medium text-slate-600">Font Family</span>
                      <span className="text-sm font-semibold text-slate-900">
                        {documentFormatting.document?.font?.family || 'Not specified'}
                      </span>
                    </div>
                    <div className="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                      <span className="text-sm font-medium text-slate-600">Font Size</span>
                      <span className="text-sm font-semibold text-slate-900">
                        {documentFormatting.document?.font?.size || 'Not specified'}pt
                      </span>
                    </div>
                    <div className="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                      <span className="text-sm font-medium text-slate-600">Line Spacing</span>
                      <span className="text-sm font-semibold text-slate-900">
                        {documentFormatting.document?.spacing?.line || 'Not specified'}
                      </span>
                    </div>
                    <div className="flex items-center justify-between p-3 bg-slate-50 rounded-lg">
                      <span className="text-sm font-medium text-slate-600">Margins</span>
                      <span className="text-sm font-semibold text-slate-900">
                        {documentFormatting.document?.margins?.top || 'Not specified'}&quot;
                      </span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// Modern Issue Category Component
const IssueCategory = React.memo(function IssueCategory({ title, count, severity, expanded, toggleExpanded, children }) {
  const getStyles = () => {
    switch (severity) {
      case 'Critical':
        return {
          gradient: 'from-red-500 to-red-600',
          bg: 'from-red-50 to-red-100',
          border: 'border-red-200',
          text: 'text-red-700',
          icon: <AlertOctagon className="h-5 w-5" />
        };
      case 'Major': 
        return {
          gradient: 'from-amber-500 to-amber-600',
          bg: 'from-amber-50 to-amber-100',
          border: 'border-amber-200',
          text: 'text-amber-700',
          icon: <AlertTriangle className="h-5 w-5" />
        };
      case 'Minor':
        return {
          gradient: 'from-blue-500 to-blue-600',
          bg: 'from-blue-50 to-blue-100',
          border: 'border-blue-200',
          text: 'text-blue-700',
          icon: <Info className="h-5 w-5" />
        };
      default:
        return {
          gradient: 'from-slate-500 to-slate-600',
          bg: 'from-slate-50 to-slate-100',
          border: 'border-slate-200',
          text: 'text-slate-700',
          icon: null
        };
    }
  };
  
  const styles = getStyles();
  
  return (
    <div className={`rounded-2xl overflow-hidden border ${styles.border} shadow-lg hover:shadow-xl transition-all duration-300 mb-4`}>
      <button 
        onClick={toggleExpanded}
        className={`w-full flex justify-between items-center px-6 py-4 bg-gradient-to-r ${styles.bg} ${styles.text} transition-all duration-200 hover:opacity-90`}
      >
        <span className="font-semibold flex items-center text-base">
          <div className={`w-8 h-8 bg-gradient-to-br ${styles.gradient} rounded-lg flex items-center justify-center mr-3 text-white`}>
            {styles.icon}
          </div>
          {title}
        </span>
        <div className="flex items-center space-x-3">
          <span className={`px-3 py-1 bg-white rounded-full text-sm font-bold shadow-sm`}>
            {count}
          </span>
          <ChevronDown 
            className={`h-5 w-5 transition-transform duration-300 ${expanded ? 'rotate-180' : ''}`}
          />
        </div>
      </button>
      
      {expanded && (
        <div className="bg-white divide-y divide-slate-100">
          {children}
        </div>
      )}
    </div>
  );
});

// Modern Issue Item Component
const IssueItem = React.memo(React.forwardRef(function IssueItem({ 
  issue, 
  isActive, 
  onSelect, 
  onApplyFix,
  isApplyingFix = false
}, ref) {
  return (
    <div
      ref={ref}
      className={`px-6 py-5 hover:bg-slate-50 cursor-pointer transition-all duration-200 ${
        isActive ? 'bg-gradient-to-r from-emerald-50 to-teal-50 border-l-4 border-emerald-500' : ''
      }`}
      onClick={onSelect}
    >
      <div className="flex justify-between">
        <div className="flex-1 pr-4">
          <div className="flex items-start mb-2">
            <p className="text-sm font-semibold text-slate-900">{issue.title}</p>
          </div>
          <p className="text-xs text-slate-600 mb-3 leading-relaxed">{issue.description}</p>
          
          {issue.text && (
            <div className="mt-3 p-3 bg-gradient-to-r from-slate-50 to-slate-100 rounded-lg border border-slate-200">
              <p className="text-xs font-mono text-slate-700">&ldquo;{issue.text}&rdquo;</p>
            </div>
          )}
          
          {issue.explanation && (
            <div className="mt-3 p-3 bg-gradient-to-r from-emerald-50 to-teal-50 rounded-lg border border-emerald-200">
              <div className="flex items-start space-x-2">
                <Info className="h-3.5 w-3.5 text-emerald-500 mt-0.5 flex-shrink-0" />
                <p className="text-xs text-emerald-700">{issue.explanation}</p>
              </div>
            </div>
          )}
        </div>
        
        {issue.hasFix && (
          <div className="flex items-center">
            <button 
              onClick={(e) => {
                e.stopPropagation();
                if (!isApplyingFix) onApplyFix();
              }}
              disabled={isApplyingFix}
              className={`flex items-center space-x-2 px-4 py-2 rounded-xl text-xs font-medium transition-all duration-200 transform ${
                isApplyingFix
                  ? 'bg-slate-100 text-slate-400 cursor-not-allowed'
                  : 'bg-gradient-to-r from-emerald-500 to-emerald-600 text-white shadow-lg hover:shadow-xl hover:-translate-y-0.5 active:translate-y-0'
              }`}
            >
              {isApplyingFix ? (
                <>
                  <div className="loading-spinner w-3.5 h-3.5"></div>
                  <span>Fixing...</span>
                </>
              ) : (
                <>
                  <Sparkles className="h-3.5 w-3.5" />
                  <span>Apply Fix</span>
                </>
              )}
            </button>
          </div>
        )}
      </div>
    </div>
  );
}));

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\LandingHeader.js
"use client";
import Link from "next/link";
import { useState, useEffect } from "react";
import { FileCheck, Menu, X, ArrowRight, LayoutDashboard, LogOut, User, Settings, Sparkles } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { createClient } from "@/lib/supabase/client";
import { useRouter } from "next/navigation";

export default function LandingHeader() {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [user, setUser] = useState(null);
  const [scrolled, setScrolled] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const getUser = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      setUser(user);
    };
    getUser();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user ?? null);
    });

    return () => subscription.unsubscribe();
  }, [supabase.auth]);

  useEffect(() => {
    const handleScroll = () => {
      setScrolled(window.scrollY > 20);
    };
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    router.push('/');
    router.refresh();
  };

  const getInitials = (email) => {
    if (!email) return "U";
    const parts = email.split('@')[0].split('.');
    if (parts.length > 1) {
      return (parts[0][0] + parts[1][0]).toUpperCase();
    }
    return email.substring(0, 2).toUpperCase();
  };

  return (
    <motion.header
      initial={{ y: -100, opacity: 0 }}
      animate={{ y: 0, opacity: 1 }}
      transition={{ duration: 0.5, ease: "easeOut" }}
      className={`fixed top-0 left-0 right-0 z-50 transition-all duration-500 ${
        scrolled
          ? 'bg-white/98 backdrop-blur-xl shadow-lg shadow-slate-900/5 border-b border-slate-200'
          : 'bg-white/70 backdrop-blur-md border-b border-slate-100/50'
      }`}
    >
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="h-[72px] flex items-center justify-between">
          {/* Logo with Badge */}
          <Link href="/" className="flex items-center gap-3 group">
            <motion.div
              whileHover={{ scale: 1.05, rotate: 3 }}
              whileTap={{ scale: 0.95 }}
              className="relative"
            >
              <div className="w-12 h-12 bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 rounded-2xl flex items-center justify-center shadow-xl shadow-blue-500/25 group-hover:shadow-2xl group-hover:shadow-blue-500/40 transition-all duration-300 ring-2 ring-white/20">
                <FileCheck className="h-6 w-6 text-white" strokeWidth={2.5} />
              </div>
              <div className="absolute -top-1 -right-1 w-3 h-3 bg-emerald-500 rounded-full border-2 border-white shadow-sm"></div>
            </motion.div>
            <div className="flex flex-col">
              <span className="text-2xl font-bold tracking-tight bg-gradient-to-r from-slate-900 via-slate-800 to-slate-700 bg-clip-text text-transparent">
                APA Pro
              </span>
              <span className="text-[10px] font-medium text-slate-500 -mt-1 tracking-wider uppercase">
                7th Edition
              </span>
            </div>
          </Link>

          {/* Desktop Navigation */}
          <nav className="hidden md:flex items-center gap-1">
            <Link
              href="/#features"
              className="px-4 py-2 text-slate-700 hover:text-slate-900 hover:bg-slate-100/80 rounded-xl transition-all duration-200 font-medium text-sm relative group"
            >
              Features
              <span className="absolute bottom-1 left-1/2 -translate-x-1/2 w-0 h-0.5 bg-gradient-to-r from-blue-600 to-indigo-600 group-hover:w-8 transition-all duration-300"></span>
            </Link>
            <Link
              href="/#how-it-works"
              className="px-4 py-2 text-slate-700 hover:text-slate-900 hover:bg-slate-100/80 rounded-xl transition-all duration-200 font-medium text-sm relative group"
            >
              How it Works
              <span className="absolute bottom-1 left-1/2 -translate-x-1/2 w-0 h-0.5 bg-gradient-to-r from-blue-600 to-indigo-600 group-hover:w-10 transition-all duration-300"></span>
            </Link>
          </nav>

          {/* Auth Buttons / User Menu */}
          <div className="hidden md:flex items-center gap-3">
            {user ? (
              <>
                <Link href="/dashboard">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="gap-2 font-medium text-slate-700 hover:text-slate-900 hover:bg-slate-100 rounded-xl"
                  >
                    <LayoutDashboard className="h-4 w-4" />
                    Dashboard
                  </Button>
                </Link>
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button
                      variant="ghost"
                      size="sm"
                      className="gap-2.5 hover:bg-slate-100 rounded-xl pl-2 pr-3"
                    >
                      <Avatar className="w-8 h-8 ring-2 ring-slate-200 ring-offset-2">
                        <AvatarFallback className="bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white text-xs font-bold">
                          {getInitials(user.email)}
                        </AvatarFallback>
                      </Avatar>
                      <span className="font-semibold text-slate-800 text-sm">{user.email?.split('@')[0]}</span>
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end" className="w-64 p-2">
                    <DropdownMenuLabel className="p-3">
                      <div className="flex items-center gap-3">
                        <Avatar className="w-10 h-10 ring-2 ring-slate-200">
                          <AvatarFallback className="bg-gradient-to-br from-blue-600 via-indigo-600 to-purple-600 text-white font-bold">
                            {getInitials(user.email)}
                          </AvatarFallback>
                        </Avatar>
                        <div className="flex flex-col">
                          <p className="text-sm font-semibold text-slate-900">{user.email?.split('@')[0]}</p>
                          <p className="text-xs text-slate-500">{user.email}</p>
                        </div>
                      </div>
                    </DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      onClick={() => router.push('/profile')}
                      className="cursor-pointer rounded-lg py-2.5"
                    >
                      <User className="mr-2 h-4 w-4" />
                      <span className="font-medium">Profile</span>
                    </DropdownMenuItem>
                    <DropdownMenuItem
                      onClick={() => router.push('/settings')}
                      className="cursor-pointer rounded-lg py-2.5"
                    >
                      <Settings className="mr-2 h-4 w-4" />
                      <span className="font-medium">Settings</span>
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                      onClick={handleSignOut}
                      className="cursor-pointer text-red-600 focus:text-red-600 focus:bg-red-50 rounded-lg py-2.5"
                    >
                      <LogOut className="mr-2 h-4 w-4" />
                      <span className="font-medium">Sign Out</span>
                    </DropdownMenuItem>
                  </DropdownMenuContent>
                </DropdownMenu>
              </>
            ) : (
              <>
                <Link href="/login">
                  <Button
                    variant="ghost"
                    size="sm"
                    className="font-semibold text-slate-700 hover:text-slate-900 hover:bg-slate-100 rounded-xl px-4"
                  >
                    Sign In
                  </Button>
                </Link>
                <Link href="/signup">
                  <Button
                    size="sm"
                    className="gap-2 bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 hover:from-blue-700 hover:via-indigo-700 hover:to-purple-700 shadow-lg shadow-blue-500/25 hover:shadow-xl hover:shadow-blue-500/30 transition-all font-semibold rounded-xl px-5 group"
                  >
                    <Sparkles className="h-4 w-4 group-hover:rotate-12 transition-transform" />
                    Get Started
                    <ArrowRight className="h-4 w-4 group-hover:translate-x-0.5 transition-transform" />
                  </Button>
                </Link>
              </>
            )}
          </div>

          {/* Mobile Menu Button */}
          <div className="md:hidden">
            <Button
              variant="ghost"
              size="icon"
              onClick={() => setIsMenuOpen(!isMenuOpen)}
              className="relative rounded-xl hover:bg-slate-100"
            >
              <AnimatePresence mode="wait">
                {isMenuOpen ? (
                  <motion.div
                    key="close"
                    initial={{ rotate: -90, opacity: 0 }}
                    animate={{ rotate: 0, opacity: 1 }}
                    exit={{ rotate: 90, opacity: 0 }}
                    transition={{ duration: 0.2 }}
                  >
                    <X className="h-6 w-6 text-slate-800" />
                  </motion.div>
                ) : (
                  <motion.div
                    key="menu"
                    initial={{ rotate: 90, opacity: 0 }}
                    animate={{ rotate: 0, opacity: 1 }}
                    exit={{ rotate: -90, opacity: 0 }}
                    transition={{ duration: 0.2 }}
                  >
                    <Menu className="h-6 w-6 text-slate-800" />
                  </motion.div>
                )}
              </AnimatePresence>
            </Button>
          </div>
        </div>
      </div>

      {/* Mobile Menu */}
      <AnimatePresence>
        {isMenuOpen && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3, ease: "easeInOut" }}
            className="md:hidden bg-gradient-to-b from-white to-slate-50 border-t border-slate-200 shadow-2xl"
          >
            <div className="px-4 pt-4 pb-6 space-y-3">
              <motion.div
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.1 }}
              >
                <Link
                  href="/#features"
                  className="block px-4 py-3.5 rounded-xl text-slate-700 hover:bg-white hover:text-blue-600 font-semibold transition-all border border-transparent hover:border-slate-200 hover:shadow-sm"
                  onClick={() => setIsMenuOpen(false)}
                >
                  Features
                </Link>
              </motion.div>
              <motion.div
                initial={{ x: -20, opacity: 0 }}
                animate={{ x: 0, opacity: 1 }}
                transition={{ delay: 0.15 }}
              >
                <Link
                  href="/#how-it-works"
                  className="block px-4 py-3.5 rounded-xl text-slate-700 hover:bg-white hover:text-blue-600 font-semibold transition-all border border-transparent hover:border-slate-200 hover:shadow-sm"
                  onClick={() => setIsMenuOpen(false)}
                >
                  How it Works
                </Link>
              </motion.div>

              {user ? (
                <>
                  <div className="h-px bg-slate-200 my-3"></div>
                  <motion.div
                    initial={{ x: -20, opacity: 0 }}
                    animate={{ x: 0, opacity: 1 }}
                    transition={{ delay: 0.2 }}
                  >
                    <Link
                      href="/dashboard"
                      className="flex items-center gap-3 px-4 py-3.5 rounded-xl bg-gradient-to-r from-blue-50 to-indigo-50 text-blue-700 hover:from-blue-100 hover:to-indigo-100 font-semibold transition-all shadow-sm"
                      onClick={() => setIsMenuOpen(false)}
                    >
                      <LayoutDashboard className="h-5 w-5" />
                      Dashboard
                    </Link>
                  </motion.div>
                  <motion.div
                    initial={{ x: -20, opacity: 0 }}
                    animate={{ x: 0, opacity: 1 }}
                    transition={{ delay: 0.25 }}
                  >
                    <Link
                      href="/profile"
                      className="flex items-center gap-3 px-4 py-3.5 rounded-xl text-slate-700 hover:bg-white font-semibold transition-all border border-transparent hover:border-slate-200"
                      onClick={() => setIsMenuOpen(false)}
                    >
                      <User className="h-5 w-5" />
                      Profile
                    </Link>
                  </motion.div>
                  <motion.div
                    initial={{ x: -20, opacity: 0 }}
                    animate={{ x: 0, opacity: 1 }}
                    transition={{ delay: 0.3 }}
                  >
                    <button
                      onClick={() => {
                        handleSignOut();
                        setIsMenuOpen(false);
                      }}
                      className="w-full flex items-center gap-3 px-4 py-3.5 rounded-xl text-red-600 hover:bg-red-50 font-semibold transition-all border border-transparent hover:border-red-200"
                    >
                      <LogOut className="h-5 w-5" />
                      Sign Out
                    </button>
                  </motion.div>
                </>
              ) : (
                <>
                  <div className="h-px bg-slate-200 my-3"></div>
                  <div className="space-y-2">
                    <motion.div
                      initial={{ x: -20, opacity: 0 }}
                      animate={{ x: 0, opacity: 1 }}
                      transition={{ delay: 0.2 }}
                    >
                      <Link
                        href="/login"
                        className="block px-4 py-3.5 rounded-xl bg-white border border-slate-200 text-slate-700 hover:bg-slate-50 font-semibold text-center transition-all shadow-sm"
                        onClick={() => setIsMenuOpen(false)}
                      >
                        Sign In
                      </Link>
                    </motion.div>
                    <motion.div
                      initial={{ x: -20, opacity: 0 }}
                      animate={{ x: 0, opacity: 1 }}
                      transition={{ delay: 0.25 }}
                    >
                      <Link
                        href="/signup"
                        className="flex items-center justify-center gap-2 px-4 py-3.5 rounded-xl bg-gradient-to-r from-blue-600 via-indigo-600 to-purple-600 text-white font-semibold text-center shadow-lg hover:shadow-xl transition-all"
                        onClick={() => setIsMenuOpen(false)}
                      >
                        <Sparkles className="h-4 w-4" />
                        Get Started
                        <ArrowRight className="h-4 w-4" />
                      </Link>
                    </motion.div>
                  </div>
                </>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.header>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\loading\AnalysisLoadingSkeleton.jsx
'use client';

import { Skeleton } from "@/components/ui/skeleton";
import { Card } from "@/components/ui/card";
import { FileSearch, AlertCircle, CheckCircle2 } from "lucide-react";

export default function AnalysisLoadingSkeleton({
  message = "Analyzing document for APA compliance...",
  fileName = "document.docx"
}) {
  return (
    <div className="min-h-screen bg-white flex items-center justify-center px-4">
      <Card className="max-w-2xl w-full p-8 border-slate-200 shadow-lg">
        <div className="text-center space-y-6">
          {/* Animated Icon */}
          <div className="relative mx-auto w-20 h-20">
            <div className="absolute inset-0 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full opacity-20 animate-ping"></div>
            <div className="relative w-20 h-20 bg-gradient-to-br from-blue-500 to-indigo-600 rounded-full flex items-center justify-center">
              <FileSearch className="h-10 w-10 text-white animate-pulse" />
            </div>
          </div>

          {/* Main Message */}
          <div className="space-y-2">
            <h2 className="text-2xl font-bold text-slate-900">{message}</h2>
            <p className="text-slate-600">Processing: <span className="font-semibold">{fileName}</span></p>
          </div>

          {/* Progress Steps */}
          <div className="space-y-3 py-6">
            <div className="flex items-center gap-3 text-left">
              <CheckCircle2 className="h-5 w-5 text-green-500 flex-shrink-0" />
              <div className="flex-1">
                <p className="text-sm font-medium text-slate-900">Document uploaded</p>
                <p className="text-xs text-slate-500">File received and validated</p>
              </div>
            </div>

            <div className="flex items-center gap-3 text-left">
              <div className="relative flex-shrink-0">
                <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
              </div>
              <div className="flex-1">
                <p className="text-sm font-medium text-slate-900">Analyzing content</p>
                <p className="text-xs text-slate-500">Checking citations, references, and formatting</p>
              </div>
            </div>

            <div className="flex items-center gap-3 text-left opacity-50">
              <AlertCircle className="h-5 w-5 text-slate-400 flex-shrink-0" />
              <div className="flex-1">
                <p className="text-sm font-medium text-slate-900">Generating report</p>
                <p className="text-xs text-slate-500">Compiling issues and compliance score</p>
              </div>
            </div>
          </div>

          {/* Progress Bar */}
          <div className="w-full bg-slate-200 rounded-full h-2 overflow-hidden">
            <div className="h-full bg-gradient-to-r from-blue-600 to-indigo-600 rounded-full animate-pulse" style={{ width: '66%' }}></div>
          </div>

          <p className="text-sm text-slate-500">
            This may take a few moments for larger documents...
          </p>
        </div>
      </Card>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\loading\DashboardLoadingSkeleton.jsx
'use client';

import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardHeader, CardContent } from "@/components/ui/card";

export default function DashboardLoadingSkeleton({ message = "Loading your dashboard..." }) {
  return (
    <div className="space-y-8">
      {/* Header Skeleton */}
      <div className="space-y-2">
        <Skeleton className="h-9 w-96" />
        <Skeleton className="h-5 w-64" />
      </div>

      {/* Overview Cards Skeleton */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {[1, 2, 3].map((i) => (
          <Card key={i}>
            <CardHeader className="pb-3">
              <Skeleton className="h-4 w-32" />
            </CardHeader>
            <CardContent>
              <Skeleton className="h-8 w-20 mb-2" />
              <Skeleton className="h-3 w-full" />
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Loading Message */}
      <div className="flex items-center gap-3 text-slate-600 bg-slate-50 p-4 rounded-lg border border-slate-200">
        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
        <p className="text-sm font-medium">{message}</p>
      </div>

      {/* Content Grid Skeleton */}
      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <div className="lg:col-span-2 space-y-4">
          <Skeleton className="h-7 w-48" />
          {[1, 2, 3].map((i) => (
            <Card key={i}>
              <CardContent className="p-6">
                <div className="space-y-3">
                  <Skeleton className="h-5 w-3/4" />
                  <Skeleton className="h-4 w-1/2" />
                  <Skeleton className="h-4 w-full" />
                </div>
              </CardContent>
            </Card>
          ))}
        </div>
        <div className="lg:col-span-1">
          <Skeleton className="h-7 w-32 mb-4" />
          <Card>
            <CardContent className="p-6">
              <Skeleton className="h-32 w-full" />
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\loading\DocumentsLoadingSkeleton.jsx
'use client';

import { Skeleton } from "@/components/ui/skeleton";
import { Card, CardHeader, CardContent } from "@/components/ui/card";
import { FileText } from "lucide-react";

export default function DocumentsLoadingSkeleton({ message = "Loading your documents..." }) {
  return (
    <div className="space-y-6">
      {/* Loading Message */}
      <div className="flex items-center gap-3 text-slate-600">
        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600"></div>
        <p className="text-sm font-medium">{message}</p>
      </div>

      {/* Skeleton Cards */}
      <div className="grid gap-4">
        {[1, 2, 3].map((i) => (
          <Card key={i} className="border-slate-200">
            <CardHeader className="pb-3">
              <div className="flex items-start justify-between">
                <div className="flex items-start gap-3 flex-1">
                  <div className="w-10 h-10 rounded-lg bg-slate-100 flex items-center justify-center">
                    <FileText className="h-5 w-5 text-slate-400" />
                  </div>
                  <div className="flex-1 space-y-2">
                    <Skeleton className="h-5 w-3/4" />
                    <Skeleton className="h-4 w-1/2" />
                  </div>
                </div>
                <Skeleton className="h-6 w-20" />
              </div>
            </CardHeader>
            <CardContent>
              <div className="flex items-center justify-between">
                <Skeleton className="h-4 w-32" />
                <div className="flex gap-2">
                  <Skeleton className="h-9 w-20" />
                  <Skeleton className="h-9 w-20" />
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\LoadingState.js
'use client';

import { memo } from 'react';

const LoadingState = memo(() => {
  return (
    <div className="flex-1 flex flex-col items-center justify-center bg-slate-50 p-8">
      <div className="bg-white rounded-2xl p-10 shadow-lg border border-slate-200 flex flex-col items-center max-w-sm">
        <div className="relative mb-8">
          <div className="w-16 h-16 border-4 border-emerald-200 border-t-emerald-500 rounded-full animate-spin"></div>
          <div className="absolute inset-0 flex items-center justify-center">
            <div className="w-6 h-6 bg-emerald-500 rounded-full animate-pulse"></div>
          </div>
        </div>
        <h3 className="text-xl font-semibold text-slate-900 mb-3">Processing Document</h3>
        <p className="text-sm text-slate-600 text-center leading-relaxed">
          Analyzing your document with enhanced XML processing and APA validation...
        </p>
      </div>
    </div>
  );
});

LoadingState.displayName = 'LoadingState';

export default LoadingState;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\NewDocumentEditor.js
'use client';

import React, { useCallback } from 'react';
import { EditorContent } from '@tiptap/react';
import { useUnifiedDocumentEditor } from '@/hooks/useUnifiedDocumentEditor';
import { useUnifiedDocumentStore } from '@/store/unifiedDocumentStore';
import EmptyDocumentState from '@/components/EmptyDocumentState';
import LoadingState from '@/components/LoadingState';
import DocumentControls from '@/components/DocumentControls';
import FormattingToolbar from '@/components/FormattingToolbar';

/**
 * New Document Editor Component
 * Uses the unified DocumentModel architecture with bidirectional sync
 */
export const NewDocumentEditor = () => {
  const {
    documentModel,
    processingState,
    getIssues,
    analyzeDocument,
    uiState
  } = useUnifiedDocumentStore();

  const {
    editor,
    editorError,
    editorInitialized
  } = useUnifiedDocumentEditor();

  const isLoading = processingState.isUploading || processingState.isAnalyzing;
  const issues = getIssues();

  // Handle manual analysis
  const handleManualAnalysis = useCallback(async () => {
    if (!isLoading && documentModel) {
      await analyzeDocument({ force: true });
    }
  }, [isLoading, documentModel, analyzeDocument]);

  // Loading state
  if (isLoading) {
    return <LoadingState />;
  }

  // Empty state
  if (!documentModel) {
    return <EmptyDocumentState />;
  }

  // Error state
  if (editorError) {
    return (
      <div className="h-full flex items-center justify-center bg-slate-50 p-8">
        <div className="bg-red-50 border border-red-200 rounded-lg p-6 max-w-md">
          <div className="flex items-center mb-4">
            <div className="text-red-400 text-2xl mr-3">⚠️</div>
            <div>
              <h3 className="text-red-800 font-semibold text-lg">Editor Error</h3>
              <p className="text-red-600 mt-1">
                {editorError.message || 'The document editor encountered an error'}
              </p>
            </div>
          </div>
          <button
            onClick={() => window.location.reload()}
            className="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors"
          >
            Reload Page
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      <DocumentControls
        lastFixAppliedAt={null}
        documentText={documentModel.getPlainText()}
        documentFormatting={documentModel.formatting}
        handleManualAnalysis={handleManualAnalysis}
        isLoading={isLoading}
        processingState={processingState}
        showIssueHighlighting={uiState.showIssueHighlighting}
        toggleIssueHighlighting={() => {
          // Toggle highlighting logic
          const newState = !uiState.showIssueHighlighting;
          useUnifiedDocumentStore.setState({
            uiState: { ...uiState, showIssueHighlighting: newState }
          });
        }}
        issues={issues}
        editor={editor}
      />

      <FormattingToolbar editor={editor} />

      {/* Editor Content */}
      <div className="flex-1 overflow-auto bg-slate-50" style={{ scrollBehavior: 'smooth' }}>
        <div className="p-6">
          <div className="mx-auto max-w-4xl">
            <div className="bg-white rounded-xl shadow-lg border border-slate-200">
              {!editorInitialized && (
                <div className="absolute inset-0 bg-white bg-opacity-75 flex items-center justify-center z-10 rounded-xl">
                  <div className="text-center">
                    <div className="w-12 h-12 border-4 border-emerald-200 border-t-emerald-500 rounded-full animate-spin mx-auto"></div>
                    <p className="mt-3 text-slate-600">Initializing editor...</p>
                  </div>
                </div>
              )}
              <EditorContent
                editor={editor}
                className="prose max-w-none min-h-[500px] p-8 focus:outline-none"
              />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default NewDocumentEditor;

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\avatar.jsx
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"
import { cn } from "@/lib/utils"

const Avatar = React.forwardRef(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn("relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full", className)}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\badge.jsx
import * as React from "react"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Badge({
  className,
  variant,
  ...props
}) {
  return (<div className={cn(badgeVariants({ variant }), className)} {...props} />);
}

export { Badge, badgeVariants }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\button.jsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority"
import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Button = React.forwardRef(({ className, variant, size, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"
  return (
    <Comp
      className={cn(buttonVariants({ variant, size, className }))}
      ref={ref}
      {...props}
    />
  )
})
Button.displayName = "Button"

export { Button, buttonVariants }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\card.jsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("rounded-xl border bg-card text-card-foreground shadow", className)}
    {...props} />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props} />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("font-semibold leading-none tracking-tight", className)}
    {...props} />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props} />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\dialog.jsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props} />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef(({ className, children, hideCloseButton, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}>
      {children}
      {!hideCloseButton && (
        <DialogPrimitive.Close
          className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
          <X className="h-4 w-4" />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      )}
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col space-y-1.5 text-center sm:text-left", className)}
    {...props} />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props} />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold leading-none tracking-tight", className)}
    {...props} />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\dropdown-menu.jsx
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}>
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
      className
    )}
    {...props} />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-dropdown-menu-content-transform-origin]",
        className
      )}
      {...props} />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props} />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}>
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}>
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", inset && "pl-8", className)}
    {...props} />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props} />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props} />
  );
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\input.jsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props} />
  );
})
Input.displayName = "Input"

export { Input }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\label.jsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\separator.jsx
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef((
  { className, orientation = "horizontal", decorative = true, ...props },
  ref
) => (
  <SeparatorPrimitive.Root
    ref={ref}
    decorative={decorative}
    orientation={orientation}
    className={cn(
      "shrink-0 bg-border",
      orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
      className
    )}
    {...props} />
))
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\sheet.jsx
"use client";
import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva } from "class-variance-authority";
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref} />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500 data-[state=open]:animate-in data-[state=closed]:animate-out",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4 border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

const SheetContent = React.forwardRef(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content ref={ref} className={cn(sheetVariants({ side }), className)} {...props}>
      <SheetPrimitive.Close
        className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
      {children}
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col space-y-2 text-center sm:text-left", className)}
    {...props} />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}) => (
  <div
    className={cn("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2", className)}
    {...props} />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props} />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\skeleton.jsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props} />
  );
}

export { Skeleton }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\switch.jsx
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}>
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )} />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\textarea.jsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-base shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props} />
  );
})
Textarea.displayName = "Textarea"

export { Textarea }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\toast.jsx
"use client";
import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva } from "class-variance-authority";
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props} />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props} />
  );
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props} />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}>
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props} />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

export { ToastProvider, ToastViewport, Toast, ToastTitle, ToastDescription, ToastClose, ToastAction };


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ui\toaster.jsx
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\config\features.js
'use client';

/**
 * Feature Flag Configuration
 * Simplified version for new architecture only
 */

const isDevelopment = process.env.NODE_ENV === 'development';
const isProduction = process.env.NODE_ENV === 'production';

const getEnvFlag = (flagName, defaultValue) => {
  const envValue = process.env[`NEXT_PUBLIC_${flagName}`];
  if (envValue === 'true') return true;
  if (envValue === 'false') return false;
  return defaultValue;
};

export const FEATURES = {
  // === PERFORMANCE FEATURES ===

  /**
   * Enable incremental APA analysis
   * - 90% performance improvement
   * - Paragraph-level caching
   * - Smart invalidation
   */
  INCREMENTAL_ANALYSIS: getEnvFlag('INCREMENTAL_ANALYSIS', true),

  /**
   * Enable paragraph-level caching
   * - Massive performance gains
   * - Memory efficiency
   * - Smart cache management
   */
  PARAGRAPH_CACHING: getEnvFlag('PARAGRAPH_CACHING', true),

  /**
   * Enable real-time performance monitoring
   */
  PERFORMANCE_MONITORING: getEnvFlag('PERFORMANCE_MONITORING', isDevelopment),

  /**
   * Enable memory usage tracking
   */
  MEMORY_TRACKING: getEnvFlag('MEMORY_TRACKING', isDevelopment),

  /**
   * Enable analysis timing metrics
   */
  ANALYSIS_METRICS: getEnvFlag('ANALYSIS_METRICS', isDevelopment),

  // === DEVELOPMENT FEATURES ===

  /**
   * Enable debug information in UI
   */
  DEBUG_INFO: getEnvFlag('DEBUG_INFO', isDevelopment),

  /**
   * Enable verbose console logging
   */
  VERBOSE_LOGGING: getEnvFlag('VERBOSE_LOGGING', isDevelopment),

  /**
   * Enable state inspection tools
   */
  STATE_INSPECTOR: getEnvFlag('STATE_INSPECTOR', isDevelopment),

  /**
   * Enable performance profiling
   */
  PERFORMANCE_PROFILING: getEnvFlag('PERFORMANCE_PROFILING', false)
};

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\hooks\use-toast.js
"use client";
// Inspired by react-hot-toast library
import * as React from "react"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST"
}

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString();
}

const toastTimeouts = new Map()

const addToRemoveQueue = (toastId) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state, action) => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      };

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t),
      };

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t),
      };
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      };
  }
}

const listeners = []

let memoryState = { toasts: [] }

function dispatch(action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

function toast({
  ...props
}) {
  const id = genId()

  const update = (props) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    };
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId) => dispatch({ type: "DISMISS_TOAST", toastId }),
  };
}

export { useToast, toast }


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\hooks\useKeyboardShortcuts.js
'use client';

import { useEffect } from 'react';

export const useKeyboardShortcuts = (handleManualAnalysis) => {
  useEffect(() => {
    const handleKeyDown = (event) => {
      if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === 'C') {
        event.preventDefault();
        handleManualAnalysis();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleManualAnalysis]);
};

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\hooks\useTextReplacement.js
'use client';

import { useEffect, useCallback } from 'react';
import { useUnifiedDocumentStore } from '@/store/unifiedDocumentStore';

export const useTextReplacement = (editor, issues, activeIssueId, showIssueHighlighting) => {
  // Apply text replacement for fixes
  const applyTextReplacement = useCallback((originalText, replacementText) => {
    if (!editor || !originalText) return;

    if (process.env.NODE_ENV === 'development') {
      console.log('Applying text replacement:', { originalText, replacementText });
    }

    const { state } = editor;
    const { doc } = state;
    let replaced = false;

    doc.descendants((node, pos) => {
      if (!replaced) {
        if (node.isText) {
          const text = node.text;
          const index = text.indexOf(originalText);

          if (index !== -1) {
            const from = pos + index;
            const to = from + originalText.length;

            editor.chain()
              .focus()
              .setTextSelection({ from, to })
              .deleteSelection()
              .insertContent(replacementText)
              .run();

            replaced = true;
            if (process.env.NODE_ENV === 'development') {
              console.log('Text replaced at position:', from);
            }
          }
        } else if (node.type.name === 'paragraph' || node.type.name === 'heading') {
          const text = node.textContent;
          const index = text.indexOf(originalText);

          if (index !== -1) {
            const from = pos + index + 1;
            const to = from + originalText.length;

            editor.chain()
              .focus()
              .setTextSelection({ from, to })
              .deleteSelection()
              .insertContent(replacementText)
              .run();

            replaced = true;
            if (process.env.NODE_ENV === 'development') {
              console.log('Text replaced in block at position:', from);
            }
          }
        }
      }
    });

    if (replaced) {
      setTimeout(() => {
        editor.commands.updateIssueHighlights({
          issues: issues,
          activeIssueId: activeIssueId,
          showHighlighting: showIssueHighlighting
        });
      }, 100);
    } else if (process.env.NODE_ENV === 'development') {
      console.warn('Text not found for replacement:', originalText);
    }
  }, [editor, issues, activeIssueId, showIssueHighlighting]);

  // Listen for text replacement events using store event system
  useEffect(() => {
    const handleTextReplacement = (data) => {
      const { originalText, replacementText } = data;
      applyTextReplacement(originalText, replacementText);
    };

    const { events } = useUnifiedDocumentStore.getState();
    const cleanup = events.on('applyTextReplacement', handleTextReplacement);

    return cleanup;
  }, [applyTextReplacement]);

  return {
    applyTextReplacement
  };
};

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\hooks\useUnifiedDocumentEditor.js
'use client';

import { useEffect, useCallback, useRef, useState, useMemo } from 'react';
import { useEditor } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import { Underline } from '@tiptap/extension-underline';
import { FormattedParagraph, FontFormatting, DocumentDefaults } from '@/utils/tiptapFormattingExtensions';
import { IssueHighlighter } from '@/utils/tiptapIssueHighlighter';
import { useUnifiedDocumentStore } from '@/store/unifiedDocumentStore';
import { indexedDBManager } from '@/utils/indexedDBManager';

/**
 * Unified Document Editor Hook - Replaces useDocumentEditor.js
 * Provides bidirectional sync between DocumentModel and Tiptap editor
 */
export const useUnifiedDocumentEditor = () => {
  const {
    documentModel,
    getEditorContent,
    syncWithEditor,
    getIssues,
    uiState: { activeIssueId, showIssueHighlighting },
    setActiveIssue,
    editorState,
    scheduleIncrementalAnalysis,
    scheduleAutoSave,
    events
  } = useUnifiedDocumentStore();

  const [editorError, setEditorError] = useState(null);
  const [editorInitialized, setEditorInitialized] = useState(false);
  const [isSyncing, setIsSyncing] = useState(false);

  const lastContentRef = useRef(null);
  const syncTimeoutRef = useRef(null);
  const isInternalUpdateRef = useRef(false);
  const syncEditorFromModelRef = useRef(null);
  const indexedDBSaveTimeoutRef = useRef(null);

  // Get current issues
  const issues = getIssues();

  // Create stable issue signature to prevent infinite loops
  const issueSignature = useMemo(() => {
    return `${issues.length}-${issues.map(i => i.id).join(',').substring(0, 100)}`;
  }, [issues]);

  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        paragraph: false, // Use custom FormattedParagraph
        heading: {
          levels: [1, 2, 3, 4, 5, 6]
        }
      }),
      FormattedParagraph,
      FontFormatting,
      DocumentDefaults,
      Underline,
      IssueHighlighter.configure({
        issues: issues,
        activeIssueId: activeIssueId,
        showHighlighting: showIssueHighlighting,
        onIssueClick: (issueId) => setActiveIssue(issueId, { shouldScroll: false })
      })
    ],
    content: '<p>Loading document...</p>',
    immediatelyRender: false,
    editorProps: {
      attributes: {
        class: 'ProseMirror focus:outline-none min-h-[500px] p-4',
        spellcheck: 'false'
      }
    },
    onUpdate: ({ editor, transaction }) => {
      // Skip if this is an internal update (from sync)
      if (isInternalUpdateRef.current) {
        return;
      }

      try {
        const currentContent = editor.getJSON();

        // Check if content actually changed
        const contentString = JSON.stringify(currentContent);
        if (lastContentRef.current === contentString) {
          return;
        }

        lastContentRef.current = contentString;

        // Debounce sync to avoid excessive updates
        if (syncTimeoutRef.current) {
          clearTimeout(syncTimeoutRef.current);
        }

        syncTimeoutRef.current = setTimeout(() => {
          performSync(currentContent, transaction);
        }, 300); // 300ms debounce for responsive editing

      } catch (error) {
        console.error('Error in editor onUpdate:', error);
        setEditorError(error);
      }
    },
    onCreate: ({ editor }) => {
      try {
        if (process.env.NODE_ENV === 'development') {
          console.log('✅ Editor created successfully');
        }
        setEditorInitialized(true);
        setEditorError(null);

        // Sync with document model if available
        if (documentModel && editorState.needsSync) {
          syncEditorFromModel();
        }
      } catch (error) {
        console.error('Error in editor onCreate:', error);
        setEditorError(error);
      }
    },
    onError: ({ error }) => {
      console.error('Editor encountered an error:', error);
      setEditorError(error);
    }
  });

  /**
   * Save to IndexedDB (debounced for performance)
   * Provides reload safety - called on every edit
   */
  const saveToIndexedDB = useCallback(async (editorContent) => {
    if (!documentModel) {
      return;
    }

    // Clear existing timeout
    if (indexedDBSaveTimeoutRef.current) {
      clearTimeout(indexedDBSaveTimeoutRef.current);
    }

    // Debounce IndexedDB save (2-3 seconds)
    indexedDBSaveTimeoutRef.current = setTimeout(async () => {
      try {
        const documentId = documentModel.supabase.documentId || documentModel.id;

        const result = await indexedDBManager.saveToIndexedDB(
          documentId,
          editorContent,
          {
            version: documentModel.version,
            lastModified: Date.now()
          }
        );

        if (!result.success && result.shouldClearOld) {
          // Storage quota exceeded - clear old drafts
          console.warn('⚠️ IndexedDB quota exceeded, clearing old drafts...');
          await indexedDBManager.clearOldDrafts(7);

          // Retry save after clearing
          await indexedDBManager.saveToIndexedDB(documentId, editorContent, {
            version: documentModel.version,
            lastModified: Date.now()
          });
        }

      } catch (error) {
        console.error('❌ IndexedDB save failed:', error);
        // Don't throw - IndexedDB is for safety, not critical
      }
    }, 2500); // 2.5 second debounce

  }, [documentModel]);

  /**
   * Perform bidirectional sync with document model
   */
  const performSync = useCallback(async (editorContent, transaction = null) => {
    if (!documentModel || isSyncing) {
      return;
    }

    setIsSyncing(true);

    try {
      const changesMeta = {
        timestamp: Date.now(),
        userInitiated: true,
        transactionSteps: transaction?.steps?.length || 0
      };

      const result = syncWithEditor(editorContent, changesMeta);

      if (result.success) {
        // Schedule auto-save if there were changes
        if (result.hasChanges) {
          // LAYER 2: Save to IndexedDB for reload safety (2.5s debounce)
          saveToIndexedDB(editorContent);

          // LAYER 3: Schedule Supabase save for long-term storage (3s debounce)
          scheduleAutoSave(false, 3000); // immediate=false, debounceMs=3000
        }
      } else {
        console.warn('Sync failed:', result.error);
      }

    } catch (error) {
      console.error('Error during sync:', error);
      setEditorError(error);
    } finally {
      setIsSyncing(false);
    }
  }, [documentModel, syncWithEditor, isSyncing, scheduleAutoSave, saveToIndexedDB]);

  /**
   * Sync editor content from document model
   */
  const syncEditorFromModel = useCallback(async () => {
    if (!editor || !documentModel) {
      if (process.env.NODE_ENV === 'development') {
        console.warn('⚠️ Cannot sync: missing editor or document model', {
          hasEditor: !!editor,
          hasDocumentModel: !!documentModel
        });
      }
      return;
    }

    // If already syncing, wait and retry
    if (isSyncing) {
      if (process.env.NODE_ENV === 'development') {
        console.log('⏳ Sync in progress, queuing retry...');
      }
      setTimeout(() => syncEditorFromModelRef.current?.(), 200);
      return;
    }

    setIsSyncing(true);
    isInternalUpdateRef.current = true;

    try {
      const editorContent = getEditorContent();

      if (!editorContent) {
        console.warn('⚠️ No editor content from document model');
        return;
      }

      if (process.env.NODE_ENV === 'development') {
        console.log('📥 Syncing editor from document model...', {
          documentVersion: documentModel.version,
          paragraphCount: editorContent?.content?.length || 0
        });
      }

      // Update editor content without triggering onUpdate
      await new Promise(resolve => {
        setTimeout(() => {
          if (editor && !editor.isDestroyed) {
            editor.commands.setContent(editorContent, false, {
              preserveWhitespace: true
            });

            // Update issue highlights after content is set
            setTimeout(() => {
              if (editor && !editor.isDestroyed) {
                updateIssueHighlights();
              }
              resolve();
            }, 100);
          } else {
            resolve();
          }
        }, 50);
      });

      lastContentRef.current = JSON.stringify(editorContent);

      if (process.env.NODE_ENV === 'development') {
        console.log('✅ Editor synced from model');
      }

    } catch (error) {
      console.error('Error syncing editor from model:', error);
      setEditorError(error);
    } finally {
      isInternalUpdateRef.current = false;
      setIsSyncing(false);
    }
  }, [editor, documentModel, getEditorContent, isSyncing]);

  /**
   * Update issue highlights in editor
   */
  const updateIssueHighlights = useCallback(() => {
    if (!editor || !editor.commands.updateIssueHighlights) {
      return;
    }

    try {
      editor.commands.updateIssueHighlights({
        issues: issues,
        activeIssueId: activeIssueId,
        showHighlighting: showIssueHighlighting
      });

      if (process.env.NODE_ENV === 'development') {
        console.log(`🎨 Updated highlights for ${issues.length} issues`);
      }
    } catch (error) {
      console.error('Error updating issue highlights:', error);
    }
  }, [editor, issues, activeIssueId, showIssueHighlighting]);

  /**
   * Scroll to specific issue in editor
   * Uses the same search logic as tiptapIssueHighlighter for consistency
   */
  const scrollToIssue = useCallback((issueId) => {
    if (!editor || !issueId) {
      console.warn('scrollToIssue: Missing editor or issueId', { hasEditor: !!editor, issueId });
      return;
    }

    const issue = issues.find(i => i.id === issueId);
    if (!issue) {
      console.warn('scrollToIssue: Issue not found', { issueId, totalIssues: issues.length });
      return;
    }

    // Skip document-level issues without specific text
    if (issue.location?.type === 'document' && !issue.highlightText && !issue.text) {
      console.warn('scrollToIssue: Document-level issue without specific text', { issueId });
      return;
    }

    // Determine search text (same as highlighter)
    let searchText = issue.highlightText || issue.text || '';
    if (!searchText || searchText.length < 2) {
      console.warn('scrollToIssue: No valid search text', { issueId, searchText });
      return;
    }

    // Handle truncated text (same as highlighter)
    const isTruncated = searchText.endsWith('...');
    if (isTruncated) {
      searchText = searchText.slice(0, -3).trim();
    }

    if (process.env.NODE_ENV === 'development') {
      console.log('scrollToIssue: Searching for:', searchText.substring(0, 80), {
        paragraphIndex: issue.location?.paragraphIndex,
        isTruncated
      });
    }

    try {
      const { state } = editor;
      const { doc } = state;
      const positions = [];

      // Use same search strategy as highlighter
      if (issue.location?.paragraphIndex !== undefined) {
        // Search in specific paragraph
        let currentPara = 0;
        let found = false;

        doc.descendants((node, pos) => {
          if (found) return false;

          if (node.type.name === 'paragraph' || node.type.name === 'heading') {
            if (currentPara === issue.location.paragraphIndex) {
              const text = node.textContent;
              const index = text.indexOf(searchText);

              if (index !== -1) {
                const from = pos + 1 + index;
                const to = from + (isTruncated
                  ? Math.min(searchText.length + 20, text.length - index)
                  : searchText.length);
                positions.push({ from, to });
              }
              found = true;
              return false;
            }
            currentPara++;
          }
        });
      } else {
        // Search entire document
        doc.descendants((node, pos) => {
          if (node.isText) {
            const text = node.text;
            const index = text.indexOf(searchText);

            if (index !== -1) {
              const from = pos + index;
              const to = from + (isTruncated
                ? Math.min(searchText.length + 20, text.length - index)
                : searchText.length);
              positions.push({ from, to });
            }
          } else if (node.type.name === 'paragraph' || node.type.name === 'heading') {
            const text = node.textContent;
            if (text.includes(searchText)) {
              const index = text.indexOf(searchText);
              if (index !== -1) {
                const from = pos + 1 + index;
                const to = from + (isTruncated
                  ? Math.min(searchText.length + 20, text.length - index)
                  : searchText.length);
                positions.push({ from, to });
              }
            }
          }
        });
      }

      // Scroll to the first found position
      if (positions.length > 0) {
        const { from, to } = positions[0];

        if (process.env.NODE_ENV === 'development') {
          console.log('scrollToIssue: Found position', { from, to, totalMatches: positions.length });
        }

        editor.chain()
          .focus()
          .setTextSelection({ from, to })
          .scrollIntoView()
          .run();
      } else if (process.env.NODE_ENV === 'development') {
        console.warn('scrollToIssue: Text not found in document', {
          searchText: searchText.substring(0, 80),
          issueTitle: issue.title,
          issueCategory: issue.category,
          paragraphIndex: issue.location?.paragraphIndex
        });
      }
    } catch (error) {
      console.error('Error scrolling to issue:', error);
    }
  }, [editor, issues]);

  // Store syncEditorFromModel in ref for stable access in event handlers
  useEffect(() => {
    syncEditorFromModelRef.current = syncEditorFromModel;
  }, [syncEditorFromModel]);

  // === EFFECTS ===

  // Sync editor when document model changes
  useEffect(() => {
    if (editorInitialized && documentModel && editorState.needsSync) {
      syncEditorFromModel();
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [editorInitialized, documentModel, editorState.needsSync]);

  // Update issue highlights when issues change
  useEffect(() => {
    if (editorInitialized) {
      const timer = setTimeout(() => {
        updateIssueHighlights();
      }, 100);

      return () => clearTimeout(timer);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [editorInitialized, issueSignature, activeIssueId, showIssueHighlighting]);

  // Listen for active issue changes that should trigger scrolling
  useEffect(() => {
    const cleanup = events.on('activeIssueChanged', (data) => {
      if (data.shouldScroll && data.currentId && editorInitialized) {
        setTimeout(() => {
          scrollToIssue(data.currentId);
        }, 200);
      }
    });

    return cleanup;
  }, [events, editorInitialized, scrollToIssue]);

  // Listen for document restoration events
  useEffect(() => {
    const cleanup = events.on('documentRestored', (data) => {
      if (process.env.NODE_ENV === 'development') {
        console.log('📋 Document restored, syncing editor...', data.description);
      }

      // Sync editor from restored document
      setTimeout(() => {
        syncEditorFromModelRef.current?.();
      }, 100);
    });

    return cleanup;
  }, [events]);

  // Listen for fix application events
  useEffect(() => {
    const cleanup = events.on('fixApplied', (data) => {
      if (process.env.NODE_ENV === 'development') {
        console.log('🔧 Fix applied, syncing editor...', data.fixAction);
      }

      // Sync editor after fix application
      setTimeout(() => {
        syncEditorFromModelRef.current?.();
      }, 100);
    });

    return cleanup;
  }, [events]);

  // Listen for analysis completion to trigger highlighting
  useEffect(() => {
    const cleanup = events.on('analysisComplete', (data) => {
      if (process.env.NODE_ENV === 'development') {
        console.log('📊 Analysis complete, updating highlights...', data.issueCount, 'issues');
      }

      // Update highlights after analysis completes
      if (editorInitialized) {
        setTimeout(() => {
          updateIssueHighlights();
        }, 200);
      }
    });

    return cleanup;
  }, [events, editorInitialized, updateIssueHighlights]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (syncTimeoutRef.current) {
        clearTimeout(syncTimeoutRef.current);
      }
      if (indexedDBSaveTimeoutRef.current) {
        clearTimeout(indexedDBSaveTimeoutRef.current);
      }
    };
  }, []);

  // === MANUAL SYNC METHODS ===

  /**
   * Force sync editor to document model
   */
  const forceSync = useCallback(async () => {
    if (editor) {
      const currentContent = editor.getJSON();
      await performSync(currentContent);
    }
  }, [editor, performSync]);

  /**
   * Refresh editor from document model
   */
  const refreshFromModel = useCallback(async () => {
    syncEditorFromModelRef.current?.();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return {
    editor,
    editorError,
    setEditorError,
    editorInitialized,
    setEditorInitialized,
    isSyncing,
    scrollToIssue,
    forceSync,
    refreshFromModel,

    // Stats for debugging
    stats: {
      hasDocument: !!documentModel,
      documentVersion: documentModel?.version,
      issueCount: issues.length,
      lastSync: editorState.lastSyncTimestamp,
      needsSync: editorState.needsSync
    }
  };
};

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\lib\profiles.js
/**
 * Profile Data Helper Functions
 * Functions to fetch and update user profile data from the profiles table
 */

/**
 * Fetches user profile data from the profiles table
 * @param {Object} supabase - Supabase client instance
 * @param {string} userId - User ID to fetch profile for
 * @returns {Promise<Object>} Profile data or null
 */
export async function getUserProfile(supabase, userId) {
  const { data, error } = await supabase
    .from('profiles')
    .select('*')
    .eq('id', userId)
    .single();

  if (error) {
    console.error('Error fetching profile:', error);
    return null;
  }

  return data;
}

/**
 * Updates user profile data in the profiles table
 * @param {Object} supabase - Supabase client instance
 * @param {string} userId - User ID to update
 * @param {Object} updates - Object containing fields to update
 * @returns {Promise<Object>} Updated profile data or error
 */
export async function updateUserProfile(supabase, userId, updates) {
  const { data, error } = await supabase
    .from('profiles')
    .update({
      ...updates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', userId)
    .select()
    .single();

  if (error) {
    console.error('Error updating profile:', error);
    return { error };
  }

  return { data };
}

/**
 * Creates a new user profile (used when auto-creation fails)
 * @param {Object} supabase - Supabase client instance
 * @param {string} userId - User ID
 * @param {string} email - User email
 * @returns {Promise<Object>} Created profile data or error
 */
export async function createUserProfile(supabase, userId, email) {
  const { data, error } = await supabase
    .from('profiles')
    .insert({
      id: userId,
      email,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString(),
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating profile:', error);
    return { error };
  }

  return { data };
}

/**
 * Gets user with profile data (combines auth.users with profiles table)
 * @param {Object} supabase - Supabase client instance
 * @returns {Promise<Object>} Combined user and profile data
 */
export async function getUserWithProfile(supabase) {
  // First get the authenticated user
  const { data: { user }, error: authError } = await supabase.auth.getUser();

  if (authError || !user) {
    return { user: null, profile: null, error: authError };
  }

  // Then fetch their profile
  const profile = await getUserProfile(supabase, user.id);

  // If profile doesn't exist, try to create it
  if (!profile) {
    const { data: newProfile } = await createUserProfile(supabase, user.id, user.email);
    return { user, profile: newProfile, error: null };
  }

  return { user, profile, error: null };
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\lib\supabase\client.js
// src/lib/supabase/client.js - Browser-side Supabase client
import { createBrowserClient } from '@supabase/ssr';

/**
 * Create Supabase client for browser environment
 * Used in client components and browser-side logic
 */
export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\lib\supabase\server.js
// src/lib/supabase/server.js - Server-side Supabase client for Next.js
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';

/**
 * Create Supabase client for Next.js server components and API routes
 * Handles cookie management for authentication
 */
export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        get(name) {
          return cookieStore.get(name)?.value;
        },
        set(name, value, options) {
          try {
            cookieStore.set({ name, value, ...options });
          } catch (error) {
            // Handle cookie setting errors (can occur in middleware)
          }
        },
        remove(name, options) {
          try {
            cookieStore.set({ name, value: '', ...options });
          } catch (error) {
            // Handle cookie removal errors
          }
        },
      },
    }
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\lib\utils.js
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\middleware.js
// src/middleware.js - Route protection middleware
import { NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';

/**
 * Middleware to protect routes and handle authentication
 * Runs before every request to check user authentication status
 */
export async function middleware(request) {
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        get(name) {
          return request.cookies.get(name)?.value;
        },
        set(name, value, options) {
          request.cookies.set({
            name,
            value,
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({
            name,
            value,
            ...options,
          });
        },
        remove(name, options) {
          request.cookies.set({
            name,
            value: '',
            ...options,
          });
          response = NextResponse.next({
            request: {
              headers: request.headers,
            },
          });
          response.cookies.set({
            name,
            value: '',
            ...options,
          });
        },
      },
    }
  );

  // Get current user session
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Protected routes that require authentication
  const protectedPaths = ['/dashboard', '/document'];
  const isProtectedPath = protectedPaths.some((path) =>
    request.nextUrl.pathname.startsWith(path)
  );

  // Redirect to login if accessing protected route without authentication
  if (isProtectedPath && !user) {
    const url = request.nextUrl.clone();
    url.pathname = '/login';
    return NextResponse.redirect(url);
  }

  // Redirect to dashboard if accessing auth pages while authenticated
  const authPaths = ['/login', '/signup'];
  const isAuthPath = authPaths.some((path) =>
    request.nextUrl.pathname.startsWith(path)
  );

  if (isAuthPath && user) {
    const url = request.nextUrl.clone();
    url.pathname = '/dashboard';
    return NextResponse.redirect(url);
  }

  // All other routes (including home page '/') are public
  return response;
}

/**
 * Configure which routes the middleware should run on
 */
export const config = {
  matcher: [
    /*
     * Match all request paths except:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder
     * - api routes (handled separately)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
};


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\models\DocumentModel.js
'use client';

import { v4 as uuidv4 } from 'uuid';
import { ParagraphModel } from './ParagraphModel';

/**
 * Single source of truth for document state
 * Replaces fragmented state (documentText, documentHtml, editorContent, etc.)
 */
export class DocumentModel {
  constructor(originalDocx = null) {
    this.id = uuidv4();
    this.created = Date.now();
    this.lastModified = Date.now();
    this.version = 1;

    // Document buffers (compressed)
    this.originalBuffer = originalDocx;
    this.currentBuffer = originalDocx;
    this.isBufferCompressed = false;

    // Document metadata
    this.metadata = new DocumentMetadata();

    // Supabase integration metadata
    this.supabase = {
      documentId: null,
      filePath: null,
      userId: null
    };

    // Paragraph-based document structure (single source of truth)
    this.paragraphs = new Map(); // paragraph-id -> ParagraphModel
    this.paragraphOrder = []; // Maintains document order

    // Document-level formatting
    this.formatting = new FormattingModel();

    // Structure analysis (derived from paragraphs)
    this.structure = new StructureModel();

    // Document styles
    this.styles = new StylesModel();

    // Issue tracking
    this.issues = new IssueTracker();

    // Change tracking
    this.changeLog = new ChangeLog();

    // Statistics (derived)
    this._statsCache = null;
    this._statsCacheVersion = 0;
  }

  /**
   * Initialize from server document data (current upload response)
   */
  static fromServerData(documentData, originalBuffer = null) {
    const model = new DocumentModel(originalBuffer);

    // Set metadata
    model.metadata.name = documentData.processingInfo?.originalName || 'Document';
    model.metadata.fileSize = documentData.processingInfo?.fileSize || 0;
    model.metadata.processedAt = new Date(documentData.processingInfo?.timestamp || Date.now());
    model.metadata.processor = documentData.processingInfo?.processor || 'Unknown';

    // Set document-level formatting
    if (documentData.formatting) {
      model.formatting.initializeFromServer(documentData.formatting);
    }

    // Initialize paragraphs from server formatting data
    if (documentData.formatting?.paragraphs) {
      documentData.formatting.paragraphs.forEach((paraData, index) => {
        const paragraphModel = ParagraphModel.fromServerData(paraData, index);
        model.paragraphs.set(paragraphModel.id, paragraphModel);
        model.paragraphOrder.push(paragraphModel.id);
      });
    } else {
      // Fallback: create paragraphs from text
      const text = documentData.text || '';
      const paragraphs = text.split('\n');
      paragraphs.forEach((paraText, index) => {
        if (paraText.trim()) {
          const paragraphModel = ParagraphModel.fromText(paraText.trim(), index);
          model.paragraphs.set(paragraphModel.id, paragraphModel);
          model.paragraphOrder.push(paragraphModel.id);
        }
      });
    }

    // Set structure data
    if (documentData.structure) {
      model.structure.initializeFromServer(documentData.structure);
    }

    // Set styles
    if (documentData.styles) {
      model.styles.initializeFromServer(documentData.styles);
    }

    // Record creation in change log
    model.changeLog.recordChange({
      type: 'document-created',
      timestamp: Date.now(),
      description: 'Document initialized from server data',
      affectedParagraphs: model.paragraphOrder
    });

    return model;
  }

  /**
   * Get document as plain text (derived from paragraphs)
   */
  getPlainText() {
    return this.paragraphOrder
      .map(id => this.paragraphs.get(id))
      .filter(para => para && para.text)
      .map(para => para.text)
      .join('\n');
  }

  /**
   * Get document as HTML (derived from paragraphs with formatting)
   */
  getFormattedHtml() {
    let html = '<div class="docx-document">';

    this.paragraphOrder.forEach(id => {
      const paragraph = this.paragraphs.get(id);
      if (paragraph) {
        html += paragraph.toHtml();
      }
    });

    html += '</div>';
    return html;
  }

  /**
   * Get document as Tiptap JSON (for editor)
   */
  getTiptapJson() {
    const content = [];

    this.paragraphOrder.forEach((id, index) => {
      const paragraph = this.paragraphs.get(id);
      if (paragraph) {
        const node = paragraph.toTiptapNode();
        content.push(node);
      }
    });

    return {
      type: 'doc',
      content: content.length > 0 ? content : [{ type: 'paragraph', content: [{ type: 'text', text: ' ' }] }]
    };
  }

  /**
   * Update paragraph content (maintains single source of truth)
   */
  updateParagraph(paragraphId, changes) {
    const paragraph = this.paragraphs.get(paragraphId);
    if (!paragraph) {
      throw new Error(`Paragraph not found: ${paragraphId}`);
    }

    const oldText = paragraph.text;
    const updated = paragraph.update(changes);

    if (updated) {
      this.lastModified = Date.now();
      this.version++;
      this._invalidateStatsCache();

      // Record change
      this.changeLog.recordChange({
        type: 'paragraph-updated',
        paragraphId,
        timestamp: Date.now(),
        oldText,
        newText: paragraph.text,
        changes
      });

      // Update any issues affecting this paragraph
      this.issues.invalidateParagraphIssues(paragraphId);
    }

    return updated;
  }

  /**
   * Apply editor changes from Tiptap JSON
   */
  applyEditorChanges(tiptapDoc, changesMeta = {}) {
    if (!tiptapDoc || !tiptapDoc.content) {
      return false;
    }

    let hasChanges = false;
    const affectedParagraphs = new Set();

    // Process each paragraph in editor content
    tiptapDoc.content.forEach((node, index) => {
      if (node.type === 'paragraph') {
        // Find corresponding paragraph by position
        const paragraphId = this.paragraphOrder[index];

        if (paragraphId) {
          const paragraph = this.paragraphs.get(paragraphId);
          if (paragraph) {
            // Extract text from Tiptap node
            const editorText = this._extractTextFromTiptapNode(node);

            // Check if text has changed
            if (paragraph.text !== editorText) {
              paragraph.update({
                text: editorText,
                runs: this._extractRunsFromTiptapNode(node)
              });

              affectedParagraphs.add(paragraphId);
              hasChanges = true;
            }
          }
        } else {
          // New paragraph added in editor
          const newParagraph = ParagraphModel.fromTiptapNode(node, this.paragraphOrder.length);
          this.paragraphs.set(newParagraph.id, newParagraph);
          this.paragraphOrder.push(newParagraph.id);
          affectedParagraphs.add(newParagraph.id);
          hasChanges = true;
        }
      }
    });

    // Handle deleted paragraphs
    if (tiptapDoc.content.length < this.paragraphOrder.length) {
      const paragraphsToDelete = this.paragraphOrder.slice(tiptapDoc.content.length);
      paragraphsToDelete.forEach(id => {
        this.paragraphs.delete(id);
        affectedParagraphs.add(id);
      });
      this.paragraphOrder = this.paragraphOrder.slice(0, tiptapDoc.content.length);
      hasChanges = true;
    }

    if (hasChanges) {
      this.lastModified = Date.now();
      this.version++;
      this._invalidateStatsCache();

      // Record editor changes
      this.changeLog.recordChange({
        type: 'editor-sync',
        timestamp: Date.now(),
        affectedParagraphs: Array.from(affectedParagraphs),
        changesMeta
      });

      // Invalidate issues for affected paragraphs
      affectedParagraphs.forEach(id => {
        this.issues.invalidateParagraphIssues(id);
      });
    }

    return hasChanges;
  }

  /**
   * Get document statistics (cached)
   */
  getStatistics() {
    if (this._statsCache && this._statsCacheVersion === this.version) {
      return this._statsCache;
    }

    let wordCount = 0;
    let charCount = 0;
    let paragraphCount = 0;

    this.paragraphOrder.forEach(id => {
      const paragraph = this.paragraphs.get(id);
      if (paragraph && paragraph.text.trim()) {
        const words = paragraph.text.trim().split(/\s+/).filter(Boolean);
        wordCount += words.length;
        charCount += paragraph.text.length;
        paragraphCount++;
      }
    });

    this._statsCache = {
      wordCount,
      charCount,
      paragraphCount,
      lastModified: this.lastModified,
      version: this.version
    };
    this._statsCacheVersion = this.version;

    return this._statsCache;
  }

  /**
   * Get paragraphs that have changed since last analysis
   */
  getChangedParagraphs(sinceTimestamp = 0) {
    return this.paragraphOrder
      .map(id => this.paragraphs.get(id))
      .filter(para => para && para.lastModified > sinceTimestamp);
  }

  /**
   * Create a snapshot for undo functionality
   */
  createSnapshot() {
    return {
      id: uuidv4(),
      timestamp: Date.now(),
      version: this.version,
      paragraphs: new Map(this.paragraphs), // Shallow copy of paragraphs map
      paragraphOrder: [...this.paragraphOrder],
      formatting: this.formatting.clone(),
      issues: this.issues.clone(),
      description: `Snapshot at version ${this.version}`
    };
  }

  /**
   * Restore from snapshot
   */
  restoreFromSnapshot(snapshot) {
    this.paragraphs = new Map(snapshot.paragraphs);
    this.paragraphOrder = [...snapshot.paragraphOrder];
    this.formatting = snapshot.formatting.clone();
    this.issues = snapshot.issues.clone();
    this.version = snapshot.version + 1; // Increment version for restore
    this.lastModified = Date.now();
    this._invalidateStatsCache();

    this.changeLog.recordChange({
      type: 'snapshot-restored',
      timestamp: Date.now(),
      snapshotId: snapshot.id,
      description: snapshot.description
    });
  }

  // Private helper methods
  _extractTextFromTiptapNode(node) {
    if (!node.content) return '';
    return node.content.map(child => child.text || '').join('');
  }

  _extractRunsFromTiptapNode(node) {
    if (!node.content) return [];

    return node.content.map((textNode, index) => {
      const run = {
        index,
        text: textNode.text || '',
        font: {}
      };

      if (textNode.marks) {
        textNode.marks.forEach(mark => {
          switch (mark.type) {
            case 'bold':
              run.font.bold = true;
              break;
            case 'italic':
              run.font.italic = true;
              break;
            case 'underline':
              run.font.underline = true;
              break;
            case 'fontFormatting':
              if (mark.attrs.fontFamily) run.font.family = mark.attrs.fontFamily;
              if (mark.attrs.fontSize) run.font.size = parseFloat(mark.attrs.fontSize);
              if (mark.attrs.color) run.color = mark.attrs.color;
              break;
          }
        });
      }

      return run;
    });
  }

  _invalidateStatsCache() {
    this._statsCache = null;
    this._statsCacheVersion = 0;
  }
}

/**
 * Document metadata
 */
export class DocumentMetadata {
  constructor() {
    this.name = '';
    this.fileSize = 0;
    this.uploadedAt = null;
    this.processedAt = null;
    this.processor = '';
    this.originalFormat = 'docx';
  }
}

/**
 * Document-level formatting model
 */
export class FormattingModel {
  constructor() {
    this.document = {
      font: { family: null, size: null },
      spacing: { line: null, paragraph: null },
      margins: { top: null, bottom: null, left: null, right: null },
      indentation: { firstLine: null, hanging: null }
    };
    this.compliance = null;
  }

  initializeFromServer(serverFormatting) {
    if (serverFormatting.document) {
      this.document = {
        font: serverFormatting.document.font || this.document.font,
        spacing: serverFormatting.document.spacing || this.document.spacing,
        margins: serverFormatting.document.margins || this.document.margins,
        indentation: serverFormatting.document.indentation || this.document.indentation
      };
    }

    if (serverFormatting.compliance) {
      this.compliance = serverFormatting.compliance;
    }
  }

  clone() {
    const cloned = new FormattingModel();
    cloned.document = JSON.parse(JSON.stringify(this.document));
    cloned.compliance = this.compliance ? JSON.parse(JSON.stringify(this.compliance)) : null;
    return cloned;
  }
}

/**
 * Document structure model
 */
export class StructureModel {
  constructor() {
    this.headings = [];
    this.sections = [];
    this.citations = [];
    this.references = [];
    this.tables = [];
    this.italicizedText = [];
    this.headersFooters = null;
  }

  initializeFromServer(serverStructure) {
    this.headings = serverStructure.headings || [];
    this.sections = serverStructure.sections || [];
    this.citations = serverStructure.citations || [];
    this.references = serverStructure.references || [];
    this.tables = serverStructure.tables || [];
    this.italicizedText = serverStructure.italicizedText || [];
    this.headersFooters = serverStructure.headersFooters || null;
  }
}

/**
 * Document styles model
 */
export class StylesModel {
  constructor() {
    this.styles = [];
    this.defaultStyle = null;
  }

  initializeFromServer(serverStyles) {
    this.styles = serverStyles.styles || [];
    this.defaultStyle = serverStyles.defaultStyle || null;
  }
}

/**
 * Change log for tracking document modifications
 */
export class ChangeLog {
  constructor() {
    this.changes = [];
    this.maxEntries = 100; // Keep last 100 changes
  }

  recordChange(change) {
    this.changes.unshift({
      id: uuidv4(),
      ...change
    });

    // Trim to max entries
    if (this.changes.length > this.maxEntries) {
      this.changes = this.changes.slice(0, this.maxEntries);
    }
  }

  getChanges(sinceTimestamp = 0) {
    return this.changes.filter(change => change.timestamp > sinceTimestamp);
  }

  getLastChange() {
    return this.changes[0] || null;
  }
}

/**
 * Issue tracking with paragraph association
 */
export class IssueTracker {
  constructor() {
    this.issues = new Map(); // issue-id -> Issue
    this.paragraphIssues = new Map(); // paragraph-id -> Set<issue-id>
    this.lastAnalysisTimestamp = 0;
  }

  addIssue(issue, paragraphId = null) {
    this.issues.set(issue.id, issue);

    if (paragraphId) {
      if (!this.paragraphIssues.has(paragraphId)) {
        this.paragraphIssues.set(paragraphId, new Set());
      }
      this.paragraphIssues.get(paragraphId).add(issue.id);
    }
  }

  removeIssue(issueId) {
    const issue = this.issues.get(issueId);
    if (issue) {
      this.issues.delete(issueId);

      // Remove from paragraph associations
      for (const [paragraphId, issueSet] of this.paragraphIssues) {
        issueSet.delete(issueId);
        if (issueSet.size === 0) {
          this.paragraphIssues.delete(paragraphId);
        }
      }
    }
  }

  getIssuesForParagraph(paragraphId) {
    const issueIds = this.paragraphIssues.get(paragraphId) || new Set();
    return Array.from(issueIds).map(id => this.issues.get(id)).filter(Boolean);
  }

  invalidateParagraphIssues(paragraphId) {
    const issueIds = this.paragraphIssues.get(paragraphId) || new Set();
    Array.from(issueIds).forEach(issueId => {
      const issue = this.issues.get(issueId);
      if (issue) {
        issue.needsReanalysis = true;
      }
    });
  }

  getAllIssues() {
    return Array.from(this.issues.values());
  }

  getIssueStats() {
    const allIssues = this.getAllIssues();
    return {
      total: allIssues.length,
      critical: allIssues.filter(i => i.severity === 'Critical').length,
      major: allIssues.filter(i => i.severity === 'Major').length,
      minor: allIssues.filter(i => i.severity === 'Minor').length
    };
  }

  clone() {
    const cloned = new IssueTracker();
    cloned.issues = new Map(this.issues);
    cloned.paragraphIssues = new Map();

    // Deep clone paragraph issues
    for (const [paragraphId, issueSet] of this.paragraphIssues) {
      cloned.paragraphIssues.set(paragraphId, new Set(issueSet));
    }

    cloned.lastAnalysisTimestamp = this.lastAnalysisTimestamp;
    return cloned;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\models\ParagraphModel.js
'use client';

import { v4 as uuidv4 } from 'uuid';

/**
 * Immutable paragraph representation - single source of truth for paragraph content
 * Tracks text, formatting, runs, and issues at the paragraph level
 */
export class ParagraphModel {
  constructor(id = null) {
    this.id = id || uuidv4();
    this.text = '';
    this.index = 0; // Position in document
    this.lastModified = Date.now();
    this.changeSequence = 0;

    // Formatting attributes
    this.formatting = {
      font: { family: null, size: null, bold: false, italic: false, underline: false },
      spacing: { line: null, before: null, after: null },
      indentation: { firstLine: null, left: null, right: null, hanging: null },
      alignment: null,
      styleName: null
    };

    // Text runs (inline formatting)
    this.runs = new Map(); // run-id -> RunModel
    this.runOrder = []; // Maintains run order

    // Issues associated with this paragraph
    this.issues = new Set(); // issue-ids

    // Original server data for reference
    this.originalData = null;
  }

  /**
   * Create from server paragraph data
   */
  static fromServerData(serverParagraph, index = 0) {
    const paragraph = new ParagraphModel();
    paragraph.index = index;
    paragraph.text = serverParagraph.text || '';
    paragraph.originalData = serverParagraph;

    // Extract formatting
    if (serverParagraph.font) {
      paragraph.formatting.font = {
        family: serverParagraph.font.family || null,
        size: serverParagraph.font.size || null,
        bold: serverParagraph.font.bold || false,
        italic: serverParagraph.font.italic || false,
        underline: serverParagraph.font.underline || false
      };
    }

    if (serverParagraph.spacing) {
      paragraph.formatting.spacing = {
        line: serverParagraph.spacing.line || null,
        before: serverParagraph.spacing.before || null,
        after: serverParagraph.spacing.after || null
      };
    }

    if (serverParagraph.indentation) {
      paragraph.formatting.indentation = {
        firstLine: serverParagraph.indentation.firstLine || null,
        left: serverParagraph.indentation.left || null,
        right: serverParagraph.indentation.right || null,
        hanging: serverParagraph.indentation.hanging || null
      };
    }

    if (serverParagraph.alignment) {
      paragraph.formatting.alignment = serverParagraph.alignment;
    }

    if (serverParagraph.style) {
      paragraph.formatting.styleName = serverParagraph.style;
    }

    // Process runs (inline formatting)
    if (serverParagraph.runs && Array.isArray(serverParagraph.runs)) {
      serverParagraph.runs.forEach((runData, runIndex) => {
        if (runData.text && runData.text.length > 0) {
          const runModel = RunModel.fromServerData(runData, runIndex);
          paragraph.runs.set(runModel.id, runModel);
          paragraph.runOrder.push(runModel.id);
        }
      });
    } else if (paragraph.text) {
      // Create a single run from paragraph text
      const runModel = RunModel.fromText(paragraph.text, 0, paragraph.formatting.font);
      paragraph.runs.set(runModel.id, runModel);
      paragraph.runOrder.push(runModel.id);
    }

    return paragraph;
  }

  /**
   * Create from plain text
   */
  static fromText(text, index = 0, formatting = null) {
    const paragraph = new ParagraphModel();
    paragraph.index = index;
    paragraph.text = text;

    if (formatting) {
      paragraph.formatting = { ...paragraph.formatting, ...formatting };
    }

    // Create single run
    const runModel = RunModel.fromText(text, 0, paragraph.formatting.font);
    paragraph.runs.set(runModel.id, runModel);
    paragraph.runOrder.push(runModel.id);

    return paragraph;
  }

  /**
   * Create from Tiptap node
   */
  static fromTiptapNode(tiptapNode, index = 0) {
    const paragraph = new ParagraphModel();
    paragraph.index = index;

    // Extract attributes from Tiptap node
    if (tiptapNode.attrs) {
      const attrs = tiptapNode.attrs;

      if (attrs.lineHeight) paragraph.formatting.spacing.line = attrs.lineHeight;
      if (attrs.spaceBefore) paragraph.formatting.spacing.before = attrs.spaceBefore;
      if (attrs.spaceAfter) paragraph.formatting.spacing.after = attrs.spaceAfter;
      if (attrs.firstLineIndent) paragraph.formatting.indentation.firstLine = attrs.firstLineIndent;
      if (attrs.leftIndent) paragraph.formatting.indentation.left = attrs.leftIndent;
      if (attrs.rightIndent) paragraph.formatting.indentation.right = attrs.rightIndent;
      if (attrs.hangingIndent) paragraph.formatting.indentation.hanging = attrs.hangingIndent;
      if (attrs.textAlign) paragraph.formatting.alignment = attrs.textAlign;
      if (attrs.styleName) paragraph.formatting.styleName = attrs.styleName;
    }

    // Process content (text nodes with marks)
    if (tiptapNode.content && Array.isArray(tiptapNode.content)) {
      let textParts = [];

      tiptapNode.content.forEach((textNode, runIndex) => {
        if (textNode.type === 'text' && textNode.text) {
          textParts.push(textNode.text);

          // Create run with formatting from marks
          const runModel = RunModel.fromTiptapTextNode(textNode, runIndex);
          paragraph.runs.set(runModel.id, runModel);
          paragraph.runOrder.push(runModel.id);
        }
      });

      paragraph.text = textParts.join('');
    }

    return paragraph;
  }

  /**
   * Update paragraph content and formatting
   */
  update(changes) {
    let hasChanges = false;
    const oldVersion = this.changeSequence;

    // Update text
    if (changes.text !== undefined && changes.text !== this.text) {
      this.text = changes.text;
      hasChanges = true;

      // CRITICAL FIX: When text changes without explicit runs, regenerate runs
      // Otherwise toTiptapNode() will use old run text
      if (!changes.runs) {
        // Preserve existing formatting from first run
        const firstRun = this.runs.size > 0 ? Array.from(this.runs.values())[0] : null;
        const formatting = firstRun ? {
          font: firstRun.font,
          color: firstRun.color
        } : {};

        this.runs.clear();
        this.runOrder = [];

        const newRun = RunModel.fromData({
          text: changes.text,
          ...formatting
        }, 0);

        this.runs.set(newRun.id, newRun);
        this.runOrder.push(newRun.id);
      }
    }

    // Update formatting
    if (changes.formatting) {
      const newFormatting = { ...this.formatting, ...changes.formatting };
      if (JSON.stringify(newFormatting) !== JSON.stringify(this.formatting)) {
        this.formatting = newFormatting;
        hasChanges = true;
      }
    }

    // Update runs
    if (changes.runs) {
      this.runs.clear();
      this.runOrder = [];

      changes.runs.forEach((runData, index) => {
        const runModel = RunModel.fromData(runData, index);
        this.runs.set(runModel.id, runModel);
        this.runOrder.push(runModel.id);
      });

      hasChanges = true;
    }

    // Update index if provided
    if (changes.index !== undefined && changes.index !== this.index) {
      this.index = changes.index;
      hasChanges = true;
    }

    if (hasChanges) {
      this.lastModified = Date.now();
      this.changeSequence++;
    }

    return hasChanges;
  }

  /**
   * Get plain text content
   */
  getPlainText() {
    return this.text;
  }

  /**
   * Convert to HTML representation
   */
  toHtml() {
    const styles = [];

    // Apply paragraph-level formatting
    if (this.formatting.spacing.line) {
      styles.push(`line-height: ${this.formatting.spacing.line}`);
    }
    if (this.formatting.spacing.before) {
      styles.push(`margin-top: ${this.formatting.spacing.before}pt`);
    }
    if (this.formatting.spacing.after) {
      styles.push(`margin-bottom: ${this.formatting.spacing.after}pt`);
    }
    if (this.formatting.indentation.firstLine) {
      styles.push(`text-indent: ${this.formatting.indentation.firstLine}in`);
    }
    if (this.formatting.indentation.left) {
      styles.push(`padding-left: ${this.formatting.indentation.left}in`);
    }
    if (this.formatting.indentation.right) {
      styles.push(`padding-right: ${this.formatting.indentation.right}in`);
    }
    if (this.formatting.indentation.hanging) {
      styles.push(`text-indent: -${this.formatting.indentation.hanging}in`);
      styles.push(`padding-left: ${this.formatting.indentation.hanging}in`);
    }
    if (this.formatting.alignment) {
      styles.push(`text-align: ${this.formatting.alignment}`);
    }

    // Build content from runs
    let content = '';
    this.runOrder.forEach(runId => {
      const run = this.runs.get(runId);
      if (run) {
        content += run.toHtml();
      }
    });

    return `<p${styles.length > 0 ? ` style="${styles.join('; ')}"` : ''}${
      this.formatting.styleName ? ` data-style-name="${this.formatting.styleName}"` : ''
    }>${content || this.text}</p>`;
  }

  /**
   * Convert to Tiptap node representation
   */
  toTiptapNode() {
    const attrs = {};

    // Map formatting to Tiptap attributes
    if (this.formatting.spacing.line) attrs.lineHeight = this.formatting.spacing.line;
    if (this.formatting.spacing.before) attrs.spaceBefore = `${this.formatting.spacing.before}pt`;
    if (this.formatting.spacing.after) attrs.spaceAfter = `${this.formatting.spacing.after}pt`;
    if (this.formatting.indentation.firstLine) attrs.firstLineIndent = `${this.formatting.indentation.firstLine}in`;
    if (this.formatting.indentation.left) attrs.leftIndent = `${this.formatting.indentation.left}in`;
    if (this.formatting.indentation.right) attrs.rightIndent = `${this.formatting.indentation.right}in`;
    if (this.formatting.indentation.hanging) attrs.hangingIndent = `${this.formatting.indentation.hanging}in`;
    if (this.formatting.alignment) attrs.textAlign = this.formatting.alignment;
    if (this.formatting.styleName) attrs.styleName = this.formatting.styleName;

    // Store original formatting for preservation
    attrs.originalFormatting = this.originalData;

    // Build content from runs
    const content = [];
    this.runOrder.forEach(runId => {
      const run = this.runs.get(runId);
      if (run) {
        const tiptapTextNode = run.toTiptapTextNode();
        if (tiptapTextNode) {
          content.push(tiptapTextNode);
        }
      }
    });

    // Fallback if no runs
    if (content.length === 0 && this.text) {
      content.push({ type: 'text', text: this.text });
    }

    return {
      type: 'paragraph',
      attrs: Object.keys(attrs).length > 0 ? attrs : undefined,
      content: content.length > 0 ? content : [{ type: 'text', text: ' ' }]
    };
  }

  /**
   * Check if paragraph has changed since given timestamp
   */
  hasChangedSince(timestamp) {
    return this.lastModified > timestamp;
  }

  /**
   * Get paragraph statistics
   */
  getStatistics() {
    const words = this.text.trim().split(/\s+/).filter(Boolean);
    return {
      characters: this.text.length,
      charactersNoSpaces: this.text.replace(/\s/g, '').length,
      words: words.length,
      sentences: this.text.split(/[.!?]+/).filter(s => s.trim()).length,
      runs: this.runs.size
    };
  }

  /**
   * Clone paragraph
   */
  clone() {
    const cloned = new ParagraphModel();
    cloned.id = uuidv4(); // New ID for clone
    cloned.text = this.text;
    cloned.index = this.index;
    cloned.formatting = JSON.parse(JSON.stringify(this.formatting));
    cloned.originalData = this.originalData;

    // Clone runs
    this.runOrder.forEach(runId => {
      const run = this.runs.get(runId);
      if (run) {
        const clonedRun = run.clone();
        cloned.runs.set(clonedRun.id, clonedRun);
        cloned.runOrder.push(clonedRun.id);
      }
    });

    // Copy issues
    cloned.issues = new Set(this.issues);

    return cloned;
  }
}

/**
 * Text run model - represents inline formatting within a paragraph
 */
export class RunModel {
  constructor(id = null) {
    this.id = id || uuidv4();
    this.text = '';
    this.index = 0; // Position within paragraph

    this.font = {
      family: null,
      size: null,
      bold: false,
      italic: false,
      underline: false
    };

    this.color = null;
    this.highlight = null;
  }

  /**
   * Create from server run data
   */
  static fromServerData(serverRun, index = 0) {
    const run = new RunModel();
    run.index = index;
    run.text = serverRun.text || '';

    if (serverRun.font) {
      run.font = {
        family: serverRun.font.family || null,
        size: serverRun.font.size || null,
        bold: serverRun.font.bold || false,
        italic: serverRun.font.italic || false,
        underline: serverRun.font.underline || false
      };
    }

    if (serverRun.color) {
      run.color = serverRun.color;
    }

    if (serverRun.highlight) {
      run.highlight = serverRun.highlight;
    }

    return run;
  }

  /**
   * Create from plain text with formatting
   */
  static fromText(text, index = 0, font = null) {
    const run = new RunModel();
    run.index = index;
    run.text = text;

    if (font) {
      run.font = { ...run.font, ...font };
    }

    return run;
  }

  /**
   * Create from general data
   */
  static fromData(runData, index = 0) {
    const run = new RunModel();
    run.index = index;
    run.text = runData.text || '';

    if (runData.font) {
      run.font = { ...run.font, ...runData.font };
    }

    if (runData.color) {
      run.color = runData.color;
    }

    return run;
  }

  /**
   * Create from Tiptap text node
   */
  static fromTiptapTextNode(textNode, index = 0) {
    const run = new RunModel();
    run.index = index;
    run.text = textNode.text || '';

    // Process marks
    if (textNode.marks) {
      textNode.marks.forEach(mark => {
        switch (mark.type) {
          case 'bold':
            run.font.bold = true;
            break;
          case 'italic':
            run.font.italic = true;
            break;
          case 'underline':
            run.font.underline = true;
            break;
          case 'fontFormatting':
            if (mark.attrs.fontFamily) run.font.family = mark.attrs.fontFamily;
            if (mark.attrs.fontSize) {
              const size = parseFloat(mark.attrs.fontSize);
              if (!isNaN(size)) run.font.size = size;
            }
            if (mark.attrs.color) run.color = mark.attrs.color;
            break;
        }
      });
    }

    return run;
  }

  /**
   * Convert to HTML
   */
  toHtml() {
    if (!this.text) return '';

    const styles = [];
    const tags = [];

    // Font formatting
    if (this.font.family) {
      styles.push(`font-family: "${this.font.family}"`);
    }
    if (this.font.size) {
      styles.push(`font-size: ${this.font.size}pt`);
    }
    if (this.color) {
      styles.push(`color: ${this.color}`);
    }

    // Text formatting
    if (this.font.bold) tags.push('strong');
    if (this.font.italic) tags.push('em');
    if (this.font.underline) tags.push('u');

    let html = this.text;

    // Apply style tags
    tags.forEach(tag => {
      html = `<${tag}>${html}</${tag}>`;
    });

    // Apply span with styles if needed
    if (styles.length > 0) {
      html = `<span style="${styles.join('; ')}">${html}</span>`;
    }

    return html;
  }

  /**
   * Convert to Tiptap text node
   */
  toTiptapTextNode() {
    if (!this.text) return null;

    const textNode = {
      type: 'text',
      text: this.text
    };

    const marks = [];

    // Add formatting marks
    if (this.font.bold) marks.push({ type: 'bold' });
    if (this.font.italic) marks.push({ type: 'italic' });
    if (this.font.underline) marks.push({ type: 'underline' });

    // Add font formatting mark if needed
    const fontAttrs = {};
    if (this.font.family) fontAttrs.fontFamily = this.font.family;
    if (this.font.size) fontAttrs.fontSize = `${this.font.size}pt`;
    if (this.color) fontAttrs.color = this.color;

    if (Object.keys(fontAttrs).length > 0) {
      marks.push({
        type: 'fontFormatting',
        attrs: fontAttrs
      });
    }

    if (marks.length > 0) {
      textNode.marks = marks;
    }

    return textNode;
  }

  /**
   * Clone run
   */
  clone() {
    const cloned = new RunModel();
    cloned.id = uuidv4(); // New ID for clone
    cloned.text = this.text;
    cloned.index = this.index;
    cloned.font = { ...this.font };
    cloned.color = this.color;
    cloned.highlight = this.highlight;
    return cloned;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\services\DocumentService.js
'use client';

import { DocumentModel } from '@/models/DocumentModel';
import { ParagraphModel } from '@/models/ParagraphModel';
import { IncrementalAPAAnalyzer } from '@/utils/IncrementalAPAAnalyzer';
import { EnhancedAPAAnalyzer } from '@/utils/enhancedApaAnalyzer';
import { FEATURES } from '@/config/features';

/**
 * DocumentService - CRUD operations and business logic for DocumentModel
 * Replaces fragmented store operations with unified document operations
 */
export class DocumentService {
  constructor() {
    // Use incremental analyzer for 90% performance improvement
    this.apaAnalyzer = FEATURES.INCREMENTAL_ANALYSIS ?
      new IncrementalAPAAnalyzer() :
      new EnhancedAPAAnalyzer();

    this.compressionUtils = new CompressionUtils();
    this.serverBaseUrl = process.env.NODE_ENV === 'development' ? 'http://localhost:3001' : '';

    if (process.env.NODE_ENV === 'development') {
      console.log(`📊 DocumentService initialized with ${FEATURES.INCREMENTAL_ANALYSIS ? 'Incremental' : 'Enhanced'} APA Analyzer`);
    }
  }

  /**
   * Load document from server upload response
   */
  async loadDocument(file) {
    if (!file) {
      throw new Error('No file provided');
    }

    // Validate file
    if (!file.name.toLowerCase().endsWith('.docx')) {
      throw new Error('Please upload a .docx file only');
    }

    if (file.size > 10 * 1024 * 1024) { // 10MB
      throw new Error('File size must be less than 10MB');
    }

    // Prepare file buffer for compression
    const fileBuffer = await file.arrayBuffer();
    const uint8Array = new Uint8Array(fileBuffer);
    const compressedBuffer = await this.compressionUtils.compressBuffer(uint8Array);

    // Upload and process on server
    const formData = new FormData();
    formData.append('document', file);

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 120000); // 2 minute timeout

    try {
      const response = await fetch(`${this.serverBaseUrl}/api/upload-docx`, {
        method: 'POST',
        body: formData,
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorData = await this._handleApiError(response);
        throw new Error(errorData.message || 'Server processing failed');
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Server processing failed');
      }

      // Validate server response
      const { document: documentData } = result;
      if (!documentData.html || !documentData.text) {
        throw new Error('Server returned incomplete document data');
      }

      // Create DocumentModel from server data
      const documentModel = DocumentModel.fromServerData(documentData, compressedBuffer);

      return {
        success: true,
        documentModel,
        stats: documentModel.getStatistics(),
        metadata: {
          originalName: file.name,
          fileSize: file.size,
          uploadedAt: new Date(),
          processingTime: documentData.processingInfo?.processingTime || 0
        }
      };

    } catch (error) {
      clearTimeout(timeoutId);

      if (error.name === 'AbortError') {
        throw new Error('Upload timeout - please try with a smaller file');
      }

      throw error;
    }
  }

  /**
   * Perform incremental APA analysis on document
   */
  async analyzeDocument(documentModel, options = {}) {
    const {
      force = false,
      changedParagraphs = null,
      preserveUnchanged = true
    } = options;

    if (!documentModel) {
      throw new Error('No document model provided');
    }

    const startTime = Date.now();
    let analysisResults;

    if (changedParagraphs && changedParagraphs.length > 0 && preserveUnchanged) {
      // Incremental analysis - only analyze changed paragraphs
      analysisResults = await this._performIncrementalAnalysis(documentModel, changedParagraphs);
    } else {
      // Full analysis
      analysisResults = await this._performFullAnalysis(documentModel);
    }

    const analysisTime = Date.now() - startTime;

    // Update document model with new issues
    this._updateDocumentIssues(documentModel, analysisResults);

    // Calculate compliance score
    const score = this._calculateComplianceScore(analysisResults.issues);

    return {
      success: true,
      issues: analysisResults.issues,
      issueCount: analysisResults.issues.length,
      analysisScore: score,
      analysisTime,
      analysisType: changedParagraphs ? 'incremental' : 'full',
      affectedParagraphs: changedParagraphs ? changedParagraphs.map(p => p.id) : documentModel.paragraphOrder
    };
  }

  /**
   * Apply fix to document (JSON-First Architecture)
   */
  async applyFix(documentModel, issueId) {
    if (!documentModel || !issueId) {
      throw new Error('Document model and issue ID required');
    }

    const issue = documentModel.issues.issues.get(issueId);
    if (!issue) {
      throw new Error(`Issue not found: ${issueId}`);
    }

    if (!issue.hasFix) {
      throw new Error(`Issue ${issueId} cannot be automatically fixed`);
    }

    // Create snapshot for undo
    const snapshot = documentModel.createSnapshot();

    try {
      let fixResult;

      // Route to appropriate fix handler based on type
      if (this._isTextFix(issue.fixAction)) {
        // Text fixes: client-side JSON mutation (instant)
        console.log('🔧 Applying text fix (client-side):', issue.fixAction);
        fixResult = this._applyTextFixToJSON(documentModel, issue);
      }
      else if (this._isFormattingFix(issue.fixAction)) {
        // Formatting fixes: client-side JSON property update (instant)
        console.log('🎨 Applying formatting fix (client-side):', issue.fixAction);
        fixResult = this._applyFormattingFixToJSON(documentModel, issue);
      }
      else {
        // Fallback to server for unsupported fix types (legacy)
        console.warn('⚠️ Using server-side fix (legacy):', issue.fixAction);
        fixResult = await this._applyServerFormattingFix(documentModel, issue);
      }

      if (fixResult.success) {
        // Remove fixed issue
        documentModel.issues.removeIssue(issueId);

        // Record fix application
        documentModel.changeLog.recordChange({
          type: 'fix-applied',
          fixAction: issue.fixAction,
          issueId,
          timestamp: Date.now(),
          snapshotId: snapshot.id,
          clientSide: fixResult.clientSide || false
        });

        return {
          success: true,
          fixedIssueId: issueId,
          fixAction: issue.fixAction,
          updatedDocument: fixResult.updatedDocument || false,
          clientSide: fixResult.clientSide || false,
          snapshotId: snapshot.id
        };
      }

      // Fix failed - return error message instead of throwing
      return {
        success: false,
        error: fixResult.message || fixResult.error || 'Fix application failed'
      };

    } catch (error) {
      // Restore from snapshot on error
      console.error('❌ Fix application failed:', error);
      documentModel.restoreFromSnapshot(snapshot);
      throw error;
    }
  }

  /**
   * Update paragraph content (maintains sync with editor)
   */
  updateParagraphContent(documentModel, paragraphId, newContent) {
    if (!documentModel || !paragraphId || newContent === undefined) {
      throw new Error('Document model, paragraph ID, and new content required');
    }

    const paragraph = documentModel.paragraphs.get(paragraphId);
    if (!paragraph) {
      throw new Error(`Paragraph not found: ${paragraphId}`);
    }

    const oldText = paragraph.text;
    const updated = paragraph.update({
      text: newContent.text || newContent,
      runs: newContent.runs || null
    });

    if (updated) {
      // Invalidate issues for this paragraph
      documentModel.issues.invalidateParagraphIssues(paragraphId);

      return {
        success: true,
        paragraphId,
        oldText,
        newText: paragraph.text,
        changeSequence: paragraph.changeSequence,
        needsReanalysis: true
      };
    }

    return {
      success: false,
      reason: 'No changes detected'
    };
  }

  /**
   * Sync document with editor state (bidirectional)
   */
  syncWithEditor(documentModel, tiptapDocument, changesMeta = {}) {
    if (!documentModel || !tiptapDocument) {
      throw new Error('Document model and Tiptap document required');
    }

    const hasChanges = documentModel.applyEditorChanges(tiptapDocument, changesMeta);

    if (hasChanges) {
      // Get changed paragraphs for incremental analysis
      const changedParagraphs = documentModel.getChangedParagraphs(Date.now() - 10000); // Last 10 seconds

      return {
        success: true,
        hasChanges: true,
        changedParagraphs,
        needsReanalysis: changedParagraphs.length > 0,
        documentVersion: documentModel.version
      };
    }

    return {
      success: true,
      hasChanges: false,
      needsReanalysis: false
    };
  }

  /**
   * Export document in specified format
   */
  async exportDocument(documentModel, format = 'html') {
    if (!documentModel) {
      throw new Error('Document model required');
    }

    switch (format.toLowerCase()) {
      case 'html':
        return {
          success: true,
          format: 'html',
          content: this._generateHtmlExport(documentModel),
          filename: `${documentModel.metadata.name || 'document'}.html`
        };

      case 'docx': {
        // NEW: Generate DOCX from JSON using DocxExportService
        const { DocxExportService } = await import('./DocxExportService');
        const exportService = new DocxExportService();

        console.log('📤 Exporting document as DOCX (JSON-based)...');
        const docxBuffer = await exportService.exportToDocx(documentModel);

        return {
          success: true,
          format: 'docx',
          content: docxBuffer,
          filename: `${documentModel.metadata.name || 'document'}.docx`,
          method: 'json-based' // Indicate new architecture
        };
      }

      case 'docx-legacy': {
        // LEGACY: Export from original buffer (for fallback)
        if (!documentModel.currentBuffer) {
          throw new Error('No DOCX buffer available for legacy export');
        }

        const decompressedBuffer = await this.compressionUtils.decompressBuffer(documentModel.currentBuffer);

        return {
          success: true,
          format: 'docx',
          content: decompressedBuffer,
          filename: `${documentModel.metadata.name || 'document'}.docx`,
          method: 'legacy-buffer'
        };
      }

      case 'text':
        return {
          success: true,
          format: 'text',
          content: documentModel.getPlainText(),
          filename: `${documentModel.metadata.name || 'document'}.txt`
        };

      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }

  /**
   * Get document statistics and compliance info
   */
  getDocumentInfo(documentModel) {
    if (!documentModel) {
      throw new Error('Document model required');
    }

    const stats = documentModel.getStatistics();
    const issueStats = documentModel.issues.getIssueStats();

    return {
      metadata: documentModel.metadata,
      statistics: stats,
      issues: issueStats,
      compliance: {
        score: this._calculateComplianceScore(documentModel.issues.getAllIssues()),
        lastAnalysis: documentModel.issues.lastAnalysisTimestamp,
        totalParagraphs: documentModel.paragraphOrder.length,
        analysisVersion: documentModel.version
      },
      version: documentModel.version,
      lastModified: documentModel.lastModified
    };
  }

  // Private methods

  async _performFullAnalysis(documentModel) {
    // Convert document model to format expected by analyzer
    const documentData = {
      text: documentModel.getPlainText(),
      html: documentModel.getFormattedHtml(),
      formatting: this._extractFormattingForAnalysis(documentModel),
      structure: this._extractStructureForAnalysis(documentModel),
      styles: this._extractStylesForAnalysis(documentModel)
    };

    console.log('🔍 Full analysis document data:', {
      textLength: documentData.text?.length || 0,
      htmlLength: documentData.html?.length || 0,
      hasFormatting: !!documentData.formatting,
      hasStructure: !!documentData.structure,
      hasStyles: !!documentData.styles,
      stylesKeys: documentData.styles ? Object.keys(documentData.styles) : []
    });

    const analysisOptions = {
      force: true,
      changedParagraphs: null,
      preserveUnchanged: false
    };

    const issues = this.apaAnalyzer.analyzeDocument(documentData, analysisOptions);

    console.log('📊 Analysis results:', {
      totalIssues: issues.length,
      bySeverity: {
        Critical: issues.filter(i => i.severity === 'Critical').length,
        Major: issues.filter(i => i.severity === 'Major').length,
        Minor: issues.filter(i => i.severity === 'Minor').length
      }
    });

    return {
      issues,
      analysisType: 'full'
    };
  }

  async _performIncrementalAnalysis(documentModel, changedParagraphs) {
    // Get existing issues
    const existingIssues = documentModel.issues.getAllIssues();

    // Invalidate issues for changed paragraphs
    const invalidatedIssueIds = new Set();
    changedParagraphs.forEach(paragraph => {
      const paragraphIssues = documentModel.issues.getIssuesForParagraph(paragraph.id);
      paragraphIssues.forEach(issue => invalidatedIssueIds.add(issue.id));
    });

    // Extract text content for analysis
    const changedText = changedParagraphs.map(p => p.text).join('\n');
    const fullText = documentModel.getPlainText();

    // Analyze only changed content but with full document context
    const documentData = {
      text: fullText,
      html: documentModel.getFormattedHtml(),
      formatting: this._extractFormattingForAnalysis(documentModel),
      structure: this._extractStructureForAnalysis(documentModel),
      styles: this._extractStylesForAnalysis(documentModel),
      changedParagraphs: changedParagraphs.map(p => ({
        id: p.id,
        index: p.index,
        text: p.text
      }))
    };

    const newIssues = this.apaAnalyzer.analyzeDocument(documentData);

    // Merge with existing issues (remove invalidated, add new)
    const mergedIssues = existingIssues
      .filter(issue => !invalidatedIssueIds.has(issue.id))
      .concat(newIssues);

    return {
      issues: mergedIssues,
      analysisType: 'incremental',
      invalidatedIssueIds: Array.from(invalidatedIssueIds),
      newIssueCount: newIssues.length
    };
  }

  _updateDocumentIssues(documentModel, analysisResults) {
    // Clear existing issues
    documentModel.issues = new (documentModel.issues.constructor)();

    console.log('📝 Updating document issues:', {
      totalIssues: analysisResults.issues.length,
      sampleIssue: analysisResults.issues[0]
    });

    // Add new issues with unique IDs
    analysisResults.issues.forEach((issue, index) => {
      // Ensure each issue has a unique ID
      const issueWithId = {
        ...issue,
        id: issue.id || `${issue.category || 'general'}-${issue.severity || 'Minor'}-${index}`
      };

      // Find paragraph association based on issue location
      let paragraphId = null;
      if (issueWithId.location && issueWithId.location.paragraphIndex !== undefined) {
        const paragraphIndex = issueWithId.location.paragraphIndex;
        if (paragraphIndex < documentModel.paragraphOrder.length) {
          paragraphId = documentModel.paragraphOrder[paragraphIndex];
        }
      }

      documentModel.issues.addIssue(issueWithId, paragraphId);
    });

    console.log('✅ Document issues updated:', {
      storedIssues: documentModel.issues.getAllIssues().length
    });

    documentModel.issues.lastAnalysisTimestamp = Date.now();
  }

  _calculateComplianceScore(issues) {
    if (!issues || issues.length === 0) return 100;

    const criticalCount = issues.filter(i => i.severity === 'Critical').length;
    const majorCount = issues.filter(i => i.severity === 'Major').length;
    const minorCount = issues.filter(i => i.severity === 'Minor').length;

    return Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
  }

  /**
   * Check if a fix action is actually implemented
   */
  isFixImplemented(fixAction) {
    return this._isTextFix(fixAction) || this._isFormattingFix(fixAction);
  }

  /**
   * Check if fix is a text-based fix (search/replace in JSON)
   */
  _isTextFix(fixAction) {
    return [
      'addCitationComma',
      'fixParentheticalConnector',
      'fixEtAlFormatting',
      'fixReferenceConnector',
      'fixAllCapsHeading',
      'addPageNumber'
    ].includes(fixAction);
  }

  /**
   * Check if fix is a formatting fix (JSON property update)
   */
  _isFormattingFix(fixAction) {
    return [
      'fixFont',
      'fixFontSize',
      'fixLineSpacing',
      'fixMargins',
      'fixIndentation'
    ].includes(fixAction);
  }

  /**
   * Apply text-based fix by mutating paragraph text in DocumentModel
   * This is instant (<100ms) and triggers auto-save in background
   */
  _applyTextFixToJSON(documentModel, issue) {
    const { fixAction, fixValue, location } = issue;

    // Find target paragraph
    let paragraphId = null;
    if (location?.paragraphIndex !== undefined) {
      if (location.paragraphIndex < documentModel.paragraphOrder.length) {
        paragraphId = documentModel.paragraphOrder[location.paragraphIndex];
      }
    }

    // Fallback: Search for text if location missing or paragraph not found
    if (!paragraphId) {
      // Prefer fixValue.original (full text) or highlightText over issue.text (may be truncated)
      const searchText = fixValue?.original || issue.highlightText || issue.text;

      if (searchText) {
        // Search all paragraphs for matching text
        for (const id of documentModel.paragraphOrder) {
          const para = documentModel.paragraphs.get(id);
          if (para && para.text.includes(searchText)) {
            paragraphId = id;
            break;
          }
        }
      }

      if (!paragraphId) {
        return { success: false, error: 'Paragraph not found' };
      }
    }

    const paragraph = documentModel.paragraphs.get(paragraphId);
    if (!paragraph) {
      return { success: false, error: 'Paragraph not found in model' };
    }

    const oldText = paragraph.text;

    // Apply text replacement based on fixValue
    let newText = oldText;
    if (fixValue && fixValue.original && fixValue.replacement) {
      newText = oldText.replace(fixValue.original, fixValue.replacement);
    } else {
      // Legacy: use predefined replacement logic
      newText = this._applyLegacyTextFix(oldText, fixAction, issue);
    }

    if (oldText === newText) {
      console.warn('⚠️ No changes applied - text unchanged');
      return { success: false, error: 'No changes detected' };
    }

    console.log('✏️ Text change:', {
      old: oldText.substring(0, 100),
      new: newText.substring(0, 100)
    });

    // Update paragraph text
    paragraph.update({ text: newText });

    // Update runs to match new text
    if (paragraph.runs && paragraph.runs.size > 0) {
      const firstRun = Array.from(paragraph.runs.values())[0];
      paragraph.runs.clear();
      paragraph.runOrder = [];

      const newRun = {
        text: newText,
        font: firstRun?.font || {},
        color: firstRun?.color || null
      };

      const RunModel = require('@/models/ParagraphModel').RunModel;
      const runModel = RunModel.fromData(newRun, 0);
      paragraph.runs.set(runModel.id, runModel);
      paragraph.runOrder.push(runModel.id);
    }

    // Update document version
    documentModel.version++;
    documentModel.lastModified = Date.now();

    // Trigger auto-save (non-blocking, 1 second debounce)
    if (this._scheduleAutoSaveCallback) {
      this._scheduleAutoSaveCallback(documentModel, 1000);
    }

    console.log('✅ Text fix applied successfully (client-side)');

    return {
      success: true,
      clientSide: true,
      paragraphId,
      oldText,
      newText
    };
  }

  /**
   * Apply formatting fix by updating DocumentModel properties
   * This is instant (<200ms) and triggers editor re-render + auto-save
   */
  _applyFormattingFixToJSON(documentModel, issue) {
    const { fixAction } = issue;

    console.log('🎨 Formatting fix:', fixAction);

    switch (fixAction) {
      case 'fixFont':
        // Update document-level default
        documentModel.formatting.document.font.family = 'Times New Roman';

        // Update all paragraph runs
        documentModel.paragraphOrder.forEach(id => {
          const para = documentModel.paragraphs.get(id);
          if (para && para.runs) {
            para.runs.forEach(run => {
              run.font.family = 'Times New Roman';
            });
          }
        });
        break;

      case 'fixFontSize':
        documentModel.formatting.document.font.size = 12;

        documentModel.paragraphOrder.forEach(id => {
          const para = documentModel.paragraphs.get(id);
          if (para && para.runs) {
            para.runs.forEach(run => {
              run.font.size = 12;
            });
          }
        });
        break;

      case 'fixLineSpacing':
        documentModel.formatting.document.spacing.line = 2.0;

        documentModel.paragraphOrder.forEach(id => {
          const para = documentModel.paragraphs.get(id);
          if (para && para.formatting) {
            para.formatting.spacing = para.formatting.spacing || {};
            para.formatting.spacing.line = 2.0;
          }
        });
        break;

      case 'fixMargins':
        documentModel.formatting.document.margins = {
          top: 1.0,
          bottom: 1.0,
          left: 1.0,
          right: 1.0
        };
        break;

      case 'fixIndentation':
        // Apply to all body paragraphs (exclude headings)
        documentModel.paragraphOrder.forEach(id => {
          const para = documentModel.paragraphs.get(id);
          if (para && para.formatting) {
            const styleName = para.formatting.styleName?.toLowerCase() || '';
            if (!styleName.includes('heading') && !styleName.includes('title')) {
              para.formatting.indentation = para.formatting.indentation || {};
              para.formatting.indentation.firstLine = 0.5;
            }
          }
        });
        break;

      default:
        return { success: false, error: `Unknown formatting fix: ${fixAction}` };
    }

    // Update document version
    documentModel.version++;
    documentModel.lastModified = Date.now();

    // Trigger auto-save (non-blocking)
    if (this._scheduleAutoSaveCallback) {
      this._scheduleAutoSaveCallback(documentModel, 1000);
    }

    console.log('✅ Formatting fix applied successfully (client-side)');

    return {
      success: true,
      clientSide: true,
      fixAction,
      requiresEditorRefresh: true
    };
  }

  /**
   * Legacy text fix logic (for backward compatibility)
   */
  _applyLegacyTextFix(text, fixAction, issue) {
    const originalText = issue.text || issue.highlightText;
    if (!originalText) return text;

    switch (fixAction) {
      case 'addCitationComma': {
        const pattern = /\(([A-Za-z][A-Za-z\s&.]+(?<!et\s+al))\s+(\d{4})\)/g;
        return text.replace(pattern, (match, author, year) => {
          if (match === originalText) return `(${author}, ${year})`;
          return match;
        });
      }
      case 'fixParentheticalConnector':
        return text.replace(originalText, originalText.replace(' and ', ' & '));
      case 'fixEtAlFormatting':
        return text.replace(originalText, originalText.replace(', et al.', ' et al.'));
      case 'fixReferenceConnector':
        return text.replace(originalText, originalText.replace(' and ', ' & '));
      case 'fixAllCapsHeading': {
        // Convert ALL CAPS to Title Case
        const titleCase = originalText
          .toLowerCase()
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        return text.replace(originalText, titleCase);
      }
      case 'addPageNumber':
        return text.replace(originalText, originalText.replace(')', ', p. XX)'));
      default:
        return text;
    }
  }

  /**
   * Set callback for scheduling auto-save from store
   */
  setScheduleAutoSaveCallback(callback) {
    this._scheduleAutoSaveCallback = callback;
  }

  async _applyServerFormattingFix(documentModel, issue) {
    let base64Buffer;

    if (!documentModel.currentBuffer) {
      // Document loaded from Supabase - download original file first
      if (!documentModel.supabase.filePath) {
        return {
          success: false,
          message: 'Cannot apply formatting fixes: document file path not available.'
        };
      }

      console.log('📥 Downloading document from Supabase for fix application...');
      console.log('📁 File path:', documentModel.supabase.filePath);

      // Download from Supabase storage - use createBrowserClient from @supabase/ssr
      const { createBrowserClient } = await import('@supabase/ssr');
      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      const { data: fileData, error: downloadError } = await supabase.storage
        .from('user-documents')
        .download(documentModel.supabase.filePath);

      console.log('📦 Download result:', { hasData: !!fileData, error: downloadError });

      if (downloadError || !fileData) {
        return {
          success: false,
          message: 'Failed to download document from storage for fix application.'
        };
      }

      // Convert Blob to Buffer to base64
      const arrayBuffer = await fileData.arrayBuffer();
      const buffer = Buffer.from(arrayBuffer);
      base64Buffer = this._bufferToBase64(buffer);
    } else {
      const decompressedBuffer = await this.compressionUtils.decompressBuffer(documentModel.currentBuffer);
      base64Buffer = this._bufferToBase64(decompressedBuffer);
    }

    console.log('🔧 Sending fix to backend:', {
      fixAction: issue.fixAction,
      fixValue: issue.fixValue,
      bufferLength: base64Buffer?.length
    });

    const response = await fetch(`${this.serverBaseUrl}/api/apply-fix`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        documentBuffer: base64Buffer,
        fixAction: issue.fixAction,
        fixValue: issue.fixValue,
        originalFilename: documentModel.metadata.name
      })
    });

    if (!response.ok) {
      const errorData = await this._handleApiError(response);
      throw new Error(errorData.message || 'Server fix failed');
    }

    const result = await response.json();

    if (!result.success) {
      throw new Error(result.error || 'Server fix failed');
    }

    // Update document model with server response - FULL REFRESH
    if (result.document) {
      console.log('🔄 Updating document model after server fix...');

      // Update formatting from server
      if (result.document.formatting) {
        documentModel.formatting.initializeFromServer(result.document.formatting);
        console.log('✅ Formatting updated');
      }

      // Update structure from server
      if (result.document.structure) {
        documentModel.structure = result.document.structure;
        console.log('✅ Structure updated');
      }

      // Update styles from server
      if (result.document.styles) {
        documentModel.styles = result.document.styles;
        console.log('✅ Styles updated');
      }

      // Update HTML/text content - this is critical for editor to show changes!
      if (result.document.html) {
        documentModel.html = result.document.html;
        console.log('✅ HTML content updated');
      }

      if (result.document.text) {
        documentModel.text = result.document.text;
        console.log('✅ Text content updated');
      }

      // Rebuild paragraphs from updated data
      if (result.document.formatting && result.document.formatting.paragraphs) {
        console.log('🔄 Rebuilding paragraphs from server data...');

        // Clear existing paragraphs
        documentModel.paragraphs.clear();
        documentModel.paragraphOrder = [];

        // Rebuild from server data (same logic as fromServerData)
        result.document.formatting.paragraphs.forEach((paraData, index) => {
          const ParagraphModel = require('@/models/ParagraphModel').ParagraphModel;
          const paragraphModel = ParagraphModel.fromServerData(paraData, index);
          documentModel.paragraphs.set(paragraphModel.id, paragraphModel);
          documentModel.paragraphOrder.push(paragraphModel.id);
        });

        console.log(`✅ Paragraphs rebuilt: ${documentModel.paragraphOrder.length} paragraphs`);
      }

      // Update document buffer
      if (result.modifiedDocumentBuffer) {
        const newBuffer = this._base64ToBuffer(result.modifiedDocumentBuffer);
        documentModel.currentBuffer = await this.compressionUtils.compressBuffer(newBuffer);
        console.log('✅ Document buffer updated');
      }

      // Increment version to trigger editor sync
      documentModel.version++;
      documentModel.lastModified = Date.now();
      console.log(`✅ Document model fully updated (version ${documentModel.version})`);

      // Save modified document back to Supabase if this is a Supabase document
      if (documentModel.supabase.documentId && result.modifiedDocumentBuffer) {
        console.log('💾 Saving modified document to Supabase...');
        await this._saveToSupabase(documentModel, result.modifiedDocumentBuffer, result.document);
      }
    }

    return {
      success: true,
      updatedDocument: true,
      serverResponse: result
    };
  }

  async _saveToSupabase(documentModel, modifiedBufferBase64, updatedDocumentData) {
    try {
      const { createBrowserClient } = await import('@supabase/ssr');
      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      // Convert base64 back to Blob for upload
      const binaryString = atob(modifiedBufferBase64);
      const bytes = new Uint8Array(binaryString.length);
      for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      const blob = new Blob([bytes], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });

      // Upload modified file to Supabase storage (overwrite original)
      const { error: uploadError } = await supabase.storage
        .from('user-documents')
        .upload(documentModel.supabase.filePath, blob, {
          upsert: true // Overwrite existing file
        });

      if (uploadError) {
        console.error('❌ Failed to upload modified document:', uploadError);
        throw uploadError;
      }

      console.log('✅ Modified document uploaded to storage');

      // Get current Tiptap JSON and issues for the NEW architecture
      const tiptapContent = documentModel.getTiptapJson();
      const issues = documentModel.issues.getAllIssues();
      const complianceScore = this._calculateComplianceScore(issues);

      // Update analysis_results table with BOTH old and new data
      const { error: updateError } = await supabase
        .from('analysis_results')
        .update({
          document_data: updatedDocumentData, // Keep for backward compatibility
          tiptap_content: tiptapContent, // NEW: JSON-based content
          issues: issues,
          compliance_score: complianceScore,
          issue_count: issues.length,
          editor_version: 1
        })
        .eq('document_id', documentModel.supabase.documentId);

      if (updateError) {
        console.error('❌ Failed to update analysis results:', updateError);
        throw updateError;
      }

      console.log('✅ Analysis results updated in database (with tiptap_content)');

    } catch (error) {
      console.error('❌ Error saving to Supabase:', error);
      // Don't throw - fix was applied locally, save failure shouldn't break the fix
    }
  }

  /**
   * Auto-save manual edits to Supabase (JSON-based, no DOCX manipulation)
   * This is the NEW architecture - DOCX is generated only on export
   * @param {DocumentModel} documentModel - The document to save
   * @param {AbortSignal} signal - Optional abort signal for cancellation
   */
  async autoSaveDocument(documentModel, signal = null) {
    if (!documentModel) {
      console.error('❌ Auto-save failed: No document model provided');
      return {
        success: false,
        error: 'No document model provided'
      };
    }

    try {
      // Check if operation was aborted
      if (signal?.aborted) {
        throw new DOMException('Auto-save aborted', 'AbortError');
      }

      // Check if this document has Supabase metadata
      if (!documentModel.supabase.documentId) {
        console.warn('⚠️ Auto-save skipped: No Supabase document ID');
        return {
          success: false,
          error: 'Document not linked to Supabase'
        };
      }

      // Get current Tiptap JSON content (source of truth)
      const tiptapContent = documentModel.getTiptapJson();

      // Get current issues for compliance score
      const issues = documentModel.issues.getAllIssues();
      const complianceScore = this._calculateComplianceScore(issues);

      // Check abort signal before network operations
      if (signal?.aborted) {
        throw new DOMException('Auto-save aborted', 'AbortError');
      }

      // Initialize Supabase client
      const { createBrowserClient } = await import('@supabase/ssr');
      const supabase = createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY
      );

      // Verify user session (security check)
      const { data: { session } } = await supabase.auth.getSession();
      if (!session) {
        console.error('❌ No active session - user not authenticated');
        return {
          success: false,
          error: 'No active session'
        };
      }

      // Check abort signal before database operations
      if (signal?.aborted) {
        throw new DOMException('Auto-save aborted', 'AbortError');
      }

      // Try to update existing record first
      const { data: updateData, error: updateError } = await supabase
        .from('analysis_results')
        .update({
          tiptap_content: tiptapContent,
          issues: issues,
          compliance_score: complianceScore,
          issue_count: issues.length,
          editor_version: 1
          // content_saved_at is automatically updated by trigger
        })
        .eq('document_id', documentModel.supabase.documentId)
        .select();

      // If update didn't affect any rows, insert new record
      if (!updateData || updateData.length === 0) {
        console.log('🆕 No existing analysis_results row, creating new one');

        const { data: insertData, error: insertError } = await supabase
          .from('analysis_results')
          .insert({
            document_id: documentModel.supabase.documentId,
            tiptap_content: tiptapContent,
            issues: issues,
            compliance_score: complianceScore,
            issue_count: issues.length,
            editor_version: 1
          })
          .select();

        if (insertError) {
          console.error('❌ Supabase insert failed:', insertError);
          throw new Error(`Failed to save to database: ${insertError.message}`);
        }

        console.log('✅ Document auto-saved to Supabase (JSON - new record)');
      } else {
        if (updateError) {
          console.error('❌ Supabase update failed:', updateError);
          throw new Error(`Failed to save to database: ${updateError.message}`);
        }
        console.log('✅ Document auto-saved to Supabase (JSON - updated)');
      }

      // Update local state
      documentModel.version++;
      documentModel.lastModified = Date.now();

      // Clear IndexedDB after successful Supabase save to prevent stale data
      try {
        const { indexedDBManager } = await import('@/utils/indexedDBManager');
        await indexedDBManager.clearFromIndexedDB(documentModel.supabase.documentId);
        console.log('🗑️ Cleared IndexedDB after successful Supabase save');
      } catch (idbError) {
        // Don't fail the save if IndexedDB clear fails
        console.warn('⚠️ Failed to clear IndexedDB:', idbError);
      }

      return {
        success: true,
        savedAt: Date.now(),
        method: 'json-based',
        size: JSON.stringify(tiptapContent).length
      };

    } catch (error) {
      console.error('❌ Auto-save failed:', error);
      return {
        success: false,
        error: error.message
      };
    }
  }

  // OLD CLIENT-SIDE FIX METHODS REMOVED - All fixes now go through backend DOCX modification (Option A)

  _extractFormattingForAnalysis(documentModel) {
    return {
      document: documentModel.formatting.document,
      paragraphs: documentModel.paragraphOrder.map(id => {
        const paragraph = documentModel.paragraphs.get(id);
        return paragraph ? {
          index: paragraph.index,
          text: paragraph.text,
          font: paragraph.formatting.font,
          spacing: paragraph.formatting.spacing,
          indentation: paragraph.formatting.indentation,
          alignment: paragraph.formatting.alignment,
          style: paragraph.formatting.styleName,
          runs: Array.from(paragraph.runs.values()).map(run => ({
            index: run.index,
            text: run.text,
            font: run.font,
            color: run.color
          }))
        } : null;
      }).filter(Boolean),
      compliance: documentModel.formatting.compliance
    };
  }

  _extractStructureForAnalysis(documentModel) {
    return {
      headings: documentModel.structure.headings,
      sections: documentModel.structure.sections,
      citations: documentModel.structure.citations,
      references: documentModel.structure.references,
      tables: documentModel.structure.tables,
      italicizedText: documentModel.structure.italicizedText,
      headersFooters: documentModel.structure.headersFooters,
      // Add paragraph map for accurate index mapping
      paragraphMap: documentModel.paragraphOrder.map((id, index) => {
        const para = documentModel.paragraphs.get(id);
        return {
          index: index,
          id: id,
          text: para?.text || ''
        };
      })
    };
  }

  _extractStylesForAnalysis(documentModel) {
    // Extract styles data from document model for APA analysis
    if (!documentModel.styles) {
      return {};
    }

    return {
      paragraphStyles: documentModel.styles.paragraphStyles || {},
      characterStyles: documentModel.styles.characterStyles || {},
      tableStyles: documentModel.styles.tableStyles || {},
      numberingStyles: documentModel.styles.numberingStyles || {},
      defaults: documentModel.styles.defaults || {}
    };
  }

  _generateHtmlExport(documentModel) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${documentModel.metadata.name || 'Document'}</title>
  <style>
    body {
      font-family: "Times New Roman", serif;
      font-size: 12pt;
      line-height: 2;
      margin: 1in;
      background: white;
    }
    .docx-document {
      max-width: 100%;
    }
  </style>
</head>
<body>
${documentModel.getFormattedHtml()}
</body>
</html>`;
  }

  _findIssueLocation(documentModel, issue) {
    // Find paragraph containing issue text
    for (const paragraphId of documentModel.paragraphOrder) {
      const paragraph = documentModel.paragraphs.get(paragraphId);
      if (paragraph && paragraph.text.includes(issue.text || issue.highlightText || '')) {
        return paragraphId;
      }
    }
    return null;
  }

  async _handleApiError(response) {
    try {
      return await response.json();
    } catch {
      return { message: `HTTP ${response.status}: ${response.statusText}` };
    }
  }

  _bufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = '';
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  _base64ToBuffer(base64) {
    try {
      // Clean base64 string - remove whitespace and newlines
      const cleanedBase64 = base64.replace(/\s/g, '');
      const binary = atob(cleanedBase64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    } catch (error) {
      console.error('Failed to decode base64:', error);
      console.error('Base64 string length:', base64?.length);
      console.error('First 100 chars:', base64?.substring(0, 100));
      throw new Error(`Base64 decode failed: ${error.message}`);
    }
  }
}

/**
 * Compression utilities (matches current implementation)
 */
class CompressionUtils {
  async compressBuffer(buffer) {
    try {
      if (typeof CompressionStream !== 'undefined') {
        const stream = new CompressionStream('gzip');
        const writer = stream.writable.getWriter();
        const reader = stream.readable.getReader();

        const chunks = [];
        const readPromise = (async () => {
          let result;
          while (!(result = await reader.read()).done) {
            chunks.push(result.value);
          }
        })();

        await writer.write(buffer);
        await writer.close();
        await readPromise;

        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const compressed = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          compressed.set(chunk, offset);
          offset += chunk.length;
        }

        return compressed;
      } else {
        return buffer; // No compression available
      }
    } catch (error) {
      console.warn('Compression failed:', error);
      return buffer;
    }
  }

  async decompressBuffer(compressedBuffer) {
    try {
      if (typeof DecompressionStream !== 'undefined') {
        const stream = new DecompressionStream('gzip');
        const writer = stream.writable.getWriter();
        const reader = stream.readable.getReader();

        const chunks = [];
        const readPromise = (async () => {
          let result;
          while (!(result = await reader.read()).done) {
            chunks.push(result.value);
          }
        })();

        await writer.write(compressedBuffer);
        await writer.close();
        await readPromise;

        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const decompressed = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          decompressed.set(chunk, offset);
          offset += chunk.length;
        }

        return decompressed;
      } else {
        return compressedBuffer; // Assume not compressed
      }
    } catch (error) {
      console.warn('Decompression failed:', error);
      return compressedBuffer;
    }
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\services\DocxExportService.js
'use client';

import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx';

/**
 * DOCX Export Service - Generate DOCX from DocumentModel JSON
 * This is the JSON-first architecture: JSON is source of truth, DOCX generated on-demand
 */
export class DocxExportService {

  /**
   * Convert DocumentModel to DOCX buffer
   * @param {DocumentModel} documentModel
   * @returns {Promise<Uint8Array>} DOCX file buffer
   */
  async exportToDocx(documentModel) {
    if (!documentModel) {
      throw new Error('No document model provided');
    }

    console.log('📄 Generating DOCX from JSON...');
    const startTime = Date.now();

    // Build DOCX sections
    const sections = [{
      properties: {
        page: {
          margin: {
            top: this._inchesToTwip(documentModel.formatting.document.margins.top || 1.0),
            bottom: this._inchesToTwip(documentModel.formatting.document.margins.bottom || 1.0),
            left: this._inchesToTwip(documentModel.formatting.document.margins.left || 1.0),
            right: this._inchesToTwip(documentModel.formatting.document.margins.right || 1.0)
          }
        }
      },
      children: this._buildParagraphs(documentModel)
    }];

    // Create document
    const doc = new Document({
      sections,
      styles: {
        default: {
          document: {
            run: {
              font: documentModel.formatting.document.font.family || 'Times New Roman',
              size: (documentModel.formatting.document.font.size || 12) * 2 // Convert to half-points
            },
            paragraph: {
              spacing: {
                line: (documentModel.formatting.document.spacing.line || 2.0) * 240,
                before: 0,
                after: 0
              }
            }
          }
        }
      }
    });

    // Generate buffer
    const buffer = await Packer.toBuffer(doc);

    const exportTime = Date.now() - startTime;
    console.log(`✅ DOCX generated in ${exportTime}ms`);

    return buffer;
  }

  /**
   * Build paragraphs from DocumentModel
   */
  _buildParagraphs(documentModel) {
    const paragraphs = [];

    documentModel.paragraphOrder.forEach(id => {
      const para = documentModel.paragraphs.get(id);
      if (!para) return;

      // Determine if heading or paragraph
      const styleName = para.formatting?.styleName || para.style || '';
      const isHeading = styleName.toLowerCase().includes('heading');
      const headingLevel = this._extractHeadingLevel(styleName);

      // Build text runs
      const children = this._buildTextRuns(para);

      // Create paragraph
      const paragraphConfig = {
        children,
        spacing: {
          line: (para.formatting?.spacing?.line || 2.0) * 240,
          before: 0,
          after: 0
        }
      };

      // Add indentation if present
      if (para.formatting?.indentation?.firstLine) {
        paragraphConfig.indent = {
          firstLine: this._inchesToTwip(para.formatting.indentation.firstLine)
        };
      }

      // Add alignment if present
      if (para.formatting?.alignment) {
        paragraphConfig.alignment = this._convertAlignment(para.formatting.alignment);
      }

      // Create heading or paragraph
      if (isHeading && headingLevel) {
        paragraphConfig.heading = this._convertHeadingLevel(headingLevel);
        paragraphs.push(new Paragraph(paragraphConfig));
      } else {
        paragraphs.push(new Paragraph(paragraphConfig));
      }
    });

    return paragraphs;
  }

  /**
   * Build text runs from paragraph
   */
  _buildTextRuns(paragraph) {
    const runs = [];

    // paragraph.runs is a Map, so use .size instead of .length
    if (paragraph.runs && paragraph.runs.size > 0) {
      // Iterate runs in order
      paragraph.runOrder.forEach(runId => {
        const run = paragraph.runs.get(runId);
        if (!run || !run.text) return;

        runs.push(new TextRun({
          text: run.text,
          font: run.font?.family || 'Times New Roman',
          size: (run.font?.size || 12) * 2,
          bold: run.font?.bold || false,
          italics: run.font?.italic || false,
          underline: run.font?.underline ? {} : undefined,
          color: run.color ? run.color.replace('#', '') : undefined
        }));
      });
    } else if (paragraph.text) {
      // Fallback to plain text
      runs.push(new TextRun({
        text: paragraph.text,
        font: 'Times New Roman',
        size: 24 // 12pt
      }));
    }

    return runs;
  }

  // Helper methods
  _inchesToTwip(inches) {
    return Math.round(inches * 1440);
  }

  _extractHeadingLevel(style) {
    if (!style) return null;
    const match = style.match(/heading\s*(\d+)/i);
    return match ? parseInt(match[1]) : null;
  }

  _convertHeadingLevel(level) {
    const mapping = {
      1: HeadingLevel.HEADING_1,
      2: HeadingLevel.HEADING_2,
      3: HeadingLevel.HEADING_3,
      4: HeadingLevel.HEADING_4,
      5: HeadingLevel.HEADING_5,
      6: HeadingLevel.HEADING_6
    };
    return mapping[level] || HeadingLevel.HEADING_1;
  }

  _convertAlignment(align) {
    const mapping = {
      left: AlignmentType.LEFT,
      center: AlignmentType.CENTER,
      right: AlignmentType.RIGHT,
      both: AlignmentType.JUSTIFIED,
      justify: AlignmentType.JUSTIFIED
    };
    return mapping[align] || AlignmentType.LEFT;
  }
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\store\unifiedDocumentStore.js
'use client';

import { create } from 'zustand';
import { DocumentService } from '@/services/DocumentService';
import { ChangeTracker, DocumentTransaction } from '@/utils/ChangeTracker';
import { DocumentModel } from '@/models/DocumentModel';

/**
 * Unified Document Store - Single Source of Truth
 * Replaces enhancedDocumentStore.js with DocumentModel-based architecture
 */

// Simple event emitter for cross-component communication (keeping from original)
class StoreEventEmitter {
  constructor() {
    this.listeners = new Map();
  }

  on(event, callback) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set());
    }
    this.listeners.get(event).add(callback);
    return () => this.off(event, callback);
  }

  off(event, callback) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).delete(callback);
      if (this.listeners.get(event).size === 0) {
        this.listeners.delete(event);
      }
    }
  }

  emit(event, data) {
    if (this.listeners.has(event)) {
      this.listeners.get(event).forEach(callback => {
        try {
          callback(data);
        } catch (error) {
          console.error(`Error in event listener for ${event}:`, error);
        }
      });
    }
  }

  clear() {
    this.listeners.clear();
  }
}

const storeEvents = new StoreEventEmitter();

export const useUnifiedDocumentStore = create((set, get) => ({
  // Single source of truth - DocumentModel
  documentModel: null,
  documentService: (() => {
    const service = new DocumentService();
    // Wire auto-save callback immediately
    service.setScheduleAutoSaveCallback((documentModel, debounceMs) => {
      get().scheduleAutoSave(false, debounceMs);
    });
    return service;
  })(),
  changeTracker: new ChangeTracker(),

  // UI state (derived from document model)
  processingState: {
    isUploading: false,
    isAnalyzing: false,
    isApplyingFix: false,
    lastError: null,
    progress: 0,
    stage: null,
    currentFixId: null
  },

  // Editor state
  editorState: {
    content: null,
    needsSync: false,
    lastSyncTimestamp: 0,
    isInitialized: false
  },

  // Auto-save state
  autoSaveState: {
    isSaving: false,
    lastSaveTimestamp: 0,
    lastSaveError: null,
    saveStatus: 'saved', // 'saved' | 'saving' | 'unsaved' | 'error'
    autoSaveDebounceTimeout: null,
    autoSaveAbortController: null // For cancelling in-flight saves
  },

  // Analysis state
  analysisState: {
    lastAnalysisTimestamp: 0,
    pendingAnalysis: false,
    analysisDebounceTimeout: null,
    incrementalMode: true,
    analysisAbortController: null // For cancelling in-flight analysis
  },

  // UI preferences
  uiState: {
    showIssueHighlighting: true,
    activeIssueId: null,
    selectedIssues: new Set()
  },

  // Snapshots for undo/redo
  snapshots: [],
  maxSnapshots: 10,
  currentSnapshotIndex: -1,

  // Event emitter
  events: storeEvents,

  // === DOCUMENT OPERATIONS ===

  /**
   * Load document from file upload
   */
  uploadDocument: async (file) => {
    if (!file) {
      throw new Error('No file provided');
    }

    set(state => ({
      processingState: {
        ...state.processingState,
        isUploading: true,
        lastError: null,
        progress: 10,
        stage: 'Uploading document...'
      }
    }));

    try {
      set(state => ({
        processingState: {
          ...state.processingState,
          progress: 30,
          stage: 'Processing on server...'
        }
      }));

      const result = await get().documentService.loadDocument(file);

      set(state => ({
        processingState: {
          ...state.processingState,
          progress: 80,
          stage: 'Initializing document...'
        }
      }));

      // Store document model
      set(state => ({
        documentModel: result.documentModel,
        processingState: {
          ...state.processingState,
          progress: 100,
          isUploading: false,
          stage: 'Upload complete'
        },
        editorState: {
          ...state.editorState,
          needsSync: true,
          content: null // Will be set by editor sync
        },
        analysisState: {
          ...state.analysisState,
          lastAnalysisTimestamp: 0 // Reset for new document
        }
      }));

      // Create initial snapshot
      get().createSnapshot('Document uploaded');

      // Automatically trigger analysis for the uploaded document
      setTimeout(async () => {
        try {
          await get().analyzeDocument({ force: true });
        } catch (error) {
          console.error('Auto-analysis failed:', error);
        }

        set(state => ({
          processingState: {
            ...state.processingState,
            stage: null
          }
        }));
      }, 1000);

      return {
        success: true,
        documentId: result.documentModel.id,
        stats: result.stats
      };

    } catch (error) {
      console.error('Error uploading document:', error);
      set(state => ({
        processingState: {
          ...state.processingState,
          isUploading: false,
          lastError: error.message,
          progress: 0,
          stage: null
        }
      }));
      throw error;
    }
  },

  /**
   * Load existing document from Supabase (for viewing processed documents)
   */
  loadExistingDocument: async (documentData, issues = [], supabaseMetadata = null) => {
    try {
      // Create DocumentModel from server data
      const documentModel = DocumentModel.fromServerData(documentData, null);

      // Set Supabase metadata for fix application
      if (supabaseMetadata) {
        documentModel.supabase.documentId = supabaseMetadata.documentId;
        documentModel.supabase.filePath = supabaseMetadata.filePath;
        documentModel.supabase.userId = supabaseMetadata.userId;
      }

      // NEW: If tiptap_content is available, use it as editor content (edited version)
      const initialEditorContent = documentData.tiptapContent || null;

      // Store document model and issues
      set(state => ({
        documentModel,
        editorState: {
          ...state.editorState,
          needsSync: true,
          content: initialEditorContent // Use saved tiptap_content if available
        },
        analysisState: {
          ...state.analysisState,
          lastAnalysisTimestamp: Date.now() // Mark as analyzed
        }
      }));

      // Load issues into DocumentModel's IssueTracker
      if (issues && issues.length > 0) {
        issues.forEach(issue => {
          documentModel.issues.addIssue(issue);
        });
      }

      // Create initial snapshot
      get().createSnapshot('Document loaded from database');

      console.log(`✅ Existing document loaded: ${documentModel.metadata.name}`);

      return {
        success: true,
        documentId: documentModel.id,
        stats: documentModel.getStatistics()
      };
    } catch (error) {
      console.error('Error loading existing document:', error);
      throw error;
    }
  },

  /**
   * Analyze document for APA compliance
   */
  analyzeDocument: async (options = {}) => {
    const { force = false, incrementalOnly = false } = options;
    const state = get();

    console.log('🧠 Starting APA analysis...', { force, incrementalOnly, hasDocument: !!state.documentModel });

    if (!state.documentModel) {
      throw new Error('No document loaded');
    }

    if (state.processingState.isAnalyzing && !force) {
      console.log('Analysis already in progress');
      return { success: false, message: 'Analysis already in progress' };
    }

    // Create new AbortController for this analysis
    const abortController = new AbortController();

    set(currentState => ({
      processingState: {
        ...currentState.processingState,
        isAnalyzing: true,
        lastError: null,
        stage: 'Analyzing document...'
      },
      analysisState: {
        ...currentState.analysisState,
        pendingAnalysis: false,
        analysisAbortController: abortController
      }
    }));

    try {
      // Check if aborted before starting
      if (abortController.signal.aborted) {
        throw new DOMException('Analysis aborted', 'AbortError');
      }

      // Determine analysis type
      let changedParagraphs = null;
      const lastAnalysis = state.analysisState.lastAnalysisTimestamp;

      if (state.analysisState.incrementalMode && lastAnalysis > 0 && !force) {
        changedParagraphs = state.documentModel.getChangedParagraphs(lastAnalysis);

        // If no changes, skip analysis
        if (changedParagraphs.length === 0 && !force) {
          set(currentState => ({
            processingState: {
              ...currentState.processingState,
              isAnalyzing: false,
              stage: null
            },
            analysisState: {
              ...currentState.analysisState,
              analysisAbortController: null
            }
          }));

          return {
            success: true,
            skipped: true,
            message: 'No changes detected - analysis skipped'
          };
        }
      }

      const analysisOptions = {
        force,
        changedParagraphs,
        preserveUnchanged: state.analysisState.incrementalMode,
        signal: abortController.signal // Pass abort signal
      };

      const result = await state.documentService.analyzeDocument(state.documentModel, analysisOptions);

      // Check if aborted after analysis
      if (abortController.signal.aborted) {
        console.log('🚫 Analysis was cancelled');
        return { success: false, aborted: true };
      }

      set(currentState => ({
        processingState: {
          ...currentState.processingState,
          isAnalyzing: false,
          stage: null
        },
        analysisState: {
          ...currentState.analysisState,
          lastAnalysisTimestamp: Date.now(),
          analysisAbortController: null
        }
      }));

      // Emit analysis complete event
      storeEvents.emit('analysisComplete', {
        issueCount: result.issueCount,
        analysisScore: result.analysisScore,
        analysisType: result.analysisType
      });

      return {
        success: true,
        issues: result.issues,
        issueCount: result.issueCount,
        analysisScore: result.analysisScore,
        analysisTime: result.analysisTime,
        analysisType: result.analysisType
      };

    } catch (error) {
      // Don't log or throw if aborted
      if (error.name === 'AbortError') {
        console.log('🚫 Analysis request was aborted');
        set(currentState => ({
          processingState: {
            ...currentState.processingState,
            isAnalyzing: false,
            stage: null
          },
          analysisState: {
            ...currentState.analysisState,
            analysisAbortController: null
          }
        }));
        return { success: false, aborted: true };
      }

      console.error('Error analyzing document:', error);
      set(currentState => ({
        processingState: {
          ...currentState.processingState,
          isAnalyzing: false,
          lastError: error.message,
          stage: null
        },
        analysisState: {
          ...currentState.analysisState,
          analysisAbortController: null
        }
      }));
      throw error;
    }
  },

  /**
   * Apply fix to issue
   */
  applyFix: async (issueId) => {
    const state = get();

    if (!state.documentModel || !issueId) {
      throw new Error('Document model and issue ID required');
    }

    if (state.processingState.isApplyingFix) {
      throw new Error('Another fix is already being applied');
    }

    set(currentState => ({
      processingState: {
        ...currentState.processingState,
        isApplyingFix: true,
        currentFixId: issueId,
        stage: `Applying fix for issue ${issueId}`
      }
    }));

    try {
      const result = await state.documentService.applyFix(state.documentModel, issueId);

      // Check if fix was successful
      if (!result.success) {
        set(currentState => ({
          processingState: {
            ...currentState.processingState,
            isApplyingFix: false,
            currentFixId: null,
            lastError: result.error || 'Fix failed',
            stage: null
          }
        }));

        return {
          success: false,
          error: result.error || 'Fix failed'
        };
      }

      set(currentState => ({
        processingState: {
          ...currentState.processingState,
          isApplyingFix: false,
          currentFixId: null,
          stage: null
        },
        editorState: {
          ...currentState.editorState,
          needsSync: true, // Editor needs to update
          content: null // Clear cached content to force regeneration from DocumentModel
        }
      }));

      // Emit fix applied event
      storeEvents.emit('fixApplied', {
        issueId,
        fixAction: result.fixAction,
        snapshotId: result.snapshotId
      });

      // Trigger incremental reanalysis if content changed
      if (!result.updatedDocument) {
        // Content fix - trigger incremental analysis
        setTimeout(() => {
          get().analyzeDocument({ incrementalOnly: true });
        }, 100);
      }

      return {
        success: true,
        fixedIssueId: result.fixedIssueId,
        fixAction: result.fixAction
      };

    } catch (error) {
      console.error('Error applying fix:', error);
      set(currentState => ({
        processingState: {
          ...currentState.processingState,
          isApplyingFix: false,
          currentFixId: null,
          lastError: error.message,
          stage: null
        }
      }));
      throw error;
    }
  },

  // === EDITOR SYNCHRONIZATION ===

  /**
   * Sync editor content with document model
   */
  syncWithEditor: (tiptapDocument, changesMeta = {}) => {
    const state = get();

    if (!state.documentModel || !tiptapDocument) {
      return { success: false, message: 'Missing document model or editor content' };
    }

    try {
      const result = state.documentService.syncWithEditor(state.documentModel, tiptapDocument, changesMeta);

      if (result.hasChanges) {
        set(currentState => ({
          editorState: {
            ...currentState.editorState,
            lastSyncTimestamp: Date.now(),
            needsSync: false
          },
          analysisState: {
            ...currentState.analysisState,
            pendingAnalysis: result.needsReanalysis
          }
        }));

        // Trigger debounced analysis if needed
        if (result.needsReanalysis) {
          get().scheduleIncrementalAnalysis();
        }

        // Emit sync event
        storeEvents.emit('editorSynced', {
          changedParagraphs: result.changedParagraphs.map(p => p.id),
          documentVersion: result.documentVersion
        });
      }

      return result;

    } catch (error) {
      console.error('Error syncing with editor:', error);
      return { success: false, error: error.message };
    }
  },

  /**
   * Get current editor content from document model
   * NEW: Prefers stored tiptap_content (edited version) over generated content
   */
  getEditorContent: () => {
    const state = get();
    if (!state.documentModel) {
      return null;
    }

    // If we have saved tiptap_content in editorState, use it (edited version)
    if (state.editorState.content) {
      return state.editorState.content;
    }

    // Otherwise, generate from DocumentModel (original version)
    return state.documentModel.getTiptapJson();
  },

  /**
   * Schedule incremental analysis with smart debounce
   * @param {number} debounceMs - Debounce delay (default: 1000ms, reduced from 3000ms)
   */
  scheduleIncrementalAnalysis: (debounceMs = 1000) => {
    const state = get();

    // Cancel any in-flight analysis request
    if (state.analysisState.analysisAbortController) {
      state.analysisState.analysisAbortController.abort();
      console.log('🚫 Cancelled previous analysis request');
    }

    // Clear existing timeout
    if (state.analysisState.analysisDebounceTimeout) {
      clearTimeout(state.analysisState.analysisDebounceTimeout);
    }

    set(currentState => ({
      analysisState: {
        ...currentState.analysisState,
        analysisDebounceTimeout: null,
        analysisAbortController: null,
        pendingAnalysis: true
      }
    }));

    const timeoutId = setTimeout(async () => {
      try {
        await get().analyzeDocument({ incrementalOnly: true });
      } catch (error) {
        // Don't log if aborted
        if (error.name !== 'AbortError') {
          console.error('Scheduled analysis failed:', error);
        }
      }
    }, debounceMs);

    set(currentState => ({
      analysisState: {
        ...currentState.analysisState,
        analysisDebounceTimeout: timeoutId
      }
    }));
  },

  /**
   * Schedule auto-save with smart debounce
   * @param {boolean} immediate - If true, save immediately (for explicit actions)
   * @param {number} debounceMs - Debounce delay in milliseconds (default: 2000ms)
   */
  scheduleAutoSave: (immediate = false, debounceMs = 2000) => {
    const state = get();

    // Cancel any in-flight auto-save request
    if (state.autoSaveState.autoSaveAbortController) {
      state.autoSaveState.autoSaveAbortController.abort();
      console.log('🚫 Cancelled previous auto-save request');
    }

    // Mark as unsaved immediately
    set(currentState => ({
      autoSaveState: {
        ...currentState.autoSaveState,
        saveStatus: 'unsaved',
        autoSaveAbortController: null
      }
    }));

    // Clear existing timeout
    if (state.autoSaveState.autoSaveDebounceTimeout) {
      clearTimeout(state.autoSaveState.autoSaveDebounceTimeout);
    }

    // Immediate save for explicit actions
    if (immediate) {
      get().performAutoSave();
      return;
    }

    // Debounced save for typing
    const timeoutId = setTimeout(async () => {
      try {
        await get().performAutoSave();
      } catch (error) {
        console.error('Auto-save failed:', error);
      }
    }, debounceMs);

    set(currentState => ({
      autoSaveState: {
        ...currentState.autoSaveState,
        autoSaveDebounceTimeout: timeoutId
      }
    }));
  },

  /**
   * Perform auto-save to backend and Supabase
   */
  performAutoSave: async () => {
    const state = get();

    if (!state.documentModel) {
      return;
    }

    if (state.autoSaveState.isSaving) {
      return;
    }

    // Create new AbortController for this save operation
    const abortController = new AbortController();

    set(currentState => ({
      autoSaveState: {
        ...currentState.autoSaveState,
        isSaving: true,
        saveStatus: 'saving',
        lastSaveError: null,
        autoSaveAbortController: abortController
      }
    }));

    try {
      const result = await state.documentService.autoSaveDocument(state.documentModel, abortController.signal);

      // Check if request was aborted
      if (abortController.signal.aborted) {
        console.log('🚫 Auto-save was cancelled');
        return;
      }

      if (result.success) {
        set(currentState => ({
          autoSaveState: {
            ...currentState.autoSaveState,
            isSaving: false,
            lastSaveTimestamp: result.savedAt,
            saveStatus: 'saved',
            lastSaveError: null,
            autoSaveAbortController: null
          }
        }));

        // Emit save event
        storeEvents.emit('documentSaved', {
          timestamp: result.savedAt
        });

        console.log('✅ Auto-save completed successfully');

        // Trigger fast analysis after save (100ms delay)
        get().scheduleIncrementalAnalysis(100);

      } else {
        throw new Error(result.error || 'Auto-save failed');
      }

    } catch (error) {
      // Don't log error if it was aborted
      if (error.name === 'AbortError') {
        console.log('🚫 Auto-save request was aborted');
        return;
      }

      console.error('❌ Auto-save failed:', error);

      set(currentState => ({
        autoSaveState: {
          ...currentState.autoSaveState,
          isSaving: false,
          saveStatus: 'error',
          lastSaveError: error.message,
          autoSaveAbortController: null
        }
      }));
    }
  },

  // === DERIVED STATE GETTERS ===

  /**
   * Get document statistics
   */
  getDocumentStats: () => {
    const state = get();
    if (!state.documentModel) {
      return { wordCount: 0, charCount: 0, paragraphCount: 0 };
    }
    return state.documentModel.getStatistics();
  },

  /**
   * Get all issues (with hasFix corrected based on actual implementation)
   */
  getIssues: () => {
    const state = get();
    if (!state.documentModel) {
      return [];
    }
    const issues = state.documentModel.issues.getAllIssues();

    // Correct hasFix based on actual implementation availability
    return issues.map(issue => {
      if (issue.hasFix) {
        const isImplemented = state.documentService.isFixImplemented(issue.fixAction);
        return {
          ...issue,
          hasFix: isImplemented
        };
      }
      return issue;
    });
  },

  /**
   * Get compliance score
   */
  getComplianceScore: () => {
    const state = get();
    if (!state.documentModel) {
      return null;
    }

    const issues = state.documentModel.issues.getAllIssues();
    if (issues.length === 0) return 100;

    const criticalCount = issues.filter(i => i.severity === 'Critical').length;
    const majorCount = issues.filter(i => i.severity === 'Major').length;
    const minorCount = issues.filter(i => i.severity === 'Minor').length;

    return Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
  },

  /**
   * Get document info
   */
  getDocumentInfo: () => {
    const state = get();
    if (!state.documentModel) {
      return null;
    }
    return state.documentService.getDocumentInfo(state.documentModel);
  },

  // === UI STATE MANAGEMENT ===

  /**
   * Set active issue for highlighting
   */
  setActiveIssue: (issueId, options = {}) => {
    const { shouldScroll = true } = options;
    const previousId = get().uiState.activeIssueId;

    set(state => ({
      uiState: {
        ...state.uiState,
        activeIssueId: issueId
      }
    }));

    storeEvents.emit('activeIssueChanged', {
      previousId: previousId,
      shouldScroll: shouldScroll,
      currentId: issueId
    });
  },

  /**
   * Toggle issue highlighting
   */
  toggleIssueHighlighting: () => {
    set(state => ({
      uiState: {
        ...state.uiState,
        showIssueHighlighting: !state.uiState.showIssueHighlighting
      }
    }));
  },

  // === SNAPSHOT AND UNDO/REDO ===

  /**
   * Create document snapshot
   */
  createSnapshot: (description = 'User action') => {
    const state = get();
    if (!state.documentModel) {
      return null;
    }

    const snapshot = state.documentModel.createSnapshot();
    snapshot.description = description;

    set(currentState => {
      const newSnapshots = [...currentState.snapshots, snapshot];

      // Trim to max snapshots
      if (newSnapshots.length > currentState.maxSnapshots) {
        newSnapshots.shift();
      }

      return {
        snapshots: newSnapshots,
        currentSnapshotIndex: newSnapshots.length - 1
      };
    });

    return snapshot.id;
  },

  /**
   * Undo to previous snapshot
   */
  undo: () => {
    const state = get();
    if (!state.documentModel || state.currentSnapshotIndex < 0) {
      return false;
    }

    const snapshot = state.snapshots[state.currentSnapshotIndex];
    if (!snapshot) {
      return false;
    }

    try {
      state.documentModel.restoreFromSnapshot(snapshot);

      set(currentState => ({
        currentSnapshotIndex: currentState.currentSnapshotIndex - 1,
        editorState: {
          ...currentState.editorState,
          needsSync: true,
          content: null // Clear cached content to force regeneration from restored snapshot
        }
      }));

      storeEvents.emit('documentRestored', {
        snapshotId: snapshot.id,
        description: snapshot.description,
        type: 'undo'
      });

      return true;

    } catch (error) {
      console.error('Error during undo:', error);
      return false;
    }
  },

  /**
   * Check if undo is available
   */
  canUndo: () => {
    const state = get();
    return state.currentSnapshotIndex >= 0 && state.snapshots.length > 0;
  },

  // === EXPORT AND UTILITIES ===

  /**
   * Export document
   */
  exportDocument: async (format = 'html') => {
    const state = get();
    if (!state.documentModel) {
      throw new Error('No document loaded');
    }

    return await state.documentService.exportDocument(state.documentModel, format);
  },

  /**
   * Reset store state
   */
  reset: () => {
    const state = get();

    // Clear any pending timeouts
    if (state.analysisState.analysisDebounceTimeout) {
      clearTimeout(state.analysisState.analysisDebounceTimeout);
    }

    // Clear event listeners
    storeEvents.clear();

    set({
      documentModel: null,
      processingState: {
        isUploading: false,
        isAnalyzing: false,
        isApplyingFix: false,
        lastError: null,
        progress: 0,
        stage: null,
        currentFixId: null
      },
      editorState: {
        content: null,
        needsSync: false,
        lastSyncTimestamp: 0,
        isInitialized: false
      },
      analysisState: {
        lastAnalysisTimestamp: 0,
        pendingAnalysis: false,
        analysisDebounceTimeout: null,
        incrementalMode: true
      },
      uiState: {
        showIssueHighlighting: true,
        activeIssueId: null,
        selectedIssues: new Set()
      },
      snapshots: [],
      currentSnapshotIndex: -1
    });
  },

  // === TRANSACTION SUPPORT ===

  /**
   * Create transaction for atomic operations
   */
  createTransaction: () => {
    const state = get();
    if (!state.documentModel) {
      throw new Error('No document model available');
    }

    return new DocumentTransaction(state.documentModel, state.changeTracker);
  },

  // === DEBUGGING AND DEVELOPMENT ===

  /**
   * Get store state for debugging
   */
  _getDebugInfo: () => {
    const state = get();
    return {
      hasDocument: !!state.documentModel,
      documentId: state.documentModel?.id,
      documentVersion: state.documentModel?.version,
      paragraphCount: state.documentModel?.paragraphOrder.length || 0,
      issueCount: state.documentModel?.issues.getAllIssues().length || 0,
      processingState: state.processingState,
      editorState: state.editorState,
      analysisState: state.analysisState,
      snapshotCount: state.snapshots.length
    };
  }
}));

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\styles\tiptap.css
/* Tiptap/ProseMirror Editor Styles */

/* Basic editor styles */
.ProseMirror {
  min-height: 500px;
  max-height: none;
  outline: none;
  padding: 2rem;
  overflow-y: visible;
  /* Don't override document fonts - let the content decide */
  /* font-family: 'Times New Roman', serif; */
  /* font-size: 12pt; */
  /* line-height: 2; */
}

.ProseMirror p[data-style-name] {
  /* Paragraphs with style names should use their own formatting */
  margin: 0;
  padding: 0;
}

.ProseMirror p {
  /* Default paragraph styles - will be overridden by inline styles */
  margin: 0;
  padding: 0;
}

.ProseMirror h1,
.ProseMirror h2,
.ProseMirror h3,
.ProseMirror h4,
.ProseMirror h5,
.ProseMirror h6 {
  margin: 1em 0 0.5em 0;
  font-weight: bold;
}

.ProseMirror h1 { font-size: 2em; }
.ProseMirror h2 { font-size: 1.5em; }
.ProseMirror h3 { font-size: 1.3em; }
.ProseMirror h4 { font-size: 1.1em; }
.ProseMirror h5 { font-size: 1em; }
.ProseMirror h6 { font-size: 0.9em; }

/* Focus styles */
.ProseMirror:focus {
  outline: none;
}

/* Issue highlighting styles */
.apa-issue {
  cursor: text; /* Changed from pointer to text to indicate normal editing */
  transition: all 0.3s ease;
  position: relative;
  border-bottom-width: 2px;
  border-bottom-style: solid;
  border-radius: 3px;
  padding: 1px 2px;
}

/* Show pointer cursor only when Ctrl key is held (simulated via title attribute) */
.apa-issue:hover {
  /* Add a subtle hint that Ctrl+click is available */
  opacity: 0.9;
}

/* Add a tooltip-like indication for issue selection */
.apa-issue::after {
  content: attr(title);
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 1000;
}

.apa-issue:hover::after {
  opacity: 1;
}

/* Critical issues - Red */
.apa-critical {
  background-color: rgba(254, 202, 202, 0.4);
  border-bottom-color: rgb(239, 68, 68);
}

.apa-critical:hover {
  background-color: rgba(254, 202, 202, 0.6);
  transform: translateY(-1px);
}

.apa-critical.apa-active {
  background: linear-gradient(135deg, rgba(239, 68, 68, 0.15), rgba(239, 68, 68, 0.25));
  border: 2px solid rgb(239, 68, 68);
  border-radius: 6px;
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
  position: relative;
  z-index: 10;
}

.apa-critical.apa-active::before {
  content: '';
  position: absolute;
  inset: -3px;
  background: linear-gradient(45deg, transparent, rgba(239, 68, 68, 0.1), transparent);
  border-radius: 6px;
  z-index: -1;
  animation: subtleGlow 3s ease-in-out infinite;
}

/* Major issues - Orange */
.apa-major {
  background-color: rgba(254, 215, 170, 0.4);
  border-bottom-color: rgb(251, 146, 60);
}

.apa-major:hover {
  background-color: rgba(254, 215, 170, 0.6);
  transform: translateY(-1px);
}

.apa-major.apa-active {
  background: linear-gradient(135deg, rgba(251, 146, 60, 0.15), rgba(251, 146, 60, 0.25));
  border: 2px solid rgb(251, 146, 60);
  border-radius: 6px;
  box-shadow: 0 0 0 2px rgba(251, 146, 60, 0.2);
  position: relative;
  z-index: 10;
}

.apa-major.apa-active::before {
  content: '';
  position: absolute;
  inset: -3px;
  background: linear-gradient(45deg, transparent, rgba(251, 146, 60, 0.1), transparent);
  border-radius: 6px;
  z-index: -1;
  animation: subtleGlow 3s ease-in-out infinite;
}

/* Minor issues - Blue */
.apa-minor {
  background-color: rgba(191, 219, 254, 0.4);
  border-bottom-color: rgb(59, 130, 246);
}

.apa-minor:hover {
  background-color: rgba(191, 219, 254, 0.6);
  transform: translateY(-1px);
}

.apa-minor.apa-active {
  background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(59, 130, 246, 0.25));
  border: 2px solid rgb(59, 130, 246);
  border-radius: 6px;
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  position: relative;
  z-index: 10;
}

.apa-minor.apa-active::before {
  content: '';
  position: absolute;
  inset: -3px;
  background: linear-gradient(45deg, transparent, rgba(59, 130, 246, 0.1), transparent);
  border-radius: 8px;
  z-index: -1;
  animation: subtleGlow 3s ease-in-out infinite;
}

/* Default issues */
.apa-default {
  background-color: rgba(229, 231, 235, 0.5);
  border-bottom-color: rgb(107, 114, 128);
}

/* Overlapping highlights */
.apa-issue + .apa-issue {
  margin-left: 2px;
}

/* Placeholder */
.ProseMirror p.is-editor-empty:first-child::before {
  content: attr(data-placeholder);
  float: left;
  color: #adb5bd;
  pointer-events: none;
  height: 0;
}

/* Selection styles */
.ProseMirror ::selection {
  background: rgba(16, 185, 129, 0.2);
}

/* Fix for proper text rendering */
.ProseMirror-focused {
  outline: none;
}

/* Don't override paragraph spacing - let the document formatting decide */
/* .ProseMirror p + p {
  margin-top: 0;
} */

/* Preserve all inline styles */
.ProseMirror span[style] {
  /* Ensure inline styles are respected */
}

/* Formatted paragraph node */
.ProseMirror p[style] {
  /* Ensure paragraph styles are respected */
}

/* Code and pre styles if needed */
.ProseMirror pre {
  background: #f5f5f5;
  color: #333;
  font-family: 'Courier New', monospace;
  padding: 0.75rem 1rem;
  border-radius: 0.25rem;
}

.ProseMirror code {
  background: #f5f5f5;
  color: #333;
  font-family: 'Courier New', monospace;
  padding: 0.2em 0.4em;
  border-radius: 0.125rem;
}

/* Subtle glow animation for active issues */
@keyframes subtleGlow {
  0%, 100% {
    opacity: 0.3;
    transform: scale(1);
  }
  50% {
    opacity: 0.6;
    transform: scale(1.01);
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\additionalApaRules.js
// src/utils/additionalApaRules.js - Additional APA 7th edition rules
'use client';

export class AdditionalAPARules {
  constructor() {
    // Patterns for additional APA rules
    this.patterns = {
      // Footnotes
      footnote: /\[\^?\d+\]|\(\*+\)|[¹²³⁴⁵⁶⁷⁸⁹⁰]+/g,
      
      // Mathematical equations
      equation: /[∑∏∫∂∇±√∞≈≠≤≥]/,
      inlineEquation: /\$[^$]+\$/g,
      displayEquation: /\$\$[^$]+\$\$/g,
      
      // Legal references
      legalCase: /v\.\s+[A-Z]/g,
      legalCitation: /\d+\s+[A-Z]\.\s*[A-Z]\.\s*(?:2d|3d)?\s*\d+/g,
      
      // Social media citations
      twitter: /@[a-zA-Z0-9_]+/g,
      hashtag: /#[a-zA-Z0-9_]+/g,
      
      // Conference papers
      conference: /(?:Conference|Symposium|Proceedings|Meeting)\s+(?:on|of)/gi,
      
      // Data availability
      dataStatement: /data\s+(?:are|is|were|was)\s+available/gi,
      openData: /open\s+(?:data|science|access)/gi,
      
      // Supplemental materials
      supplemental: /supplementa[lr](?:y)?\s+(?:material|data|file|information|table|figure)/gi
    };
  }
  
  /**
   * Validate footnotes according to APA 7th edition
   */
  validateFootnotes(text, structure) {
    const issues = [];
    const footnotes = text.match(this.patterns.footnote) || [];
    
    if (footnotes.length > 0) {
      // APA prefers to minimize footnote use
      issues.push({
        title: "Footnotes detected",
        description: "APA style discourages extensive use of footnotes",
        text: footnotes[0],
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "Use footnotes sparingly. Consider incorporating content into main text or using parenthetical information."
      });
      
      // Check footnote formatting
      footnotes.forEach(footnote => {
        if (footnote.includes('[') && footnote.includes(']')) {
          issues.push({
            title: "Incorrect footnote format",
            description: "Use superscript numbers for footnotes",
            text: footnote,
            severity: "Minor",
            category: "formatting",
            hasFix: false,
            explanation: "Format footnotes as superscript numbers (¹, ², ³) not [1], [2], [3]"
          });
        }
      });
    }
    
    return issues;
  }
  
  /**
   * Validate mathematical equations formatting
   */
  validateMathematicalEquations(text, structure) {
    const issues = [];
    
    // Check for mathematical symbols
    if (this.patterns.equation.test(text)) {
      const inlineEqs = text.match(this.patterns.inlineEquation) || [];
      const displayEqs = text.match(this.patterns.displayEquation) || [];
      
      // Check inline equations
      inlineEqs.forEach(eq => {
        if (eq.length > 50) {
          issues.push({
            title: "Long inline equation",
            description: "Complex equations should be displayed on separate lines",
            text: eq.substring(0, 30) + '...',
            severity: "Minor",
            category: "formatting",
            hasFix: false,
            explanation: "Display complex equations on separate lines and number them"
          });
        }
      });
      
      // Check if display equations are numbered
      displayEqs.forEach((eq, index) => {
        const eqPosition = text.indexOf(eq);
        const nearbyText = text.substring(eqPosition - 20, eqPosition + eq.length + 20);
        
        if (!nearbyText.match(/\(\d+\)/)) {
          issues.push({
            title: "Unnumbered display equation",
            description: "Display equations should be numbered",
            text: eq.substring(0, 30) + '...',
            severity: "Minor",
            category: "formatting",
            hasFix: false,
            explanation: "Number display equations consecutively: (1), (2), etc."
          });
        }
      });
    }
    
    return issues;
  }
  
  /**
   * Validate legal references formatting
   */
  validateLegalReferences(text) {
    const issues = [];
    const reportedTypes = new Set();
    
    // Check for legal case citations
    const legalCases = text.match(this.patterns.legalCase) || [];
    
    legalCases.forEach(legalCase => {
      if (!reportedTypes.has('legal-italics')) {
        const casePosition = text.indexOf(legalCase);
        const fullCase = text.substring(Math.max(0, casePosition - 30), casePosition + 50);
        
        issues.push({
          title: "Legal case name formatting",
          description: "Legal case names should be italicized",
          text: fullCase,
          severity: "Minor",
          category: "references",
          hasFix: false,
          explanation: "Italicize case names: *Brown v. Board of Education*"
        });
        reportedTypes.add('legal-italics');
      }
    });
    
    // Check for legal citations
    const legalCitations = text.match(this.patterns.legalCitation) || [];
    
    if (legalCitations.length > 0 && !reportedTypes.has('legal-format')) {
      issues.push({
        title: "Legal citation format",
        description: "Verify legal citation follows Bluebook format",
        text: legalCitations[0],
        severity: "Minor",
        category: "references",
        hasFix: false,
        explanation: "Legal citations should follow standard legal citation format"
      });
      reportedTypes.add('legal-format');
    }
    
    return issues;
  }
  
  /**
   * Validate social media citations
   */
  validateSocialMediaCitations(text) {
    const issues = [];
    const reportedTypes = new Set();
    
    // Check for Twitter handles
    const twitterHandles = text.match(this.patterns.twitter) || [];
    
    twitterHandles.forEach(handle => {
      if (!reportedTypes.has('twitter-citation')) {
        const handlePosition = text.indexOf(handle);
        const context = text.substring(Math.max(0, handlePosition - 50), handlePosition + 50);
        
        // Check if it's in a reference or citation
        if (context.includes('Twitter') || context.includes('Tweet')) {
          issues.push({
            title: "Social media citation format",
            description: "Include full citation information for social media",
            text: context,
            severity: "Minor",
            category: "references",
            hasFix: false,
            explanation: "Format: Author, A. [@username]. (Year, Month Day). Content [Tweet]. Twitter. URL"
          });
          reportedTypes.add('twitter-citation');
        }
      }
    });
    
    return issues;
  }
  
  /**
   * Validate conference paper citations
   */
  validateConferencePapers(text) {
    const issues = [];
    const reportedTypes = new Set();
    
    const conferences = text.match(this.patterns.conference) || [];
    
    conferences.forEach(conf => {
      if (!reportedTypes.has('conference-format')) {
        const confPosition = text.indexOf(conf);
        const context = text.substring(Math.max(0, confPosition - 100), confPosition + 100);
        
        // Check if it's in references section
        if (context.includes('In ') || context.includes('Paper presented')) {
          // Check for location
          if (!context.match(/,\s+[A-Z][a-z]+(?:,\s+[A-Z]{2})?(?:,\s+[A-Z][a-z]+)?/)) {
            issues.push({
              title: "Conference paper missing location",
              description: "Conference presentations need location information",
              text: context.substring(0, 60) + '...',
              severity: "Minor",
              category: "references",
              hasFix: false,
              explanation: "Include conference location: City, State/Country"
            });
            reportedTypes.add('conference-format');
          }
        }
      }
    });
    
    return issues;
  }
  
  /**
   * Validate data availability statements
   */
  validateDataAvailability(text) {
    const issues = [];
    
    // Check if research paper (has method/results sections)
    const hasMethodSection = /\bMethod(?:s|ology)?\b/i.test(text);
    const hasResultsSection = /\bResults?\b/i.test(text);
    
    if (hasMethodSection && hasResultsSection) {
    }
    
    return issues;
  }
  
  /**
   * Validate supplemental materials references
   */
  validateSupplementalMaterials(text) {
    const issues = [];
    const supplementalRefs = text.match(this.patterns.supplemental) || [];
    
    supplementalRefs.forEach(ref => {
      const refPosition = text.indexOf(ref);
      const context = text.substring(Math.max(0, refPosition - 50), refPosition + 100);
      
      // Check if properly referenced
      if (!context.match(/see|refer|available|found|included/i)) {
        issues.push({
          title: "Supplemental material reference unclear",
          description: "Clearly indicate how to access supplemental materials",
          text: context,
          severity: "Minor",
          category: "content",
          hasFix: false,
          explanation: "Specify where supplemental materials can be found (e.g., 'see Supplemental Material online')"
        });
      }
      
      // Check naming convention
      if (!ref.match(/Supplement(?:al|ary)\s+(?:Table|Figure)\s+[A-Z]?\d+/)) {
        issues.push({
          title: "Supplemental material naming",
          description: "Use consistent naming for supplemental materials",
          text: ref,
          severity: "Minor",
          category: "formatting",
          hasFix: false,
          explanation: "Label as 'Supplemental Table S1', 'Supplemental Figure S1', etc."
        });
      }
    });
    
    return issues;
  }
  
  /**
   * Main validation function for additional rules
   */
  validateAdditionalRules(text, structure) {
    const issues = [];
    
    // Run all additional validations
    issues.push(...this.validateFootnotes(text, structure));
    issues.push(...this.validateMathematicalEquations(text, structure));
    issues.push(...this.validateLegalReferences(text));
    issues.push(...this.validateSocialMediaCitations(text));
    issues.push(...this.validateConferencePapers(text));
    issues.push(...this.validateDataAvailability(text));
    issues.push(...this.validateSupplementalMaterials(text));
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\advancedCitationValidator.js
// src/utils/advancedCitationValidator.js - Advanced citation validation
'use client';

export class AdvancedCitationValidator {
  constructor() {
    this.narrativeCitationPattern = /([A-Z][a-z]+(?:\s+(?:and|&)\s+[A-Z][a-z]+)*)\s+\((\d{4}[a-z]?)\)/g;
    this.parentheticalCitationPattern = /\(([^)]+,\s*\d{4}[a-z]?)\)/g;
  }

  /**
   * Validate advanced citation rules
   */
  validateAdvancedCitations(text, structure) {
    const issues = [];
    
    // Multiple authors formatting
    issues.push(...this.validateMultipleAuthors(text));
    
    // Secondary source citations
    issues.push(...this.validateSecondarySources(text));
    
    // Personal communication citations
    issues.push(...this.validatePersonalCommunications(text));
    
    // Group/corporate authors
    issues.push(...this.validateCorporateAuthors(text));
    
    // No date citations
    issues.push(...this.validateNoDateCitations(text));
    
    // Multiple works same author/year
    issues.push(...this.validateMultipleWorksSameYear(text));
    
    // Narrative vs parenthetical consistency
    issues.push(...this.validateCitationConsistency(text));
    
    return issues;
  }

  /**
   * Validate multiple authors formatting (up to 20 authors rules)
   */
  validateMultipleAuthors(text) {
    const issues = [];
    
    // Check for 3+ authors without et al.
    const threeAuthorsPattern = /\(([A-Z][a-z]+),\s+([A-Z][a-z]+),\s+(?:and|&)\s+([A-Z][a-z]+),\s+\d{4}\)/g;
    let match;
    
    while ((match = threeAuthorsPattern.exec(text)) !== null) {
      const citation = match[0];
      
      // For 3+ authors, first citation should list all, subsequent use et al.
      const firstAuthor = match[1];
      const etAlPattern = new RegExp(`\\(${firstAuthor},?\\s+et\\s+al\\.`, 'g');
      const hasEtAl = etAlPattern.test(text);
      
      if (!hasEtAl) {
        issues.push({
          title: "Multiple authors citation may need et al.",
          description: "Citations with 3+ authors should use 'et al.' after first mention",
          text: citation,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "After first citation, use: (FirstAuthor, et al., year)"
        });
      }
    }
    
    // Check for incorrect number of authors before et al.
    const etAlCitations = text.match(/\([^)]*et\s+al\.[^)]*\)/g) || [];
    etAlCitations.forEach(citation => {
      // Count commas before et al.
      const beforeEtAl = citation.split('et al.')[0];
      const authorCount = (beforeEtAl.match(/[A-Z][a-z]+/g) || []).length;
      
      if (authorCount > 2) {
        issues.push({
          title: "Too many authors before et al.",
          description: "List only first author before 'et al.' for 3+ authors",
          text: citation,
          severity: "Minor",
          category: "citations",
          hasFix: true,
          fixAction: "simplifyEtAlCitation",
          explanation: "Format: (FirstAuthor, et al., year) not (Author1, Author2, et al., year)"
        });
      }
    });
    
    // Check for 21+ authors rule
    const veryLongCitations = text.match(/\([^)]{200,}\)/g) || [];
    veryLongCitations.forEach(citation => {
      const authorCount = (citation.match(/[A-Z][a-z]+/g) || []).length;
      if (authorCount > 20) {
        issues.push({
          title: "Too many authors in citation",
          description: "For 21+ authors, cite first 19, then '...', then last author",
          text: citation.substring(0, 50) + '...',
          severity: "Major",
          category: "citations",
          hasFix: false,
          explanation: "Format: (Author1, Author2, ... Author19, ... LastAuthor, year)"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate secondary source citations (as cited in)
   */
  validateSecondarySources(text) {
    const issues = [];
    
    // Check for secondary source format
    const secondaryPattern = /\((?:as\s+)?cited\s+in\s+[^)]+\)/gi;
    const secondaryMatches = text.match(secondaryPattern) || [];
    
    secondaryMatches.forEach(citation => {
      // Check format: (Original, year, as cited in Secondary, year)
      if (!citation.match(/\([^,]+,\s*\d{4},?\s*as\s+cited\s+in\s+[^,]+,\s*\d{4}\)/i)) {
        issues.push({
          title: "Incorrect secondary source citation format",
          description: "Secondary citations need both original and secondary source years",
          text: citation,
          severity: "Major",
          category: "citations",
          hasFix: false,
          explanation: "Format: (OriginalAuthor, OriginalYear, as cited in SecondaryAuthor, SecondaryYear)"
        });
      }
    });
    
    // Check if primary source is in references
    const primarySources = text.match(/\(([^,]+),\s*\d{4},?\s*as\s+cited\s+in/gi) || [];
    if (primarySources.length > 0) {
      issues.push({
        title: "Secondary source used",
        description: "Consider finding and citing the primary source directly",
        text: primarySources[0],
        severity: "Minor",
        category: "citations",
        hasFix: false,
        explanation: "Only the secondary source should appear in references, not the original"
      });
    }
    
    return issues;
  }

  /**
   * Validate personal communication citations
   */
  validatePersonalCommunications(text) {
    const issues = [];
    
    // Check for personal communication format
    const personalCommPattern = /\(([^,)]+),\s*personal\s+communication,?\s*([^)]+)\)/gi;
    const personalComms = text.match(personalCommPattern) || [];
    
    personalComms.forEach(citation => {
      // Check for date format
      if (!citation.match(/,\s*(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},\s*\d{4}/)) {
        issues.push({
          title: "Personal communication missing full date",
          description: "Personal communications need full date (Month Day, Year)",
          text: citation,
          severity: "Major",
          category: "citations",
          hasFix: false,
          explanation: "Format: (J. Smith, personal communication, January 15, 2024)"
        });
      }
      
      // Check if in references (shouldn't be)
      const author = citation.match(/\(([^,]+),/)?.[1];
      if (author && text.includes('References') && text.indexOf('References') < text.length - 1000) {
        const referencesSection = text.substring(text.indexOf('References'));
        if (referencesSection.includes(author) && referencesSection.includes('personal communication')) {
          issues.push({
            title: "Personal communication in references",
            description: "Personal communications should not appear in reference list",
            text: citation,
            severity: "Major",
            category: "citations",
            hasFix: false,
            explanation: "Personal communications are cited in text only, not in references"
          });
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate corporate/group author citations
   */
  validateCorporateAuthors(text) {
    const issues = [];
    
    // Common corporate authors
    const corporatePattern = /\((?:American\s+Psychological\s+Association|World\s+Health\s+Organization|National\s+Institute|Centers\s+for\s+Disease|Department\s+of|Ministry\s+of|University\s+of)[^,)]*[,)]/gi;
    const corporateMatches = text.match(corporatePattern) || [];
    
    corporateMatches.forEach(citation => {
      // Check for abbreviation on first use
      const fullName = citation.match(/\(([^,)]+)/)?.[1];
      if (fullName && fullName.length > 20) {
        // Check if abbreviation is defined
        const abbrevPattern = new RegExp(`${fullName}\\s*\\[([A-Z]+)\\]`, 'i');
        const hasAbbrev = abbrevPattern.test(text.substring(0, text.indexOf(citation)));
        
        if (!hasAbbrev) {
          issues.push({
            title: "Long corporate author without abbreviation",
            description: "Define abbreviation for long organizational names on first use",
            text: citation.substring(0, 50) + '...',
            severity: "Minor",
            category: "citations",
            hasFix: false,
            explanation: "First use: (American Psychological Association [APA], 2020), then: (APA, 2020)"
          });
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate no date citations
   */
  validateNoDateCitations(text) {
    const issues = [];
    
    // Check for n.d. citations
    const ndPattern = /\(([^,)]+),\s*n\.d\.\)/g;
    const ndMatches = text.match(ndPattern) || [];
    
    if (ndMatches.length > 0) {
      // Check if used consistently
      ndMatches.forEach(citation => {
        const author = citation.match(/\(([^,]+),/)?.[1];
        if (author) {
          // Check if same author has dated citations too
          const datedPattern = new RegExp(`\\(${author},\\s*\\d{4}\\)`, 'g');
          if (datedPattern.test(text)) {
            issues.push({
              title: "Inconsistent dating for same author",
              description: `${author} has both dated and undated (n.d.) citations`,
              text: citation,
              severity: "Major",
              category: "citations",
              hasFix: false,
              explanation: "Verify if all works by this author have publication dates"
            });
          }
        }
      });
      
      // General warning about n.d. usage
      if (ndMatches.length > 3) {
        issues.push({
          title: "Multiple undated sources",
          description: "Document has many n.d. citations - verify if dates can be found",
          text: `${ndMatches.length} instances of n.d.`,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "Use (n.d.) only when publication date truly cannot be determined"
        });
      }
    }
    
    return issues;
  }

  /**
   * Validate multiple works by same author in same year
   */
  validateMultipleWorksSameYear(text) {
    const issues = [];
    
    // Find citations with letter suffixes (2021a, 2021b)
    const suffixPattern = /\(([^,)]+),\s*(\d{4})([a-z])\)/g;
    const suffixMatches = [...text.matchAll(suffixPattern)];
    
    const authorYearMap = new Map();
    
    suffixMatches.forEach(match => {
      const author = match[1];
      const year = match[2];
      const suffix = match[3];
      const key = `${author}_${year}`;
      
      if (!authorYearMap.has(key)) {
        authorYearMap.set(key, new Set());
      }
      authorYearMap.get(key).add(suffix);
    });
    
    // Check for missing or inconsistent suffixes
    authorYearMap.forEach((suffixes, key) => {
      const suffixArray = Array.from(suffixes).sort();
      
      // Check if sequence starts with 'a'
      if (!suffixArray.includes('a')) {
        const [author, year] = key.split('_');
        issues.push({
          title: "Letter suffix doesn't start with 'a'",
          description: `${author} (${year}) citations should start with 'a'`,
          text: `${author}, ${year}${suffixArray[0]}`,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "Multiple works same year should be labeled: 2024a, 2024b, 2024c..."
        });
      }
      
      // Check for gaps in sequence
      for (let i = 1; i < suffixArray.length; i++) {
        const expected = String.fromCharCode(suffixArray[0].charCodeAt(0) + i);
        if (suffixArray[i] !== expected) {
          const [author, year] = key.split('_');
          issues.push({
            title: "Gap in letter suffix sequence",
            description: `${author} (${year}) has non-consecutive letter suffixes`,
            text: `${suffixArray.join(', ')}`,
            severity: "Minor",
            category: "citations",
            hasFix: false,
            explanation: "Use consecutive letters: a, b, c, not a, c, d"
          });
          break;
        }
      }
    });
    
    return issues;
  }

  /**
   * Check narrative vs parenthetical citation consistency
   */
  validateCitationConsistency(text) {
    const issues = [];
    
    // Extract all citations
    const narrativeMatches = [...text.matchAll(this.narrativeCitationPattern)];
    const parentheticalMatches = [...text.matchAll(this.parentheticalCitationPattern)];
    
    // Track which style is used for each source
    const citationStyles = new Map();
    
    narrativeMatches.forEach(match => {
      const author = match[1];
      const year = match[2];
      const key = `${author}_${year}`;
      
      if (!citationStyles.has(key)) {
        citationStyles.set(key, { narrative: 0, parenthetical: 0 });
      }
      citationStyles.get(key).narrative++;
    });
    
    parentheticalMatches.forEach(match => {
      const citation = match[1];
      const authorMatch = citation.match(/([^,]+),\s*(\d{4})/);
      if (authorMatch) {
        const author = authorMatch[1].replace(/\s*&\s*/g, ' and ');
        const year = authorMatch[2];
        const key = `${author}_${year}`;
        
        if (!citationStyles.has(key)) {
          citationStyles.set(key, { narrative: 0, parenthetical: 0 });
        }
        citationStyles.get(key).parenthetical++;
      }
    });
    
    // Check for overuse of one style
    let totalNarrative = 0;
    let totalParenthetical = 0;
    
    citationStyles.forEach(style => {
      totalNarrative += style.narrative;
      totalParenthetical += style.parenthetical;
    });
    
    if (totalNarrative > 0 && totalParenthetical > 0) {
      const ratio = totalNarrative / totalParenthetical;
      
      if (ratio > 5 || ratio < 0.2) {
        issues.push({
          title: "Imbalanced citation style usage",
          description: ratio > 5 ? "Overuse of narrative citations" : "Overuse of parenthetical citations",
          text: `Narrative: ${totalNarrative}, Parenthetical: ${totalParenthetical}`,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "Vary citation style for better readability. Use narrative when author is subject, parenthetical for support."
        });
      }
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\biasFreeLanguageValidator.js
// src/utils/biasFreeLanguageValidator.js - Bias-free and inclusive language validation
'use client';

export class BiasFreeLanguageValidator {
  constructor() {
    // Gendered terms to avoid
    this.genderedTerms = {
      'mankind': 'humanity, humankind, people',
      'man-made': 'artificial, synthetic, manufactured',
      'chairman': 'chair, chairperson, coordinator',
      'policeman': 'police officer',
      'fireman': 'firefighter',
      'mailman': 'mail carrier, postal worker',
      'businessman': 'business person, executive',
      'manpower': 'workforce, personnel, staff',
      'man hours': 'work hours, person hours',
      'freshman': 'first-year student',
      'upperclassman': 'upper-level student',
      'forefathers': 'ancestors, founders',
      'mothering': 'parenting, nurturing',
      'fathering': 'parenting'
    };
    
    // Outdated disability terms
    this.disabilityTerms = {
      'handicapped': 'person with a disability',
      'crippled': 'person with a physical disability',
      'retarded': 'person with an intellectual disability',
      'mentally ill': 'person with a mental health condition',
      'suffers from': 'has, experiences',
      'victim of': 'person with, person who has',
      'wheelchair-bound': 'wheelchair user',
      'confined to a wheelchair': 'uses a wheelchair',
      'normal people': 'people without disabilities',
      'able-bodied': 'people without disabilities',
      'invalid': 'person with a disability',
      'afflicted with': 'has, experiences'
    };
    
    // Age-related biased terms
    this.ageTerms = {
      'elderly': 'older adults, older people',
      'senile': 'person with dementia',
      'old people': 'older adults',
      'the aged': 'older adults',
      'geriatric': 'older adult (unless medical context)'
    };
    
    // Racial/ethnic considerations
    this.racialConsiderations = {
      'minorities': 'specific group names or "people of color"',
      'non-white': 'people of color or specific groups',
      'oriental': 'Asian or specific nationality',
      'hispanic': 'Latino/Latina/Latinx or specific nationality',
      'indian': 'Native American, Indigenous, or specific tribe'
    };
  }

  /**
   * Main validation for bias-free language
   */
  validateBiasFreeLanguage(text, structure) {
    const issues = [];
    
    // Check gendered language
    issues.push(...this.checkGenderedLanguage(text));
    
    // Check person-first language for disabilities
    issues.push(...this.checkPersonFirstLanguage(text));
    
    // Check age-appropriate terminology
    issues.push(...this.checkAgeTerminology(text));
    
    // Check racial/ethnic terminology
    issues.push(...this.checkRacialEthnicTerminology(text));
    
    // Check sexual orientation/gender identity terms
    issues.push(...this.checkSOGITerminology(text));
    
    // Check generic pronoun usage
    issues.push(...this.checkGenericPronouns(text));
    
    return issues;
  }

  /**
   * Check for gendered language with context awareness
   */
  checkGenderedLanguage(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    Object.entries(this.genderedTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 50), position + term.length + 50);
        
        // Context-aware checks to avoid false positives
        const contextExceptions = {
          'mailman': ['Mailman list', 'Mailman software'], // Software name
          'chairman': ['Chairman Mao', 'Chairman of the Board (proper title)'],
          'freshman': ['Freshman Composition (course name)']
        };
        
        // Skip if it's a proper noun or specific exception
        const exceptions = contextExceptions[term.toLowerCase()] || [];
        let isException = false;
        for (const exception of exceptions) {
          if (context.includes(exception)) {
            isException = true;
            break;
          }
        }
        
        // Also skip if in quotes (might be historical/direct quote)
        const inQuotes = (context.match(/["'][^"']*$/)?.[0] || '').includes(term);
        
        if (!isException && !inQuotes) {
          issues.push({
            title: "Gendered language detected",
            description: `"${firstMatch}" is gendered language`,
            text: context.trim(),
            severity: "Minor",
            category: "bias-free",
            hasFix: true,
            fixAction: "replaceGenderedTerm",
            fixValue: { original: firstMatch, replacement: alternative.split(',')[0].trim() },
            explanation: `Use gender-neutral terms: ${alternative}`
          });
          
          reportedTerms.add(term.toLowerCase());
        }
      }
    });
    
    // Check for generic "he" or "his"
    const genericHePattern = /\b(he|his|him)\b[^.]*(student|participant|person|individual|researcher|subject|child|adult|employee|worker)/gi;
    const heMatches = [...text.matchAll(genericHePattern)];
    
    if (heMatches.length > 2) {
      issues.push({
        title: "Generic masculine pronouns",
        description: "Avoid using 'he/his/him' as generic pronouns",
        text: heMatches[0][0],
        severity: "Minor",
        category: "bias-free",
        hasFix: false,
        explanation: "Use 'they/their', alternate pronouns, or rephrase to avoid pronouns"
      });
    }
    
    return issues;
  }

  /**
   * Check person-first language for disabilities
   */
  checkPersonFirstLanguage(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    // Check outdated disability terms
    Object.entries(this.disabilityTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        issues.push({
          title: "Consider person-first disability language",
          description: `"${firstMatch}" could use person-first language`,
          text: context,
          severity: "Minor", // FIXED: Changed from "Major" to "Minor"
          category: "bias-free",
          hasFix: true,
          fixAction: "usePersonFirst",
          fixValue: { original: firstMatch, replacement: alternative },
          explanation: `Consider person-first: "${alternative}" (though respect individual/community preferences)`
        });
        
        reportedTerms.add(term.toLowerCase());
      }
    });
    
    // Check for disability-first language patterns
    const disabilityFirstPatterns = [
      /\b(autistic|blind|deaf|disabled|epileptic|schizophrenic)\s+(person|people|individual|child|adult|student)/gi,
      /\bthe\s+(blind|deaf|disabled|mentally ill|handicapped)\b/gi
    ];
    
    disabilityFirstPatterns.forEach(pattern => {
      const matches = text.match(pattern) || [];
      if (matches.length > 0 && !reportedTerms.has('disability-first')) {
        issues.push({
          title: "Consider language preference",
          description: "Some prefer person-first, others identity-first language",
          text: matches[0],
          severity: "Minor", // FIXED: Changed from "Major" to "Minor"
          category: "bias-free",
          hasFix: false,
          explanation: "APA 7th: Use 'person with autism' OR 'autistic person' based on individual/community preference. When unknown, person-first is safer."
        });
        reportedTerms.add('disability-first');
      }
    });
    
    return issues;
  }

  /**
   * Check age-appropriate terminology
   */
  checkAgeTerminology(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    Object.entries(this.ageTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        // Check if in appropriate medical context
        const isMedicalContext = context.includes('geriatric medicine') || 
                                context.includes('geriatric care');
        
        if (!isMedicalContext || term !== 'geriatric') {
          issues.push({
            title: "Age-biased terminology",
            description: `"${firstMatch}" may be considered age-biased`,
            text: context,
            severity: "Minor",
            category: "bias-free",
            hasFix: true,
            fixAction: "replaceAgeTerm",
            fixValue: { original: firstMatch, replacement: alternative.split(',')[0].trim() },
            explanation: `Use: ${alternative}`
          });
          
          reportedTerms.add(term.toLowerCase());
        }
      }
    });
    
    // Check for specific age ranges
    const ageRangePattern = /\b(\d{2,3})[- ]years?[- ]old\b/gi;
    const ageMatches = text.match(ageRangePattern) || [];
    
    if (ageMatches.length > 0) {
      const ages = ageMatches.map(m => parseInt(m.match(/\d+/)[0]));
      const hasOlderAdults = ages.some(age => age >= 65);
      
      if (hasOlderAdults) {
        issues.push({
          title: "Consider age designations",
          description: "Be specific with age ranges for older adults",
          text: ageMatches[0],
          severity: "Minor",
          category: "bias-free",
          hasFix: false,
          explanation: "Use specific ages (65-80) rather than broad terms like 'elderly'"
        });
      }
    }
    
    return issues;
  }

  /**
   * Check racial and ethnic terminology
   */
  checkRacialEthnicTerminology(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    Object.entries(this.racialConsiderations).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        // Special handling for "Indian" - check if it's about India
        if (term === 'indian' && (context.includes('India') || context.includes('Indian Ocean'))) {
          return; // Skip if referring to country
        }
        
        issues.push({
          title: "Consider racial/ethnic terminology",
          description: `"${firstMatch}" may need more specific terminology`,
          text: context,
          severity: "Minor",
          category: "bias-free",
          hasFix: false,
          explanation: `Consider using: ${alternative}`
        });
        
        reportedTerms.add(term.toLowerCase());
      }
    });
    
    // Check for proper capitalization of racial/ethnic terms
    const lowercaseGroups = /\b(black|white|indigenous|asian|latino|latina)\s+(person|people|man|woman|participant)/g;
    const lowercaseMatches = text.match(lowercaseGroups) || [];
    
    lowercaseMatches.forEach(match => {
      const racial = match.split(/\s+/)[0];
      if (racial === racial.toLowerCase()) {
        issues.push({
          title: "Capitalize racial/ethnic designations",
          description: `Capitalize '${racial}' when referring to racial/ethnic groups`,
          text: match,
          severity: "Minor",
          category: "bias-free",
          hasFix: true,
          fixAction: "capitalizeRacialTerm",
          explanation: "Use 'Black person' not 'black person', 'White participants' not 'white participants'"
        });
      }
    });
    
    return issues;
  }

  /**
   * Check sexual orientation and gender identity terminology
   */
  checkSOGITerminology(text) {
    const issues = [];
    
    // Outdated or inappropriate terms
    const outdatedTerms = {
      'homosexual': 'gay, lesbian, or specific identity',
      'sexual preference': 'sexual orientation',
      'lifestyle choice': 'sexual orientation or gender identity',
      'transgenders': 'transgender people',
      'transgendered': 'transgender',
      'sex change': 'gender affirmation surgery',
      'opposite sex': 'different sex/gender',
      'both genders': 'all genders',
      'preferred pronouns': 'pronouns'
    };
    
    Object.entries(outdatedTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        issues.push({
          title: "Consider updated SOGI terminology",
          description: `"${firstMatch}" may be outdated terminology`,
          text: context,
          severity: "Minor", // FIXED: More nuanced - some terms may be contextually appropriate
          category: "bias-free",
          hasFix: true,
          fixAction: "updateSOGITerm",
          fixValue: { original: firstMatch, replacement: alternative.split(',')[0].trim() },
          explanation: `Consider: ${alternative} (check current community preferences)`
        });
      }
    });
    
    // Check for binary assumptions
    const binaryPatterns = [
      /\b(he|she)\s+or\s+(she|he)\b/gi,
      /\bmale\s+or\s+female\b/gi,
      /\bmen\s+and\s+women\b/gi,
      /\bboys\s+and\s+girls\b/gi
    ];
    
    let hasBinaryAssumption = false;
    binaryPatterns.forEach(pattern => {
      if (!hasBinaryAssumption && pattern.test(text)) {
        const match = text.match(pattern)[0];
        issues.push({
          title: "Binary gender assumption",
          description: "Consider inclusive language for all genders",
          text: match,
          severity: "Minor",
          category: "bias-free",
          hasFix: false,
          explanation: "Consider: 'all genders', 'they', or specific inclusive language"
        });
        hasBinaryAssumption = true;
      }
    });
    
    return issues;
  }

  /**
   * Check generic pronoun usage
   */
  checkGenericPronouns(text) {
    const issues = [];
    
    // Check for singular they usage (which is now acceptable)
    const singularTheyPattern = /\b(everyone|someone|anyone|each person|the student|the participant)\s+[^.]*\bthey\b/gi;
    const singularTheyMatches = text.match(singularTheyPattern) || [];
    
    // This is actually good - no issue needed, but we can provide positive feedback
    if (singularTheyMatches.length > 3) {
      // Good use of singular they - no issue
    }
    
    // Check for alternating pronouns (he/she throughout)
    const heCount = (text.match(/\bhe\b/gi) || []).length;
    const sheCount = (text.match(/\bshe\b/gi) || []).length;
    const theyCount = (text.match(/\bthey\b/gi) || []).length;
    
    if (heCount > 10 && sheCount < 2) {
      issues.push({
        title: "Overuse of masculine pronouns",
        description: "Document predominantly uses 'he' pronouns",
        text: `he: ${heCount} times, she: ${sheCount} times`,
        severity: "Minor",
        category: "bias-free",
        hasFix: false,
        explanation: "Balance pronoun use or use 'they' for generic references"
      });
    }
    
    if (sheCount > 10 && heCount < 2) {
      issues.push({
        title: "Overuse of feminine pronouns",
        description: "Document predominantly uses 'she' pronouns",
        text: `she: ${sheCount} times, he: ${heCount} times`,
        severity: "Minor",
        category: "bias-free",
        hasFix: false,
        explanation: "Balance pronoun use or use 'they' for generic references"
      });
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\ChangeTracker.js
'use client';

import { v4 as uuidv4 } from 'uuid';

/**
 * ChangeTracker - Efficient diff and change detection system
 * Enables incremental analysis and precise undo/redo functionality
 */
export class ChangeTracker {
  constructor() {
    this.changeThreshold = 50; // Minimum characters for significant change
    this.diffCache = new Map(); // Cache diff results for performance
    this.maxCacheSize = 100;
  }

  /**
   * Detect changes between two document states
   */
  detectChanges(oldContent, newContent) {
    if (!oldContent || !newContent) {
      return {
        hasChanges: true,
        type: 'complete-replacement',
        operations: [{
          type: 'replace-all',
          oldContent,
          newContent,
          timestamp: Date.now()
        }]
      };
    }

    // Check cache first
    const cacheKey = this._getCacheKey(oldContent, newContent);
    if (this.diffCache.has(cacheKey)) {
      return this.diffCache.get(cacheKey);
    }

    const operations = [];

    // Handle different content types
    if (this._isTiptapDocument(oldContent) && this._isTiptapDocument(newContent)) {
      const docChanges = this._detectTiptapDocumentChanges(oldContent, newContent);
      operations.push(...docChanges);
    } else if (typeof oldContent === 'string' && typeof newContent === 'string') {
      const textChanges = this._detectTextChanges(oldContent, newContent);
      operations.push(...textChanges);
    } else {
      // Generic object comparison
      const objectChanges = this._detectObjectChanges(oldContent, newContent);
      operations.push(...objectChanges);
    }

    const result = {
      hasChanges: operations.length > 0,
      type: this._classifyChangeType(operations),
      operations,
      timestamp: Date.now()
    };

    // Cache result
    this._cacheResult(cacheKey, result);

    return result;
  }

  /**
   * Apply change operations to content
   */
  applyChanges(baseContent, changes) {
    if (!changes.operations || changes.operations.length === 0) {
      return baseContent;
    }

    let result = this._cloneContent(baseContent);

    // Apply operations in sequence
    for (const operation of changes.operations) {
      result = this._applyOperation(result, operation);
    }

    return result;
  }

  /**
   * Create reverse operations for undo functionality
   */
  createReverseOperations(changes) {
    if (!changes.operations) {
      return { operations: [] };
    }

    const reverseOps = changes.operations.map(op => this._reverseOperation(op)).reverse();

    return {
      hasChanges: reverseOps.length > 0,
      type: 'reverse',
      operations: reverseOps,
      timestamp: Date.now()
    };
  }

  /**
   * Detect paragraph-level changes for incremental analysis
   */
  detectParagraphChanges(oldParagraphs, newParagraphs) {
    const changes = {
      added: [],
      removed: [],
      modified: [],
      moved: [],
      unchanged: []
    };

    // Convert to maps for efficient lookup
    const oldMap = new Map();
    const newMap = new Map();

    if (Array.isArray(oldParagraphs)) {
      oldParagraphs.forEach((para, index) => {
        const id = para.id || `temp-${index}`;
        oldMap.set(id, { ...para, index });
      });
    }

    if (Array.isArray(newParagraphs)) {
      newParagraphs.forEach((para, index) => {
        const id = para.id || `temp-${index}`;
        newMap.set(id, { ...para, index });
      });
    }

    // Find removed paragraphs
    for (const [id, oldPara] of oldMap) {
      if (!newMap.has(id)) {
        changes.removed.push({
          id,
          paragraph: oldPara,
          oldIndex: oldPara.index
        });
      }
    }

    // Find added and modified paragraphs
    for (const [id, newPara] of newMap) {
      const oldPara = oldMap.get(id);

      if (!oldPara) {
        // New paragraph
        changes.added.push({
          id,
          paragraph: newPara,
          newIndex: newPara.index
        });
      } else {
        // Check for modifications
        const paraChanges = this._compareParagraphs(oldPara, newPara);

        if (paraChanges.hasChanges) {
          changes.modified.push({
            id,
            oldParagraph: oldPara,
            newParagraph: newPara,
            changes: paraChanges,
            oldIndex: oldPara.index,
            newIndex: newPara.index
          });
        } else if (oldPara.index !== newPara.index) {
          // Moved paragraph
          changes.moved.push({
            id,
            paragraph: newPara,
            oldIndex: oldPara.index,
            newIndex: newPara.index
          });
        } else {
          // Unchanged paragraph
          changes.unchanged.push({
            id,
            paragraph: newPara,
            index: newPara.index
          });
        }
      }
    }

    return changes;
  }

  /**
   * Calculate change significance for analysis prioritization
   */
  calculateChangeSignificance(changes) {
    if (!changes.operations) {
      return 0;
    }

    let score = 0;

    changes.operations.forEach(op => {
      switch (op.type) {
        case 'paragraph-add':
        case 'paragraph-remove':
          score += 10;
          break;
        case 'text-replace':
          const textLength = (op.newText || '').length;
          score += Math.min(textLength / 10, 5);
          break;
        case 'formatting-change':
          score += 2;
          break;
        case 'move':
          score += 3;
          break;
        default:
          score += 1;
      }
    });

    return Math.min(score, 100); // Cap at 100
  }

  /**
   * Merge multiple change sets for batch processing
   */
  mergeChanges(changesList) {
    if (!changesList || changesList.length === 0) {
      return { operations: [], hasChanges: false };
    }

    if (changesList.length === 1) {
      return changesList[0];
    }

    const mergedOperations = [];
    let hasChanges = false;

    changesList.forEach(changes => {
      if (changes.operations) {
        mergedOperations.push(...changes.operations);
        hasChanges = hasChanges || changes.hasChanges;
      }
    });

    // Remove duplicate operations
    const uniqueOperations = this._deduplicateOperations(mergedOperations);

    return {
      hasChanges,
      type: 'merged',
      operations: uniqueOperations,
      timestamp: Date.now()
    };
  }

  // Private methods

  _detectTiptapDocumentChanges(oldDoc, newDoc) {
    const operations = [];

    if (!oldDoc.content || !newDoc.content) {
      return [{
        type: 'document-replace',
        oldContent: oldDoc,
        newContent: newDoc
      }];
    }

    const oldParagraphs = oldDoc.content.filter(node => node.type === 'paragraph');
    const newParagraphs = newDoc.content.filter(node => node.type === 'paragraph');

    const paragraphChanges = this.detectParagraphChanges(
      oldParagraphs.map((node, index) => ({
        id: node.id || `para-${index}`,
        node,
        index
      })),
      newParagraphs.map((node, index) => ({
        id: node.id || `para-${index}`,
        node,
        index
      }))
    );

    // Convert paragraph changes to operations
    paragraphChanges.added.forEach(change => {
      operations.push({
        type: 'paragraph-add',
        paragraphId: change.id,
        content: change.paragraph.node,
        index: change.newIndex
      });
    });

    paragraphChanges.removed.forEach(change => {
      operations.push({
        type: 'paragraph-remove',
        paragraphId: change.id,
        content: change.paragraph.node,
        index: change.oldIndex
      });
    });

    paragraphChanges.modified.forEach(change => {
      operations.push({
        type: 'paragraph-modify',
        paragraphId: change.id,
        oldContent: change.oldParagraph.node,
        newContent: change.newParagraph.node,
        oldIndex: change.oldIndex,
        newIndex: change.newIndex,
        changes: change.changes
      });
    });

    paragraphChanges.moved.forEach(change => {
      operations.push({
        type: 'paragraph-move',
        paragraphId: change.id,
        oldIndex: change.oldIndex,
        newIndex: change.newIndex
      });
    });

    return operations;
  }

  _detectTextChanges(oldText, newText) {
    if (oldText === newText) {
      return [];
    }

    // Simple diff algorithm for text changes
    const operations = [];

    // Check if it's a simple replacement
    if (oldText.length > 0 && newText.length > 0) {
      // Find common prefix and suffix
      let prefixLength = 0;
      while (prefixLength < oldText.length &&
             prefixLength < newText.length &&
             oldText[prefixLength] === newText[prefixLength]) {
        prefixLength++;
      }

      let suffixLength = 0;
      while (suffixLength < (oldText.length - prefixLength) &&
             suffixLength < (newText.length - prefixLength) &&
             oldText[oldText.length - 1 - suffixLength] === newText[newText.length - 1 - suffixLength]) {
        suffixLength++;
      }

      if (prefixLength > 0 || suffixLength > 0) {
        const oldMiddle = oldText.substring(prefixLength, oldText.length - suffixLength);
        const newMiddle = newText.substring(prefixLength, newText.length - suffixLength);

        if (oldMiddle !== newMiddle) {
          operations.push({
            type: 'text-replace',
            position: prefixLength,
            oldText: oldMiddle,
            newText: newMiddle,
            length: oldMiddle.length
          });
        }
      } else {
        // Complete replacement
        operations.push({
          type: 'text-replace',
          position: 0,
          oldText,
          newText,
          length: oldText.length
        });
      }
    } else if (oldText.length === 0) {
      // Insertion
      operations.push({
        type: 'text-insert',
        position: 0,
        text: newText
      });
    } else if (newText.length === 0) {
      // Deletion
      operations.push({
        type: 'text-delete',
        position: 0,
        text: oldText,
        length: oldText.length
      });
    }

    return operations;
  }

  _detectObjectChanges(oldObj, newObj) {
    const operations = [];

    // Simple object property comparison
    const oldKeys = Object.keys(oldObj || {});
    const newKeys = Object.keys(newObj || {});

    // Find removed properties
    oldKeys.forEach(key => {
      if (!(key in newObj)) {
        operations.push({
          type: 'property-remove',
          key,
          oldValue: oldObj[key]
        });
      }
    });

    // Find added and modified properties
    newKeys.forEach(key => {
      if (!(key in oldObj)) {
        operations.push({
          type: 'property-add',
          key,
          newValue: newObj[key]
        });
      } else if (JSON.stringify(oldObj[key]) !== JSON.stringify(newObj[key])) {
        operations.push({
          type: 'property-modify',
          key,
          oldValue: oldObj[key],
          newValue: newObj[key]
        });
      }
    });

    return operations;
  }

  _compareParagraphs(oldPara, newPara) {
    const changes = {
      hasChanges: false,
      textChanged: false,
      formattingChanged: false,
      positionChanged: false
    };

    // Compare text content
    const oldText = this._extractParagraphText(oldPara);
    const newText = this._extractParagraphText(newPara);

    if (oldText !== newText) {
      changes.hasChanges = true;
      changes.textChanged = true;
      changes.textDiff = this._detectTextChanges(oldText, newText);
    }

    // Compare formatting
    if (this._hasFormattingChanged(oldPara, newPara)) {
      changes.hasChanges = true;
      changes.formattingChanged = true;
    }

    // Compare position
    if (oldPara.index !== newPara.index) {
      changes.hasChanges = true;
      changes.positionChanged = true;
    }

    return changes;
  }

  _extractParagraphText(paragraph) {
    if (typeof paragraph === 'string') {
      return paragraph;
    }

    if (paragraph.text) {
      return paragraph.text;
    }

    if (paragraph.node && paragraph.node.content) {
      return paragraph.node.content
        .map(node => node.text || '')
        .join('');
    }

    return '';
  }

  _hasFormattingChanged(oldPara, newPara) {
    // Simple formatting comparison
    const oldFormatting = JSON.stringify(oldPara.formatting || {});
    const newFormatting = JSON.stringify(newPara.formatting || {});
    return oldFormatting !== newFormatting;
  }

  _applyOperation(content, operation) {
    switch (operation.type) {
      case 'text-replace':
        if (typeof content === 'string') {
          return content.substring(0, operation.position) +
                 operation.newText +
                 content.substring(operation.position + operation.length);
        }
        break;

      case 'text-insert':
        if (typeof content === 'string') {
          return content.substring(0, operation.position) +
                 operation.text +
                 content.substring(operation.position);
        }
        break;

      case 'text-delete':
        if (typeof content === 'string') {
          return content.substring(0, operation.position) +
                 content.substring(operation.position + operation.length);
        }
        break;

      case 'paragraph-add':
        if (this._isTiptapDocument(content)) {
          const newContent = [...content.content];
          newContent.splice(operation.index, 0, operation.content);
          return { ...content, content: newContent };
        }
        break;

      case 'paragraph-remove':
        if (this._isTiptapDocument(content)) {
          const newContent = [...content.content];
          newContent.splice(operation.index, 1);
          return { ...content, content: newContent };
        }
        break;

      case 'paragraph-modify':
        if (this._isTiptapDocument(content)) {
          const newContent = [...content.content];
          newContent[operation.newIndex] = operation.newContent;
          return { ...content, content: newContent };
        }
        break;

      case 'replace-all':
        return operation.newContent;
    }

    return content;
  }

  _reverseOperation(operation) {
    switch (operation.type) {
      case 'text-replace':
        return {
          type: 'text-replace',
          position: operation.position,
          oldText: operation.newText,
          newText: operation.oldText,
          length: operation.newText.length
        };

      case 'text-insert':
        return {
          type: 'text-delete',
          position: operation.position,
          text: operation.text,
          length: operation.text.length
        };

      case 'text-delete':
        return {
          type: 'text-insert',
          position: operation.position,
          text: operation.text
        };

      case 'paragraph-add':
        return {
          type: 'paragraph-remove',
          paragraphId: operation.paragraphId,
          content: operation.content,
          index: operation.index
        };

      case 'paragraph-remove':
        return {
          type: 'paragraph-add',
          paragraphId: operation.paragraphId,
          content: operation.content,
          index: operation.index
        };

      case 'paragraph-modify':
        return {
          type: 'paragraph-modify',
          paragraphId: operation.paragraphId,
          oldContent: operation.newContent,
          newContent: operation.oldContent,
          oldIndex: operation.newIndex,
          newIndex: operation.oldIndex,
          changes: operation.changes
        };

      case 'replace-all':
        return {
          type: 'replace-all',
          oldContent: operation.newContent,
          newContent: operation.oldContent
        };

      default:
        return operation;
    }
  }

  _classifyChangeType(operations) {
    if (operations.length === 0) return 'none';
    if (operations.length === 1) {
      return operations[0].type;
    }

    const types = new Set(operations.map(op => op.type));
    if (types.has('paragraph-add') || types.has('paragraph-remove')) {
      return 'structural';
    }
    if (types.has('text-replace') || types.has('text-insert') || types.has('text-delete')) {
      return 'content';
    }
    return 'mixed';
  }

  _isTiptapDocument(content) {
    return content &&
           typeof content === 'object' &&
           content.type === 'doc' &&
           Array.isArray(content.content);
  }

  _cloneContent(content) {
    if (typeof content === 'string') {
      return content;
    }
    return JSON.parse(JSON.stringify(content));
  }

  _deduplicateOperations(operations) {
    const seen = new Set();
    return operations.filter(op => {
      const key = `${op.type}-${op.position || op.index || 0}-${JSON.stringify(op.oldText || op.oldContent || '')}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  _getCacheKey(oldContent, newContent) {
    const oldHash = this._hashContent(oldContent);
    const newHash = this._hashContent(newContent);
    return `${oldHash}->${newHash}`;
  }

  _hashContent(content) {
    const str = typeof content === 'string' ? content : JSON.stringify(content);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
  }

  _cacheResult(key, result) {
    if (this.diffCache.size >= this.maxCacheSize) {
      // Remove oldest entries
      const keysToRemove = Array.from(this.diffCache.keys()).slice(0, 10);
      keysToRemove.forEach(k => this.diffCache.delete(k));
    }
    this.diffCache.set(key, result);
  }
}

/**
 * Transaction system for atomic document operations
 */
export class DocumentTransaction {
  constructor(documentModel, changeTracker) {
    this.id = uuidv4();
    this.documentModel = documentModel;
    this.changeTracker = changeTracker;
    this.operations = [];
    this.rollbackData = [];
    this.completed = false;
    this.rolledBack = false;
    this.startTime = Date.now();
  }

  /**
   * Update paragraph content
   */
  updateParagraph(paragraphId, changes) {
    if (this.completed) {
      throw new Error('Transaction already completed');
    }

    const paragraph = this.documentModel.paragraphs.get(paragraphId);
    if (!paragraph) {
      throw new Error(`Paragraph not found: ${paragraphId}`);
    }

    // Store rollback data
    this.rollbackData.push({
      type: 'paragraph-update',
      paragraphId,
      oldText: paragraph.text,
      oldFormatting: JSON.parse(JSON.stringify(paragraph.formatting)),
      oldChangeSequence: paragraph.changeSequence
    });

    this.operations.push({
      type: 'update-paragraph',
      paragraphId,
      changes,
      execute: () => paragraph.update(changes),
      rollback: () => this._rollbackParagraph(paragraphId)
    });

    return this;
  }

  /**
   * Add new paragraph
   */
  addParagraph(paragraph, index = -1) {
    if (this.completed) {
      throw new Error('Transaction already completed');
    }

    const insertIndex = index >= 0 ? index : this.documentModel.paragraphOrder.length;

    this.rollbackData.push({
      type: 'paragraph-add',
      paragraphId: paragraph.id,
      insertIndex
    });

    this.operations.push({
      type: 'add-paragraph',
      paragraph,
      index: insertIndex,
      execute: () => {
        this.documentModel.paragraphs.set(paragraph.id, paragraph);
        this.documentModel.paragraphOrder.splice(insertIndex, 0, paragraph.id);
      },
      rollback: () => this._rollbackParagraphAdd(paragraph.id, insertIndex)
    });

    return this;
  }

  /**
   * Remove paragraph
   */
  removeParagraph(paragraphId) {
    if (this.completed) {
      throw new Error('Transaction already completed');
    }

    const paragraph = this.documentModel.paragraphs.get(paragraphId);
    const index = this.documentModel.paragraphOrder.indexOf(paragraphId);

    if (!paragraph || index === -1) {
      throw new Error(`Paragraph not found: ${paragraphId}`);
    }

    this.rollbackData.push({
      type: 'paragraph-remove',
      paragraphId,
      paragraph: paragraph.clone(),
      index
    });

    this.operations.push({
      type: 'remove-paragraph',
      paragraphId,
      execute: () => {
        this.documentModel.paragraphs.delete(paragraphId);
        this.documentModel.paragraphOrder.splice(index, 1);
      },
      rollback: () => this._rollbackParagraphRemove(paragraphId, paragraph.clone(), index)
    });

    return this;
  }

  /**
   * Commit all operations atomically
   */
  async commit() {
    if (this.completed) {
      throw new Error('Transaction already completed');
    }

    try {
      // Execute all operations
      this.operations.forEach(op => op.execute());

      // Update document metadata
      this.documentModel.lastModified = Date.now();
      this.documentModel.version++;

      // Record transaction in change log
      this.documentModel.changeLog.recordChange({
        type: 'transaction-committed',
        transactionId: this.id,
        operationCount: this.operations.length,
        duration: Date.now() - this.startTime,
        operations: this.operations.map(op => ({
          type: op.type,
          paragraphId: op.paragraphId || null,
          changes: op.changes || null
        }))
      });

      this.completed = true;
      return true;

    } catch (error) {
      // Auto-rollback on error
      await this.rollback();
      throw error;
    }
  }

  /**
   * Rollback all operations
   */
  async rollback() {
    if (this.rolledBack) {
      return true;
    }

    try {
      // Execute rollback operations in reverse order
      this.operations.reverse().forEach(op => {
        try {
          op.rollback();
        } catch (error) {
          console.error(`Error rolling back operation ${op.type}:`, error);
        }
      });

      this.rolledBack = true;
      this.completed = true;

      // Record rollback in change log
      this.documentModel.changeLog.recordChange({
        type: 'transaction-rolled-back',
        transactionId: this.id,
        operationCount: this.operations.length
      });

      return true;

    } catch (error) {
      console.error('Error during transaction rollback:', error);
      return false;
    }
  }

  // Private rollback methods
  _rollbackParagraph(paragraphId) {
    const rollbackData = this.rollbackData.find(
      data => data.type === 'paragraph-update' && data.paragraphId === paragraphId
    );

    if (rollbackData) {
      const paragraph = this.documentModel.paragraphs.get(paragraphId);
      if (paragraph) {
        paragraph.text = rollbackData.oldText;
        paragraph.formatting = rollbackData.oldFormatting;
        paragraph.changeSequence = rollbackData.oldChangeSequence;
      }
    }
  }

  _rollbackParagraphAdd(paragraphId, insertIndex) {
    this.documentModel.paragraphs.delete(paragraphId);
    const orderIndex = this.documentModel.paragraphOrder.indexOf(paragraphId);
    if (orderIndex !== -1) {
      this.documentModel.paragraphOrder.splice(orderIndex, 1);
    }
  }

  _rollbackParagraphRemove(paragraphId, paragraph, index) {
    this.documentModel.paragraphs.set(paragraphId, paragraph);
    this.documentModel.paragraphOrder.splice(index, 0, paragraphId);
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\comprehensiveValidator.js
// src/utils/comprehensiveValidator.js - Lists, abbreviations, and appendix validation
'use client';

export class ComprehensiveValidator {
  constructor() {
    this.commonAbbreviations = {
      'e.g.': 'for example',
      'i.e.': 'that is',
      'etc.': 'and so forth',
      'vs.': 'versus',
      'cf.': 'compare',
      'viz.': 'namely'
    };
  }

  /**
   * Validate lists and seriation
   */
  validateListsAndSeriation(text) {
    const issues = [];
    
    // Check bulleted lists
    const bulletPatterns = [/^[•·▪▫◦‣⁃]\s+/gm, /^\*\s+/gm, /^-\s+/gm];
    let hasBullets = false;
    
    bulletPatterns.forEach(pattern => {
      if (pattern.test(text)) {
        hasBullets = true;
      }
    });
    
    if (hasBullets) {
      // Check for parallel structure in lists
      const bulletLines = text.split('\n').filter(line => 
        bulletPatterns.some(p => p.test(line))
      );
      
      
      // Check for punctuation consistency
      const withPeriods = bulletLines.filter(line => line.trim().endsWith('.')).length;
      const withoutPeriods = bulletLines.filter(line => 
        !line.trim().endsWith('.') && line.trim().length > 0
      ).length;
      
      if (withPeriods > 0 && withoutPeriods > 0) {
        issues.push({
          title: "Inconsistent list punctuation",
          description: "List items have mixed punctuation",
          severity: "Minor",
          category: "lists",
          hasFix: false,
          explanation: "Use periods for all items (complete sentences) or none (fragments)"
        });
      }
    }
    
    // Check numbered lists
    const numberedPattern = /^\d+[.)]\s+/gm;
    const numberedLines = text.split('\n').filter(line => numberedPattern.test(line));
    
    if (numberedLines.length > 1) {
      // Check sequence
      const numbers = numberedLines.map(line => 
        parseInt(line.match(/^(\d+)/)[1])
      );
      
      for (let i = 1; i < numbers.length; i++) {
        if (numbers[i] !== numbers[i-1] + 1) {
          issues.push({
            title: "Numbered list sequence error",
            description: "Numbered list has non-consecutive numbers",
            text: `${numbers[i-1]} followed by ${numbers[i]}`,
            severity: "Minor",
            category: "lists",
            hasFix: true,
            fixAction: "fixListNumbering",
            explanation: "Number lists consecutively: 1, 2, 3..."
          });
          break;
        }
      }
    }
    
    // Check in-sentence series (serial comma)
    const seriesPattern = /\b\w+,\s+\w+(?:,\s+\w+)*,?\s+and\s+\w+/g;
    const seriesMatches = text.match(seriesPattern) || [];
    
    seriesMatches.forEach(series => {
      const items = series.split(/,|\s+and\s+/).map(s => s.trim());
      if (items.length >= 3) {
        // Check for Oxford/serial comma
        if (!series.includes(', and')) {
          issues.push({
            title: "Missing serial comma",
            description: "APA requires serial comma before 'and' in lists",
            text: series,
            severity: "Minor",
            category: "lists",
            hasFix: true,
            fixAction: "addSerialComma",
            explanation: "Use: A, B, and C (not A, B and C)"
          });
        }
      }
    });
    
    // Check for complex series with semicolons
    const complexSeries = text.match(/[^.;]+;\s*[^.;]+;\s*and\s+[^.;]+/g) || [];
    complexSeries.forEach(series => {
      if (!series.includes('; and')) {
        issues.push({
          title: "Complex series punctuation",
          description: "Use semicolon before 'and' in complex series",
          text: series.substring(0, 50) + '...',
          severity: "Minor",
          category: "lists",
          hasFix: true,
          fixAction: "fixComplexSeries",
          explanation: "Complex items need: item A; item B; and item C"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate abbreviation management
   */
  validateAbbreviations(text) {
    const issues = [];
    const definedAbbreviations = new Set();
    const usedAbbreviations = new Map();

    // Find abbreviation definitions [ABBR] or (ABBR)
    const definitionPattern = /\b([A-Za-z][A-Za-z\s]+)\s*[\[(]([A-Z]{2,})\s*[\])]/g;
    const definitions = [...text.matchAll(definitionPattern)];

    definitions.forEach(match => {
      const fullTerm = match[1];
      const abbr = match[2];
      definedAbbreviations.add(abbr);
    });

    // Detect ALL CAPS headings first to exclude them from abbreviation detection
    const allCapsHeadingPattern = /\n\s*([A-Z][A-Z\s]{2,})\s*\n/g;
    const headings = new Set();
    let headingMatch;
    while ((headingMatch = allCapsHeadingPattern.exec(text)) !== null) {
      const heading = headingMatch[1].trim();
      // Only consider it a heading if it meets the criteria
      if (heading.length >= 3 && heading === heading.toUpperCase() &&
          !heading.includes('(') && !heading.includes(',') &&
          heading.split(' ').length <= 8 &&
          /^[A-Z\s]+$/.test(heading)) {
        // Extract individual words from heading
        heading.split(/\s+/).forEach(word => {
          if (word.length >= 2) {
            headings.add(word);
          }
        });
      }
    }

    // Find used abbreviations (2+ capital letters)
    const abbrPattern = /\b([A-Z]{2,})\b/g;
    const abbreviations = [...text.matchAll(abbrPattern)];

    abbreviations.forEach(match => {
      const abbr = match[1];
      const position = match.index;

      // Skip common ones that don't need definition
      const skipList = ['USA', 'UK', 'US', 'AM', 'PM', 'BC', 'AD', 'DC', 'ID', 'OK', 'TV'];
      if (skipList.includes(abbr)) return;

      // Skip if it's part of an ALL CAPS heading
      if (headings.has(abbr)) return;

      if (!usedAbbreviations.has(abbr)) {
        usedAbbreviations.set(abbr, []);
      }
      usedAbbreviations.get(abbr).push(position);
    });
    
    // Check for undefined abbreviations
    usedAbbreviations.forEach((positions, abbr) => {
      if (!definedAbbreviations.has(abbr) && positions.length > 1) {
        const firstPosition = positions[0];
        const context = text.substring(Math.max(0, firstPosition - 20), firstPosition + abbr.length + 20);
        
        issues.push({
          title: "Undefined abbreviation",
          description: `Abbreviation "${abbr}" used without definition`,
          text: context,
          severity: "Minor",
          category: "abbreviations",
          hasFix: false,
          explanation: "Define abbreviation on first use: American Psychological Association (APA)"
        });
      }
    });
    
    // Check Latin abbreviations usage
    Object.entries(this.commonAbbreviations).forEach(([abbr, meaning]) => {
      const pattern = new RegExp(`\\b${abbr.replace('.', '\\.')}`, 'g');
      const matches = text.match(pattern) || [];
      
      matches.forEach(match => {
        const position = text.indexOf(match);
        const context = text.substring(Math.max(0, position - 30), position + match.length + 30);
        
        // Check if in parentheses (required for e.g., i.e., etc.)
        const inParentheses = context.includes(`(${match}`) || 
                             context.includes(`(${meaning}`) ||
                             context.match(/\([^)]*$/);
        
        if (!inParentheses && ['e.g.', 'i.e.', 'etc.', 'cf.'].includes(abbr)) {
          issues.push({
            title: "Latin abbreviation outside parentheses",
            description: `"${abbr}" should only be used in parentheses`,
            text: context,
            severity: "Minor",
            category: "abbreviations",
            hasFix: true,
            fixAction: "replaceLatinAbbr",
            fixValue: { original: abbr, replacement: meaning },
            explanation: `In text use "${meaning}", in parentheses use "${abbr}"`
          });
        }
      })
    });
    
    // Check plural abbreviations
    const pluralAbbrPattern = /\b([A-Z]{2,})'s\b/g;
    const pluralAbbrs = text.match(pluralAbbrPattern) || [];
    
    pluralAbbrs.forEach(plural => {
      // Check if it has apostrophe (it shouldn't for plurals)
      if (plural.includes("'")) {
        issues.push({
          title: "Incorrect plural abbreviation",
          description: "Plural abbreviations don't use apostrophes",
          text: plural,
          severity: "Minor",
          category: "abbreviations",
          hasFix: true,
          fixAction: "fixPluralAbbr",
          explanation: "Use 'URLs' not 'URL's' for plurals"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate appendix and supplemental materials
   */
  validateAppendixAndSupplements(text, structure) {
    const issues = [];
    
    // Check for appendix references
    const appendixPattern = /\bAppendix\s+([A-Z])\b/g;
    const appendixRefs = [...text.matchAll(appendixPattern)];
    const referencedAppendices = new Set();
    const actualAppendices = new Set();
    
    appendixRefs.forEach(match => {
      const letter = match[1];
      const position = match.index;
      const context = text.substring(Math.max(0, position - 50), position + 100);
      
      // Check if this is the appendix itself or a reference to it
      if (context.match(/^Appendix\s+[A-Z]\s*\n/)) {
        actualAppendices.add(letter);
      } else {
        referencedAppendices.add(letter);
      }
    });
    
    // Check for missing appendices
    referencedAppendices.forEach(letter => {
      if (!actualAppendices.has(letter)) {
        issues.push({
          title: "Referenced appendix not found",
          description: `Appendix ${letter} is referenced but not included`,
          text: `Appendix ${letter}`,
          severity: "Major",
          category: "appendix",
          hasFix: false,
          explanation: "All referenced appendices must be included in the document"
        });
      }
    });
    
    // Check appendix order
    const appendixLetters = Array.from(actualAppendices).sort();
    for (let i = 0; i < appendixLetters.length; i++) {
      const expected = String.fromCharCode(65 + i); // A, B, C...
      if (appendixLetters[i] !== expected) {
        issues.push({
          title: "Appendix labeling sequence error",
          description: `Appendix ${appendixLetters[i]} out of sequence`,
          text: `Expected Appendix ${expected}`,
          severity: "Minor",
          category: "appendix",
          hasFix: false,
          explanation: "Label appendices consecutively: Appendix A, Appendix B, etc."
        });
        break;
      }
    }
    
    // Check for appendix titles
    actualAppendices.forEach(letter => {
      const titlePattern = new RegExp(`Appendix\\s+${letter}\\s*\\n\\s*([A-Z][^\\n]+)`, 'g');
      const titleMatch = text.match(titlePattern);
      
      if (!titleMatch) {
        issues.push({
          title: "Appendix missing title",
          description: `Appendix ${letter} should have a descriptive title`,
          text: `Appendix ${letter}`,
          severity: "Minor",
          category: "appendix",
          hasFix: false,
          explanation: "Each appendix needs a title: 'Appendix A: Survey Questions'"
        });
      }
    });
    
    // Check for callouts to appendices
    actualAppendices.forEach(letter => {
      const calloutPattern = new RegExp(`(?:see|See|shown in|presented in)\\s+Appendix\\s+${letter}`, 'g');
      const hasCallout = calloutPattern.test(text);
      
      if (!hasCallout) {
        // Check if appendix is mentioned at all before it appears
        const appendixPosition = text.indexOf(`Appendix ${letter}\n`);
        const mentionPattern = new RegExp(`Appendix\\s+${letter}`, 'g');
        const mentions = [...text.matchAll(mentionPattern)];
        
        const hasEarlierMention = mentions.some(m => m.index < appendixPosition);
        
        if (!hasEarlierMention) {
          issues.push({
            title: "Appendix not referenced in text",
            description: `Appendix ${letter} should be mentioned in the main text`,
            text: `Appendix ${letter}`,
            severity: "Minor",
            category: "appendix",
            hasFix: false,
            explanation: "Refer to each appendix in the main text before it appears"
          });
        }
      }
    });
    
    // Check for supplemental materials notation
    if (text.includes('supplemental material') || text.includes('supplementary material')) {
      const suppPattern = /supplementa[lr]y?\s+materials?\s+(?:is|are)?\s*available/gi;
      const suppMatches = text.match(suppPattern) || [];
      
      if (suppMatches.length > 0 && !text.includes('osf.io') && !text.includes('doi.org')) {
        issues.push({
          title: "Supplemental materials location not specified",
          description: "Specify where supplemental materials can be accessed",
          text: suppMatches[0],
          severity: "Minor",
          category: "appendix",
          hasFix: false,
          explanation: "Include repository URL or DOI for supplemental materials"
        });
      }
    }
    
    return issues;
  }

  /**
   * Additional title and heading validations
   */
  validateTitleAndHeadings(text) {
    const issues = [];
    
    // Check title length (≤12 words recommended)
    const lines = text.split('\n').filter(l => l.trim());
    if (lines.length > 0) {
      const potentialTitle = lines[0];
      const wordCount = potentialTitle.split(/\s+/).filter(w => w.length > 0).length;
      
      if (wordCount > 12 && wordCount < 30) {
        issues.push({
          title: "Title length",
          description: `Title has ${wordCount} words (recommended ≤12)`,
          text: potentialTitle.substring(0, 50) + '...',
          severity: "Minor",
          category: "headings",
          hasFix: false,
          explanation: "APA recommends concise titles of 12 words or fewer"
        });
      }
    }
    
    // Check for colon usage in titles
    const titleWithColon = lines[0]?.includes(':');
    if (titleWithColon) {
      const parts = lines[0].split(':');
      if (parts.length === 2 && parts[1].trim()[0] !== parts[1].trim()[0].toUpperCase()) {
        issues.push({
          title: "Subtitle capitalization",
          description: "Subtitle after colon should start with capital letter",
          text: lines[0].substring(0, 50),
          severity: "Minor",
          category: "headings",
          hasFix: true,
          fixAction: "capitalizeSubtitle",
          explanation: "Capitalize first word after colon in titles"
        });
      }
    }
    
    // Check heading length
    const headingPattern = /^(#{1,5}|[A-Z][^.!?]{5,50}$)/gm;
    const headings = text.match(headingPattern) || [];
    
    headings.forEach(heading => {
      const wordCount = heading.split(/\s+/).filter(w => w.length > 0).length;
      if (wordCount > 10) {
        issues.push({
          title: "Long heading",
          description: "Heading may be too long for clarity",
          text: heading.substring(0, 50),
          severity: "Minor",
          category: "headings",
          hasFix: false,
          explanation: "Keep headings concise and descriptive"
        });
      }
    });

    // NEW: Validate APA 7th Edition Level 5 heading format
    issues.push(...this.validateLevel5Headings(text));

    return issues;
  }

  /**
   * NEW: Validate APA 7th Edition Level 5 heading format
   */
  validateLevel5Headings(text) {
    const issues = [];

    // Level 5 headings should be: Indented, Bold, Italic, Title Case, Ending with a Period.
    // They appear as part of the paragraph.

    // Pattern to detect potential level 5 headings
    // Look for bold/italic text at paragraph start that ends with a period
    const level5Pattern = /^[ \t]*([A-Z][^.]{10,50})\.\s+[A-Z]/gm;
    const potentialLevel5s = [...text.matchAll(level5Pattern)];

    potentialLevel5s.forEach(match => {
      const headingText = match[1];
      const fullMatch = match[0];

      // Check if it follows title case
      const words = headingText.split(/\s+/);
      const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if',
                         'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];

      let titleCaseErrors = 0;
      words.forEach((word, index) => {
        const isFirstOrLast = index === 0 || index === words.length - 1;
        const isSmallWord = smallWords.includes(word.toLowerCase());

        if (isFirstOrLast && word[0] !== word[0].toUpperCase()) {
          titleCaseErrors++;
        } else if (!isFirstOrLast && !isSmallWord && word[0] !== word[0].toUpperCase()) {
          titleCaseErrors++;
        } else if (!isFirstOrLast && isSmallWord && word[0] === word[0].toUpperCase()) {
          titleCaseErrors++;
        }
      });

      if (titleCaseErrors > 0) {
        issues.push({
          title: "Potential Level 5 heading case error",
          description: "Level 5 headings should use title case",
          text: headingText,
          severity: "Minor",
          category: "headings",
          hasFix: true,
          fixAction: "fixLevel5HeadingCase",
          explanation: "Level 5 headings: Indented, Bold, Italic, Title Case, Ending with Period. Text continues on same line."
        });
      }

      // Check if indented (should start with spaces/tab)
      if (!match[0].match(/^[ \t]/)) {
        issues.push({
          title: "Level 5 heading not indented",
          description: "Level 5 headings should be indented",
          text: headingText,
          severity: "Minor",
          category: "headings",
          hasFix: true,
          fixAction: "indentLevel5Heading",
          explanation: "Level 5 headings must be indented (0.5 inch) like paragraph indent"
        });
      }
    });

    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\enhancedApaAnalyzer.js
// src/utils/enhancedApaAnalyzer.js - Enhanced with reference and table/figure validation
'use client';

// Import specialized validators
import { ReferenceValidator } from './referenceValidator';
import { TableFigureValidator } from './tableFigureValidator';
import { HeaderFooterValidator } from './headerFooterValidator';
import { AdvancedCitationValidator } from './advancedCitationValidator';
import { QuotationValidator } from './quotationValidator';
import { StatisticalValidator } from './statisticalValidator';
import { BiasFreeLanguageValidator } from './biasFreeLanguageValidator';
import { ComprehensiveValidator } from './comprehensiveValidator';
import { AdditionalAPARules } from './additionalApaRules';

// Enhanced APA 7th Edition Analyzer that works with rich document formatting data
export class EnhancedAPAAnalyzer {
  constructor(validators = {}) {
    this.apaStandards = {
      font: {
        family: 'times new roman',
        size: 12 // points
      },
      spacing: {
        line: 2.0, // double spacing
        paragraphAfter: 0, // no extra space after paragraphs
        paragraphBefore: 0
      },
      margins: {
        top: 1.0, // inches
        bottom: 1.0,
        left: 1.0,
        right: 1.0
      },
      indentation: {
        firstLine: 0.5 // inches
      }
    };

    // Initialize specialized validators with dependency injection
    // Allow injection of custom validators for testing and modularity
    this.referenceValidator = validators.referenceValidator || new ReferenceValidator();
    this.tableFigureValidator = validators.tableFigureValidator || new TableFigureValidator();
    this.headerFooterValidator = validators.headerFooterValidator || new HeaderFooterValidator();
    this.advancedCitationValidator = validators.advancedCitationValidator || new AdvancedCitationValidator();
    this.quotationValidator = validators.quotationValidator || new QuotationValidator();
    this.statisticalValidator = validators.statisticalValidator || new StatisticalValidator();
    this.biasFreeLanguageValidator = validators.biasFreeLanguageValidator || new BiasFreeLanguageValidator();
    this.comprehensiveValidator = validators.comprehensiveValidator || new ComprehensiveValidator();
  }

  /**
   * Factory method to create analyzer with default validators
   * Useful for production use while maintaining testability
   */
  static createDefault() {
    return new EnhancedAPAAnalyzer();
  }

  /**
   * Factory method to create analyzer with custom validators
   * Useful for testing and modularity
   */
  static createWithValidators(validators) {
    return new EnhancedAPAAnalyzer(validators);
  }

  /**
   * Main analysis function - works with rich document data from server
   */
  analyzeDocument(documentData) {
    const issues = [];

    // Comprehensive input validation
    if (!documentData) {
      console.error('❌ analyzeDocument called with null/undefined documentData');
      issues.push({
        id: 'invalid-document-data',
        title: 'Invalid document data',
        description: 'Document analysis failed due to missing document data',
        severity: 'Critical',
        category: 'document',
        hasFix: false,
        explanation: 'The document could not be analyzed because no document data was provided.'
      });
      return issues;
    }

    // Safely extract data with defaults and type checking
    const {
      text = '',
      html = '',
      formatting = null,
      structure = null
    } = documentData;

    // Validate required fields
    if (!text && !html) {
      console.error('❌ Document has no text or HTML content');
      issues.push({
        id: 'no-content',
        title: 'Empty document',
        description: 'Document contains no readable text content',
        severity: 'Critical',
        category: 'document',
        hasFix: false,
        explanation: 'The document appears to be empty or could not be processed properly.'
      });
      return issues;
    }

    // Validate text content
    if (typeof text !== 'string') {
      console.warn('⚠️ Document text is not a string, converting...');
      text = String(text || '');
    }

    // Validate HTML content
    if (typeof html !== 'string') {
      console.warn('⚠️ Document HTML is not a string, converting...');
      html = String(html || '');
    }

    if (process.env.NODE_ENV === 'development') {
      console.log(`📊 Analyzing document: ${text.length} chars text, ${html.length} chars HTML, formatting: ${!!formatting}, structure: ${!!structure}`);
    }

    try {
      // 1. Analyze formatting with precise data (if available)
      if (formatting && typeof formatting === 'object') {
        issues.push(...this.analyzeFormatting(formatting));
      } else {
        console.warn('⚠️ No valid formatting data available - using basic analysis');
        issues.push(...this.analyzeBasicFormatting(html));
      }
    } catch (error) {
      console.error('❌ Error in formatting analysis:', error);
      issues.push(this.createErrorIssue('formatting-analysis-error', 'Formatting analysis failed', error.message));
    }

    try {
      // 2. Analyze document structure
      if (structure && typeof structure === 'object' && text) {
        issues.push(...this.analyzeStructure(structure, text));
      } else if (text) {
        console.warn('⚠️ No valid structure data available - using text-based analysis');
        issues.push(...this.analyzeBasicStructure(text));
      }
    } catch (error) {
      console.error('❌ Error in structure analysis:', error);
      issues.push(this.createErrorIssue('structure-analysis-error', 'Structure analysis failed', error.message));
    }

    try {
      // 3. Analyze citations - use basic analysis for better results
      if (text) {
        console.log('📚 Using basic citation analysis for better coverage...');
        issues.push(...this.analyzeBasicCitations(text));
      }
    } catch (error) {
      console.error('❌ Error in citation analysis:', error);
      issues.push(this.createErrorIssue('citation-analysis-error', 'Citation analysis failed', error.message));
    }

    try {
      // 4. Analyze references with enhanced validation including deep formatting
      if (text) {
        // Safely extract italicized text
        const italicizedText = (structure && Array.isArray(structure.italicizedText)) ? structure.italicizedText : [];
        const referenceIssues = this.referenceValidator.validateReferences(text, structure, italicizedText);
        issues.push(...(Array.isArray(referenceIssues) ? referenceIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in reference validation:', error);
      issues.push(this.createErrorIssue('reference-validation-error', 'Reference validation failed', error.message));
    }

    try {
      // 5. Analyze tables and figures including border validation
      if (text) {
        // Enhanced validation with table border information from XML
        const tableFigureIssues = this.tableFigureValidator.validateTablesAndFigures(text, structure, formatting);
        issues.push(...(Array.isArray(tableFigureIssues) ? tableFigureIssues : []));

        // Add table border validation if XML data is available
        if (structure && Array.isArray(structure.tables)) {
          const borderIssues = this.validateTableBorders(structure.tables);
          issues.push(...(Array.isArray(borderIssues) ? borderIssues : []));
        }
      }
    } catch (error) {
      console.error('❌ Error in table/figure validation:', error);
      issues.push(this.createErrorIssue('table-figure-error', 'Table/figure validation failed', error.message));
    }

    try {
      // 6. Analyze headers, footers, running heads, and page numbers
      if (text && structure && typeof structure === 'object') {
        const headerFooterIssues = this.headerFooterValidator.validateHeadersFooters(text, structure);
        issues.push(...(Array.isArray(headerFooterIssues) ? headerFooterIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in header/footer validation:', error);
      issues.push(this.createErrorIssue('header-footer-error', 'Header/footer validation failed', error.message));
    }

    try {
      // 7. Advanced citation validation
      if (text) {
        const advancedCitationIssues = this.advancedCitationValidator.validateAdvancedCitations(text, structure);
        issues.push(...(Array.isArray(advancedCitationIssues) ? advancedCitationIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in advanced citation validation:', error);
      issues.push(this.createErrorIssue('advanced-citation-error', 'Advanced citation validation failed', error.message));
    }

    try {
      // 8. Quotation handling validation
      if (text) {
        const quotationIssues = this.quotationValidator.validateQuotations(text, structure);
        issues.push(...(Array.isArray(quotationIssues) ? quotationIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in quotation validation:', error);
      issues.push(this.createErrorIssue('quotation-error', 'Quotation validation failed', error.message));
    }

    try {
      // 9. Statistical and numerical formatting
      if (text) {
        const statisticalIssues = this.statisticalValidator.validateStatistical(text, structure);
        issues.push(...(Array.isArray(statisticalIssues) ? statisticalIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in statistical validation:', error);
      issues.push(this.createErrorIssue('statistical-error', 'Statistical validation failed', error.message));
    }

    try {
      // 10. Bias-free language detection
      if (text) {
        const biasFreeIssues = this.biasFreeLanguageValidator.validateBiasFreeLanguage(text, structure);
        issues.push(...(Array.isArray(biasFreeIssues) ? biasFreeIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in bias-free language validation:', error);
      issues.push(this.createErrorIssue('bias-free-error', 'Bias-free language validation failed', error.message));
    }

    try {
      // 11. Lists, abbreviations, and appendices
      if (text) {
        const listIssues = this.comprehensiveValidator.validateListsAndSeriation(text);
        issues.push(...(Array.isArray(listIssues) ? listIssues : []));

        const abbrIssues = this.comprehensiveValidator.validateAbbreviations(text);
        issues.push(...(Array.isArray(abbrIssues) ? abbrIssues : []));

        const appendixIssues = this.comprehensiveValidator.validateAppendixAndSupplements(text, structure);
        issues.push(...(Array.isArray(appendixIssues) ? appendixIssues : []));

        const titleIssues = this.comprehensiveValidator.validateTitleAndHeadings(text);
        issues.push(...(Array.isArray(titleIssues) ? titleIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in comprehensive validation:', error);
      issues.push(this.createErrorIssue('comprehensive-error', 'Comprehensive validation failed', error.message));
    }

    try {
      // 12. Additional APA rules (footnotes, equations, legal, social media, etc.)
      if (text) {
        const additionalRulesValidator = new AdditionalAPARules();
        const additionalIssues = additionalRulesValidator.validateAdditionalRules(text, structure);
        issues.push(...(Array.isArray(additionalIssues) ? additionalIssues : []));
      }
    } catch (error) {
      console.error('❌ Error in additional rules validation:', error);
      issues.push(this.createErrorIssue('additional-rules-error', 'Additional rules validation failed', error.message));
    }
    
    // 13. Analyze content compliance (original basic content check)
    if (text) {
      issues.push(...this.analyzeContent(text));
    }
    
    
    if (process.env.NODE_ENV === 'development') {
      console.log(`✅ Analysis complete: ${issues.length} issues found`);
    }
    return this.prioritizeAndDeduplicateIssues(issues);
  }

  /**
   * Create a standardized error issue for analysis failures
   */
  createErrorIssue(id, title, errorMessage) {
    return {
      id: id,
      title: title,
      description: `Analysis failed: ${errorMessage}`,
      severity: 'Major',
      category: 'system',
      hasFix: false,
      explanation: 'An error occurred during document analysis. The validator may have encountered invalid data or a processing error.',
      error: errorMessage
    };
  }

  /**
   * Analyze formatting with precise measurements - FIXED with safe property access
   */
  analyzeFormatting(formatting) {
    const issues = [];
    
    
    // Safely access formatting properties
    const documentFormatting = formatting?.document || {};
    const font = documentFormatting.font || {};
    const spacing = documentFormatting.spacing || {};
    const margins = documentFormatting.margins || {};
    const indentation = documentFormatting.indentation || {};
    const paragraphs = formatting?.paragraphs || [];
    const compliance = formatting?.compliance || {};
    
    // Check font family - SAFE ACCESS
    if (font.family) {
      const fontFamily = font.family.toLowerCase();
      if (!fontFamily.includes('times new roman') && 
          !fontFamily.includes('times') && 
          !fontFamily.includes('liberation serif')) {
        // Find first paragraph with text to highlight
        const firstParagraphWithText = paragraphs.find(p => p.text && p.text.trim().length > 0);
        const paraIndex = firstParagraphWithText ? paragraphs.indexOf(firstParagraphWithText) : 0;
        issues.push({
          title: "Incorrect font family",
          description: `Document uses "${font.family}" instead of Times New Roman`,
          text: firstParagraphWithText ? firstParagraphWithText.text.substring(0, 50) : null,
          highlightText: firstParagraphWithText ? firstParagraphWithText.text.substring(0, 50) : null,
          severity: "Major",
          category: "formatting",
          location: { 
            type: "document", 
            section: "font", 
            paragraphIndex: paraIndex,
            charOffset: 0,
            length: firstParagraphWithText ? Math.min(50, firstParagraphWithText.text.length) : 50
          },
          hasFix: true,
          fixAction: "fixFont",
          explanation: "APA 7th edition requires Times New Roman 12pt font throughout the document."
        });
      }
    } else if (compliance.font && !compliance.font.family) {
      issues.push({
        title: "Font family not specified or non-compliant",
        description: "Document should use Times New Roman font",
        severity: "Major",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    // Check font size with tolerance - SAFE ACCESS
    if (font.size && Math.abs(font.size - 12) > 0.5) {
      // Find first paragraph with text to highlight
      const firstParagraphWithText = paragraphs.find(p => p.text && p.text.trim().length > 0);
      const paraIndex = firstParagraphWithText ? paragraphs.indexOf(firstParagraphWithText) : 0;
      issues.push({
        title: "Incorrect font size",
        description: `Font size is ${font.size}pt instead of 12pt`,
        text: firstParagraphWithText ? firstParagraphWithText.text.substring(0, 50) : null,
        highlightText: firstParagraphWithText ? firstParagraphWithText.text.substring(0, 50) : null,
        severity: "Major",
        category: "formatting", 
        location: { 
          type: "document", 
          section: "font", 
          paragraphIndex: paraIndex,
          charOffset: 0,
          length: firstParagraphWithText ? Math.min(50, firstParagraphWithText.text.length) : 50
        },
        hasFix: true,
        fixAction: "fixFontSize",
        explanation: "APA 7th edition requires 12-point font size."
      });
    }
    
    // Check line spacing - SAFE ACCESS
    if (spacing.line && Math.abs(spacing.line - 2.0) > 0.1) {
      // Find first paragraph with text to highlight
      const firstParagraphWithText = paragraphs.find(p => p.text && p.text.trim().length > 0);
      const paraIndex = firstParagraphWithText ? paragraphs.indexOf(firstParagraphWithText) : 0;
      issues.push({
        title: "Incorrect line spacing",
        description: `Line spacing is ${spacing.line} instead of double (2.0)`,
        text: firstParagraphWithText ? firstParagraphWithText.text.substring(0, 50) : null,
        highlightText: firstParagraphWithText ? firstParagraphWithText.text.substring(0, 50) : null,
        severity: "Major",
        category: "formatting", 
        location: { 
          type: "document", 
          section: "spacing", 
          paragraphIndex: paraIndex,
          charOffset: 0,
          length: firstParagraphWithText ? Math.min(50, firstParagraphWithText.text.length) : 50
        },
        hasFix: true,
        fixAction: "fixLineSpacing",
        explanation: "APA 7th edition requires double spacing (2.0) throughout the document."
      });
    }
    
    // Check margins with tolerance - SAFE ACCESS
    const marginIssues = [];
    Object.entries(this.apaStandards.margins).forEach(([side, required]) => {
      const actual = margins[side];
      if (actual !== null && actual !== undefined && Math.abs(actual - required) > 0.1) {
        marginIssues.push(`${side}: ${actual}" (should be ${required}")`);
      }
    });
    
    if (marginIssues.length > 0) {
      issues.push({
        title: "Incorrect margins",
        description: `Margins are not 1 inch: ${marginIssues.join(', ')}`,
        text: marginIssues.join(', '),
        severity: "Major",
        category: "formatting",
        location: { type: "document", section: "margins" },
        hasFix: true,
        fixAction: "fixMargins",
        explanation: "APA 7th edition requires 1-inch margins on all sides."
      });
    }
    
    // Check paragraph indentation - SAFE ACCESS
    if (paragraphs.length > 0) {
      const bodyParagraphs = paragraphs.filter(p => 
        p && p.indentation && (p.indentation.firstLine !== null || p.indentation.left !== null)
      );
      
      const incorrectIndentation = bodyParagraphs.filter(p => {
        const firstLine = (p.indentation && p.indentation.firstLine) || 0;
        return Math.abs(firstLine - 0.5) > 0.05; // 5% tolerance
      });
      
      if (bodyParagraphs.length > 0 && incorrectIndentation.length > 0) {
        issues.push({
          title: "Incorrect paragraph indentation",
          description: `${incorrectIndentation.length} of ${bodyParagraphs.length} paragraphs have incorrect first-line indentation`,
          text: `Expected: 0.5", Found: varies`,
          severity: "Minor",
          category: "formatting",
          location: { 
            type: "paragraph", 
            indices: incorrectIndentation.map(p => p.index).slice(0, 5) 
          },
          hasFix: true,
          fixAction: "fixIndentation",
          explanation: "APA 7th edition requires 0.5-inch first-line indentation for all paragraphs."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback formatting analysis for when rich data isn't available
   */
  analyzeBasicFormatting(html) {
    const issues = [];
    
    
    if (!html) return issues;
    
    // Check font family
    const fontCheck = html.match(/font-family:\s*['"]([^'"]+)['"]/i);
    if (fontCheck && !fontCheck[1].toLowerCase().includes('times new roman')) {
      issues.push({
        title: "Incorrect font detected",
        description: `Document appears to use "${fontCheck[1]}" instead of Times New Roman`,
        text: `Font: ${fontCheck[1]}`,
        severity: "Minor",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze document structure with heading hierarchy
   */
  analyzeStructure(structure, text) {
    const issues = [];
    
    
    if (!structure || !text) return issues;
    
    const headings = structure.headings || [];
    const sections = structure.sections || [];
    const citations = structure.citations || [];
    
    // 1. Check for required sections
    const hasAbstract = sections.some(s => s.type === 'abstract') || text.toLowerCase().includes('abstract');
    const hasReferences = sections.some(s => s.type === 'references') || text.toLowerCase().includes('references');
    const wordCount = text.split(/\s+/).length;
    
    if (wordCount > 1000 && !hasAbstract) {
      issues.push({
        title: "Missing abstract",
        description: "Long papers typically require an abstract",
        severity: "Major",
        category: "structure",
        hasFix: true,
        fixAction: "addAbstract",
        explanation: "Papers longer than 1000 words typically require an abstract (150-250 words) summarizing the main points."
      });
    }
    
    if (!hasReferences && citations.length > 0) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    // 2. Check heading hierarchy
    if (headings.length > 1) {
      for (let i = 1; i < headings.length; i++) {
        const current = headings[i];
        const previous = headings[i - 1];
        
        if (current.level > previous.level + 1) {
          issues.push({
            title: "Improper heading hierarchy",
            description: `Heading level ${current.level} follows level ${previous.level}`,
            text: `"${current.text}" (Level ${current.level}) after "${previous.text}" (Level ${previous.level})`,
            severity: "Major",
            category: "structure",
            location: { 
              type: "heading", 
              paragraphIndex: current.paragraphIndex 
            },
            hasFix: true,
            fixAction: "fixHeadingLevel",
            explanation: "Headings must follow sequential order: Level 1, then Level 2, then Level 3, etc. Don't skip levels."
          });
        }
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback structure analysis
   */
  analyzeBasicStructure(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,\s*\d{4}\)/.test(text);
    
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze citations with extracted citation data
   */
  analyzeCitations(text, extractedCitations) {
    const issues = [];
    
    
    // Use extracted citations for more accurate analysis
    const citations = extractedCitations || [];
    
    citations.forEach((citation, index) => {
      // Check author-year format - SAFE ACCESS
      if (!citation.year || !citation.author) {
        issues.push({
          title: "Incomplete citation",
          description: "Citation missing author or year",
          text: citation.text || 'Unknown citation',
          severity: "Major",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: false,
          explanation: "All in-text citations must include author surname(s) and publication year."
        });
        return;
      }
      
      // Check for proper punctuation
      if (citation.text && !citation.text.includes(`, ${citation.year}`)) {
        issues.push({
          title: "Missing comma in citation",
          description: "Citation missing comma between author and year",
          text: citation.text,
          severity: "Minor",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: true,
          fixAction: "addCitationComma",
          fixValue: {
            original: citation.text,
            replacement: citation.text.replace(/\(([^)]+)\s+(\d{4})\)/, '($1, $2)')
          },
          explanation: "In-text citations require a comma between the author name and year: (Smith, 2023)."
        });
      }
    });
    
    return issues;
  }
  
  /**
   * Fallback citation analysis with position tracking
   */
  analyzeBasicCitations(text) {
    const issues = [];
    
    if (!text) return issues;
    
    // Split text into paragraphs to track positions
    const paragraphs = text.split('\n');
    let globalOffset = 0;
    
    paragraphs.forEach((paragraphText, paragraphIndex) => {
      // Enhanced citation patterns to catch all APA violations
      
      // 1. Check for citations missing commas (Author YEAR) format - but exclude et al. cases
      const missingCommaPattern = /\(([A-Za-z][A-Za-z\s&.]+(?<!et\s+al))\s+(\d{4})\)/g;
      let missingCommaMatch;
      while ((missingCommaMatch = missingCommaPattern.exec(paragraphText)) !== null) {
        const fullCitation = missingCommaMatch[0];
        const authorPart = missingCommaMatch[1];
        
        // Skip if this contains et al. - handle separately
        if (authorPart.includes('et al')) continue;
        
        issues.push({
          title: "Missing comma in citation",
          description: "Citations must have a comma between author and year",
          text: fullCitation,
          highlightText: fullCitation,
          severity: "Minor", 
          category: "citations",
          location: {
            paragraphIndex: paragraphIndex,
            charOffset: missingCommaMatch.index,
            length: fullCitation.length,
            type: 'text'
          },
          hasFix: true,
          fixAction: "addCitationComma",
          fixValue: {
            original: fullCitation,
            replacement: fullCitation.replace(/\(([^)]+)\s+(\d{4})\)/, '($1, $2)')
          },
          explanation: "APA format requires a comma between author name(s) and year: (Author, YEAR)."
        });
      }
    
      // 2. Standard citation pattern with comma (Author, YEAR)
      const citationPattern = /\(([^)]+),\s*(\d{4})[^)]*\)/g;
      let match;
      
      while ((match = citationPattern.exec(paragraphText)) !== null) {
        const fullCitation = match[0];
        const authorPart = match[1];
        
        // Check for incorrect ampersand usage
        if (authorPart.includes(' and ') && fullCitation.includes('(')) {
          issues.push({
            title: "Incorrect connector in parenthetical citation",
            description: "Use '&' instead of 'and' in parenthetical citations",
            text: fullCitation,
            highlightText: fullCitation,
            severity: "Minor",
            category: "citations",
            location: {
              paragraphIndex: paragraphIndex,
              charOffset: match.index,
              length: fullCitation.length,
              type: 'text'
            },
            hasFix: true,
            fixAction: "fixParentheticalConnector",
            fixValue: {
              original: fullCitation,
              replacement: fullCitation.replace(' and ', ' & ')
            },
            explanation: "In parenthetical citations, use & to connect author names."
          });
        }
        
        // Check for incorrect et al. formatting - APA 7th edition does NOT use comma before et al.
        if (authorPart.includes(', et al.')) {
          issues.push({
            title: "Incorrect comma before et al.",
            description: "APA 7th edition does not use comma before 'et al.' in citations",
            text: fullCitation,
            highlightText: fullCitation,
            severity: "Minor",
            category: "citations",
            location: {
              paragraphIndex: paragraphIndex,
              charOffset: match.index,
              length: fullCitation.length,
              type: 'text'
            },
            hasFix: true,
            fixAction: "fixEtAlFormatting",
            fixValue: {
              original: fullCitation,
              replacement: fullCitation.replace(', et al.', ' et al.')
            },
            explanation: "APA 7th edition format: (Smith et al., 2021), not (Smith, et al., 2021)."
          });
        }
      }
      
      globalOffset += paragraphText.length + 1; // +1 for newline
    });
    
    
    // 3. Analyze References section for consistency issues
    // NOTE: Reference connector validation ("and" vs "&") is handled by referenceValidator.js
    // which provides more accurate paragraph indexing for fixes
    const referencesSection = text.match(/REFERENCES([\s\S]*?)(?=\n\n[A-Z]|$)/i);
    if (referencesSection) {
      const referencesText = referencesSection[1];
      
      // Check for missing DOI/URL when available
      const lines = referencesText.split('\n').filter(line => line.trim().length > 0);
      lines.forEach((line, index) => {
        if (line.match(/^\s*[A-Z]/)) { // Reference entry line
          if (!line.includes('doi:') && !line.includes('http') && !line.includes('Retrieved from')) {
            if (line.toLowerCase().includes('journal') || line.toLowerCase().includes('article')) {
              issues.push({
                title: "Missing DOI or URL",
                description: "Journal articles should include DOI or URL when available",
                text: line.substring(0, 100) + '...',
                severity: "Minor",
                category: "references",
                hasFix: false,
                explanation: "Include DOI (preferred) or URL for journal articles and online sources when available."
              });
            }
          }
        }
      });
    }
    
    // 4. Check for title page issues
    const titlePageIssues = this.analyzeTitlePage(text);
    issues.push(...titlePageIssues);
    
    // 5. Check for spacing issues around citations
    const spacingIssuePattern = /[^\s]\(([^)]+,\s*\d{4})\)|(\([^)]+,\s*\d{4}\))[^\s.,;]/g;
    let spacingMatch;
    while ((spacingMatch = spacingIssuePattern.exec(text)) !== null) {
      issues.push({
        title: "Citation spacing error",
        description: "Citations need proper spacing before and after",
        text: spacingMatch[0],
        highlightText: spacingMatch[0],
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "There should be a space before opening parenthesis and proper punctuation after citations."
      });
    }
    
    // 6. Check for URLs in text that should be properly formatted
    const urlInTextPattern = /https?:\/\/[^\s)]+/g;
    let urlMatch;
    while ((urlMatch = urlInTextPattern.exec(text)) !== null) {
      if (!text.includes('Retrieved from') || !text.includes('doi:')) {
        issues.push({
          title: "URL formatting in text",
          description: "URLs should be properly formatted in references, not embedded in text",
          text: urlMatch[0],
          highlightText: urlMatch[0],
          severity: "Minor",
          category: "formatting",
          hasFix: false,
          explanation: "URLs should appear in the reference list, not embedded in the main text."
        });
      }
    }
    
    // 7. Check for ALL CAPS headings (more precise detection)
    const allCapsHeadingPattern = /\n\s*([A-Z][A-Z\s]{2,})\s*\n/g;
    let titleMatch;
    while ((titleMatch = allCapsHeadingPattern.exec(text)) !== null) {
      const heading = titleMatch[1].trim();
      // Only flag if it's truly ALL CAPS and looks like a heading
      // Changed from > 8 to >= 3 to catch shorter headings like "ABSTRACT" (8 chars)
      if (heading.length >= 3 && heading === heading.toUpperCase() &&
          !heading.includes('(') && !heading.includes(',') &&
          heading.split(' ').length <= 8 &&
          /^[A-Z\s]+$/.test(heading)) {
        // Convert to Title Case (capitalize first letter of each word)
        const titleCase = heading
          .toLowerCase()
          .split(' ')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');

        issues.push({
          title: "ALL CAPS heading detected",
          description: "Headings should use title case or sentence case, not ALL CAPS",
          text: heading,
          highlightText: heading,
          severity: "Minor",
          category: "formatting",
          location: {
            paragraphIndex: paragraphIndex,
            charOffset: titleMatch.index,
            length: heading.length,
            type: 'text'
          },
          hasFix: true,
          fixAction: "fixAllCapsHeading",
          fixValue: {
            original: heading,
            replacement: titleCase
          },
          explanation: "APA 7th edition headings should use title case (Level 1-3) or sentence case (Level 4-5), not ALL CAPS."
        });
      }
    }
    
    // 8. Check for paragraph structure (multiple consecutive line breaks)
    const excessiveBreaksPattern = /\n\s*\n\s*\n\s*\n/g;
    if (excessiveBreaksPattern.test(text)) {
      issues.push({
        title: "Excessive line spacing",
        description: "Too many blank lines between paragraphs",
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "APA format uses double-spacing with no extra blank lines between paragraphs."
      });
    }
    
    
    // Check for direct quotes without page numbers
    const quotePattern = /[""][^""]{10,}[""]\s*(\([^)]+\))/g;
    let quoteMatch;
    while ((quoteMatch = quotePattern.exec(text)) !== null) {
      const citation = quoteMatch[1];
      if (!citation.match(/,\s*p\.?\s*\d+/)) {
        issues.push({
          title: "Direct quote missing page number",
          description: "Direct quotes require page numbers",
          text: quoteMatch[0],
          highlightText: quoteMatch[0],
          severity: "Major",
          category: "citations",
          hasFix: true,
          fixAction: "addPageNumber",
          fixValue: {
            original: citation,
            replacement: citation.replace(')', ', p. XX)')
          },
          explanation: "All direct quotations must include a page number to help readers locate the original text."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Analyze title page structure
   */
  analyzeTitlePage(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    const firstPage = text.substring(0, 1500); // First ~1500 chars for title page
    
    // Check for required elements in order
    const lines = firstPage.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    if (lines.length < 3) {
      issues.push({
        title: "Incomplete title page",
        description: "Title page appears to be missing required elements",
        severity: "Major",
        category: "structure",
        hasFix: false,
        explanation: "APA title page requires: paper title, author name(s), institutional affiliation, and author note."
      });
      return issues;
    }
    
    // Check if title is centered (simple heuristic - no excessive leading spaces)
    const possibleTitle = lines[0];
    if (possibleTitle.length > 5 && possibleTitle.startsWith('  ')) {
      // This might indicate improper formatting, but it's hard to detect without rich formatting
    }
    
    // Check for common title page issues
    const titlePageText = firstPage.toLowerCase();
    
    // Check for missing running head
    if (!titlePageText.includes('running head') && !titlePageText.includes('page')) {
      issues.push({
        title: "Missing running head",
        description: "Title page should include a running head (for professional papers)",
        severity: "Minor", 
        category: "structure",
        hasFix: false,
        explanation: "Professional papers require a running head on the title page and throughout the document."
      });
    }
    
    // Check for in-text citations on title page (but be more selective)
    const citationPattern = /\([A-Za-z]+,?\s+\d{4}\)/g;
    const citationsOnTitlePage = firstPage.match(citationPattern);
    if (citationsOnTitlePage && citationsOnTitlePage.length > 0) {
      // Only flag if it's clearly in the main title page content, not in author notes
      const titlePageWithoutAuthorNote = firstPage.split('Author Note')[0];
      if (citationPattern.test(titlePageWithoutAuthorNote)) {
        issues.push({
          title: "Citations on title page",
          description: "Title page should not contain in-text citations",
          severity: "Minor",
          category: "structure", 
          hasFix: false,
          explanation: "The title page should contain only title, author, affiliation information - no citations."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Validate table borders from XML data
   */
  validateTableBorders(tables) {
    const issues = [];
    
    tables.forEach((table, index) => {
      // Check for vertical lines (APA doesn't use them)
      if (table.hasVerticalLines) {
        issues.push({
          title: "Vertical lines in table",
          description: `Table ${index + 1} contains vertical lines which violate APA format`,
          text: `Table ${index + 1}`,
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "removeTableVerticalLines",
          explanation: "APA style tables should not use vertical lines. Use only horizontal lines for clarity."
        });
      }
      
      // Check for excessive borders
      if (table.hasFullBorders) {
        issues.push({
          title: "Excessive borders in table",
          description: `Table ${index + 1} has full borders instead of APA style minimal borders`,
          text: `Table ${index + 1}`,
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "fixTableBorders",
          explanation: "APA tables use minimal borders: horizontal lines at top, bottom, and below column headings only."
        });
      }
      
      // Check for proper APA table border style
      if (table.borderStyle) {
        const hasProperBorders = table.borderStyle.top && 
                                table.borderStyle.bottom && 
                                table.borderStyle.insideH && 
                                !table.borderStyle.left && 
                                !table.borderStyle.right && 
                                !table.borderStyle.insideV;
        
        if (!hasProperBorders && !table.hasFullBorders) {
          issues.push({
            title: "Incorrect table border style",
            description: `Table ${index + 1} doesn't follow APA border guidelines`,
            text: `Table ${index + 1}`,
            severity: "Minor",
            category: "tables",
            hasFix: true,
            fixAction: "fixTableBorderStyle",
            explanation: "APA tables should have horizontal lines at top, bottom, and after header row only."
          });
        }
      }
    });
    
    return issues;
  }

  /**
   * Legacy analyze references section - kept for backward compatibility
   * Now replaced by ReferenceValidator for comprehensive validation
   * @deprecated Use ReferenceValidator.validateReferences() instead
   */
  analyzeReferences(text, structure) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Simple check - if we have citations but no references section
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,?\s*\d{4}\)/.test(text);
    
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing References section",
        description: "Document has citations but no References section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesHeader",
        explanation: "All APA papers must include a References section."
      });
    }
    
    const referencesMatch = text.match(/References[\s\n]+([\s\S]+?)(?:\n\n[A-Z]|$)/i);
    if (!referencesMatch) return issues;
    
    const referencesText = referencesMatch[1].trim();
    const referenceEntries = referencesText
      .split(/\n\s*\n/)
      .filter(entry => entry.trim().length > 10);
    
    if (referenceEntries.length === 0) {
      issues.push({
        title: "Empty references section",
        description: "References section contains no entries",
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "The References section must contain entries for all sources cited in your paper."
      });
      return issues;
    }
    
    // Check alphabetical order
    const firstWords = referenceEntries.map(entry => {
      const match = entry.match(/^([^,\s]+)/);
      return match ? match[1].toLowerCase() : '';
    });
    
    const sortedFirstWords = [...firstWords].sort();
    const isAlphabetical = JSON.stringify(firstWords) === JSON.stringify(sortedFirstWords);
    
    if (!isAlphabetical) {
      issues.push({
        title: "References not in alphabetical order",
        description: "Reference entries must be alphabetized by first author's surname",
        text: `First entries: ${firstWords.slice(0, 3).join(', ')}...`,
        severity: "Major",
        category: "references",
        hasFix: true,
        fixAction: "sortReferences",
        explanation: "References must be arranged in alphabetical order by the surname of the first author."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze content for APA compliance
   */
  analyzeContent(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    
    return issues;
  }
  
  /**
   * Helper methods
   */
  prioritizeAndDeduplicateIssues(issues) {
    // Remove duplicates based on title and text
    const unique = issues.filter((issue, index, self) => 
      index === self.findIndex(i => 
        i.title === issue.title && i.text === issue.text
      )
    );
    
    // Sort by severity and category
    const severityOrder = { 'Critical': 0, 'Major': 1, 'Minor': 2 };
    const categoryOrder = { 
      'formatting': 0, 
      'structure': 1, 
      'citations': 2, 
      'references': 3, 
      'content': 4 
    };
    
    return unique.sort((a, b) => {
      // First by severity
      const severityCompare = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityCompare !== 0) return severityCompare;
      
      // Then by category
      return categoryOrder[a.category] - categoryOrder[b.category];
    });
  }
}

// Usage function that matches what your store expects
export function analyzeAPADocument(documentData) {
  const analyzer = new EnhancedAPAAnalyzer();
  return analyzer.analyzeDocument(documentData);
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\errorHandler.js
// Client-side error handling utilities for consistent error processing

/**
 * Extract error message from various error response formats
 * @param {Object|Error|string} error - Error object or response
 * @returns {string} - Standardized error message
 */
export function extractErrorMessage(error) {
  // Handle API response errors
  if (error?.error?.message) {
    return error.error.message;
  }

  // Handle legacy format
  if (error?.error && typeof error.error === 'string') {
    return error.error;
  }

  // Handle JavaScript Error objects
  if (error?.message) {
    return error.message;
  }

  // Handle string errors
  if (typeof error === 'string') {
    return error;
  }

  // Fallback
  return 'An unexpected error occurred';
}

/**
 * Extract error code from error response
 * @param {Object|Error} error - Error object or response
 * @returns {string|null} - Error code if available
 */
export function extractErrorCode(error) {
  return error?.error?.code || error?.code || null;
}

/**
 * Get user-friendly error message based on error code
 * @param {Object|Error|string} error - Error object or response
 * @returns {string} - User-friendly error message
 */
export function getUserFriendlyMessage(error) {
  const code = extractErrorCode(error);
  const message = extractErrorMessage(error);

  // Map error codes to user-friendly messages
  const friendlyMessages = {
    'NO_FILE': 'Please select a document to upload.',
    'FILE_TOO_LARGE': 'The selected file is too large. Please choose a smaller document.',
    'INVALID_FILE_TYPE': 'Please upload a valid .docx file.',
    'PROCESSING_FAILED': 'Failed to process the document. Please try again.',
    'PROCESSING_TIMEOUT': 'Document processing is taking longer than expected. Please try again with a smaller document.',
    'FIX_NOT_SUPPORTED': 'This fix is not currently supported.',
    'FIX_APPLICATION_FAILED': 'Failed to apply the fix. Please try again.',
    'INVALID_BUFFER': 'The document appears to be corrupted. Please try uploading again.',
    'BUFFER_TOO_LARGE': 'The document is too large to process. Please use a smaller document.',
    'NETWORK_ERROR': 'Network connection issue. Please check your internet connection and try again.',
    'SERVER_ERROR': 'Server is temporarily unavailable. Please try again in a few moments.',
    'REQUEST_TOO_LARGE': 'The request is too large. Please try with a smaller document.',
    'DOCUMENT_TOO_LARGE': 'The document is too large to process. Maximum size is 50MB.',
    'MISSING_PARAMS': 'Required information is missing. Please try again.',
    'INVALID_PARAMS': 'Invalid request parameters. Please try again.'
  };

  return friendlyMessages[code] || message || 'An unexpected error occurred';
}

/**
 * Check if error is retryable based on error code
 * @param {Object|Error} error - Error object or response
 * @returns {boolean} - Whether the error is retryable
 */
export function isRetryableError(error) {
  const code = extractErrorCode(error);
  const retryableCodes = [
    'NETWORK_ERROR',
    'SERVER_ERROR',
    'PROCESSING_TIMEOUT'
  ];

  return retryableCodes.includes(code);
}

/**
 * Check if error indicates a client-side issue (user fixable)
 * @param {Object|Error} error - Error object or response
 * @returns {boolean} - Whether the error is client-side
 */
export function isClientError(error) {
  const code = extractErrorCode(error);
  const clientCodes = [
    'NO_FILE',
    'FILE_TOO_LARGE',
    'INVALID_FILE_TYPE',
    'DOCUMENT_TOO_LARGE',
    'BUFFER_TOO_LARGE',
    'MISSING_PARAMS',
    'INVALID_PARAMS'
  ];

  return clientCodes.includes(code);
}

/**
 * Format error for logging
 * @param {Object|Error} error - Error object or response
 * @param {string} context - Context where error occurred
 * @returns {Object} - Formatted error for logging
 */
export function formatErrorForLogging(error, context) {
  return {
    context,
    message: extractErrorMessage(error),
    code: extractErrorCode(error),
    timestamp: new Date().toISOString(),
    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : 'unknown',
    url: typeof window !== 'undefined' ? window.location.href : 'unknown',
    ...(error?.error?.details && { details: error.error.details }),
    ...(error?.stack && { stack: error.stack })
  };
}

/**
 * Standardized error handling for API responses
 * @param {Response} response - Fetch response object
 * @returns {Promise<Object>} - Parsed error object
 */
export async function handleApiError(response) {
  let errorData;

  try {
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      errorData = await response.json();
    } else {
      const text = await response.text();
      errorData = {
        error: {
          message: text || `HTTP ${response.status}: ${response.statusText}`,
          code: 'SERVER_ERROR',
          statusCode: response.status
        }
      };
    }
  } catch (parseError) {
    errorData = {
      error: {
        message: `Failed to parse error response: ${response.status} ${response.statusText}`,
        code: 'SERVER_ERROR',
        statusCode: response.status
      }
    };
  }

  return errorData;
}

export default {
  extractErrorMessage,
  extractErrorCode,
  getUserFriendlyMessage,
  isRetryableError,
  isClientError,
  formatErrorForLogging,
  handleApiError
};

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\headerFooterValidator.js
// src/utils/headerFooterValidator.js - Running head and page number validation
'use client';

export class HeaderFooterValidator {
  constructor() {
    this.maxRunningHeadLength = 50;
  }

  /**
   * Validate headers, footers, running head, and page numbers
   */
  validateHeadersFooters(text, structure) {
    const issues = [];
    
    // Extract headers/footers from structure if available
    const headersFooters = structure?.headersFooters || {};
    
    // Validate running head
    issues.push(...this.validateRunningHead(headersFooters, text));
    
    // Validate page numbers
    issues.push(...this.validatePageNumbers(headersFooters, text));
    
    // Check for different first page header
    issues.push(...this.validateFirstPageHeader(headersFooters, text));
    
    // Validate section breaks
    issues.push(...this.validateSectionBreaks(headersFooters, text));
    
    return issues;
  }

  /**
   * FIXED: Validate running head format according to APA 7th Edition
   */
  validateRunningHead(headersFooters, text) {
    const issues = [];

    // UPDATED: APA 7th distinguishes between student and professional papers
    // Check if document appears to be a professional paper
    const wordCount = text.split(/\s+/).filter(Boolean).length;
    const hasRunningHeadText = text.toLowerCase().includes('running head');
    const isProfessionalPaper = hasRunningHeadText || wordCount > 5000; // Professional papers are typically longer

    // NEW: Detect if this is a student paper (common indicators)
    const isStudentPaper = text.toLowerCase().includes('student') ||
                          text.toLowerCase().includes('university') ||
                          text.toLowerCase().includes('course') ||
                          text.toLowerCase().includes('professor') ||
                          (!hasRunningHeadText && wordCount < 3000);

    if (isProfessionalPaper) {
      const runningHead = headersFooters.runningHead;

      // Check if running head exists for professional papers
      if (!runningHead && !headersFooters.headers?.length) {
        issues.push({
          title: "Missing running head (professional paper)",
          description: "Professional papers require a running head on every page",
          severity: "Major",
          category: "headers",
          hasFix: false,
          explanation: "Add a running head in the format: 'Running head: ABBREVIATED TITLE' on the title page, then 'ABBREVIATED TITLE' on subsequent pages."
        });
        return issues;
      }

      // Validate running head content for professional papers
      if (runningHead) {
        // Check length (max 50 characters)
        if (runningHead.length > this.maxRunningHeadLength) {
          issues.push({
            title: "Running head too long",
            description: `Running head is ${runningHead.length} characters (max 50)`,
            text: runningHead.text,
            severity: "Major",
            category: "headers",
            hasFix: false,
            explanation: "Running head must be 50 characters or less including spaces and punctuation."
          });
        }
        
        // Check if all caps
        if (runningHead.text && !runningHead.allCaps) {
          const upperText = runningHead.text.replace(/^Running head:\s*/i, '');
          if (upperText !== upperText.toUpperCase()) {
            issues.push({
              title: "Running head not in all caps",
              description: "Running head should be in ALL CAPITAL LETTERS",
              text: runningHead.text,
              severity: "Minor",
              category: "headers",
              hasFix: true,
              fixAction: "fixRunningHeadCaps",
              explanation: "The running head text (after 'Running head:') should be in all capital letters."
            });
          }
        }
        
        // Check first page format
        const firstPageHasLabel = text.substring(0, 2000).includes('Running head:');
        const hasRunningHeadText = runningHead.text && runningHead.text.length > 0;
        
        if (hasRunningHeadText && !firstPageHasLabel) {
          issues.push({
            title: "Missing 'Running head:' label on title page",
            description: "Title page should include 'Running head:' before the abbreviated title",
            severity: "Minor",
            category: "headers",
            hasFix: true,
            fixAction: "addRunningHeadLabel",
            explanation: "The title page header should read 'Running head: ABBREVIATED TITLE' while subsequent pages show only 'ABBREVIATED TITLE'."
          });
        }
      }
    } else if (isStudentPaper) {
      // NEW: APA 7th Edition - Student papers only need running head on title page
      const titlePageRunningHead = text.toLowerCase().includes('running head');

      if (!titlePageRunningHead) {
        issues.push({
          title: "Consider adding running head to title page",
          description: "APA 7th: Student papers only need running head on title page (optional for other pages)",
          severity: "Minor", // Optional for students
          category: "headers",
          hasFix: false,
          explanation: "Student papers: Add 'Running head: ABBREVIATED TITLE' only on title page. Other pages can just have the page header or nothing."
        });
      }
    }

    return issues;
  }

  /**
   * Validate page number positioning
   */
  validatePageNumbers(headersFooters, text) {
    const issues = [];
    const pageNumbers = headersFooters.pageNumbers || {};
    
    // Check if page numbers exist
    if (!pageNumbers.present) {
      // Check if document has multiple pages (rough estimate based on content)
      const estimatedPages = Math.ceil(text.split(/\s+/).length / 250); // ~250 words per page
      
      if (estimatedPages > 1) {
        issues.push({
          title: "Missing page numbers",
          description: "Document appears to have multiple pages but no page numbers detected",
          severity: "Major",
          category: "headers",
          hasFix: false,
          explanation: "All pages should be numbered consecutively, starting with the title page as page 1."
        });
      }
    } else {
      // Check positioning (should be top right)
      if (pageNumbers.position && pageNumbers.position !== 'right') {
        issues.push({
          title: "Incorrect page number position",
          description: `Page numbers are ${pageNumbers.position}-aligned instead of right-aligned`,
          severity: "Minor",
          category: "headers",
          hasFix: true,
          fixAction: "fixPageNumberPosition",
          explanation: "Page numbers should be positioned in the top right corner of every page."
        });
      }
      
      // Check if in header (not footer)
      const inFooter = headersFooters.footers?.some(f => f.hasPageNumber);
      const inHeader = headersFooters.headers?.some(h => h.hasPageNumber);
      
      if (inFooter && !inHeader) {
        issues.push({
          title: "Page numbers in footer instead of header",
          description: "Page numbers should be in the header, not the footer",
          severity: "Major",
          category: "headers",
          hasFix: true,
          fixAction: "movePageNumbersToHeader",
          explanation: "APA format requires page numbers in the top right corner of the header, not in the footer."
        });
      }
    }
    
    return issues;
  }

  /**
   * Validate first page header differences
   */
  validateFirstPageHeader(headersFooters, text) {
    const issues = [];
    
    // Check if there's a different first page header setting
    if (headersFooters.firstPageHeader || headersFooters.firstPageFooter) {
      // This is often correct for APA (different first page for running head)
      // But check if it's properly configured
      
      const hasRunningHead = headersFooters.runningHead;
      const firstPageText = text.substring(0, 2000);
      
      if (hasRunningHead && !firstPageText.includes('Running head:')) {
        issues.push({
          title: "First page header configuration issue",
          description: "Different first page header detected but may not be properly configured",
          severity: "Minor",
          category: "headers",
          hasFix: false,
          explanation: "The title page should have 'Running head: TITLE' while other pages have just 'TITLE'."
        });
      }
    }
    
    // Check for title page elements
    const titlePageElements = this.checkTitlePageElements(text);
    if (!titlePageElements.hasAll) {
      const missing = [];
      if (!titlePageElements.hasTitle) missing.push('paper title');
      if (!titlePageElements.hasAuthor) missing.push('author name(s)');
      if (!titlePageElements.hasAffiliation) missing.push('institutional affiliation');
      
      if (missing.length > 0) {
        issues.push({
          title: "Incomplete title page",
          description: `Title page missing: ${missing.join(', ')}`,
          severity: "Major",
          category: "structure",
          hasFix: false,
          explanation: "APA title page must include: paper title, author name(s), institutional affiliation, and author note (if applicable)."
        });
      }
    }
    
    return issues;
  }

  /**
   * Check title page elements
   */
  checkTitlePageElements(text) {
    const firstPage = text.substring(0, 1500);
    const lines = firstPage.split('\n').map(l => l.trim()).filter(l => l.length > 0);
    
    // Simple heuristics for title page elements
    const hasTitle = lines.some(line => 
      line.length > 10 && 
      line.length < 100 && 
      !line.includes('Running head') &&
      line[0] === line[0].toUpperCase()
    );
    
    // Check for author names (typically after title)
    const hasAuthor = lines.some((line, i) => 
      i > 0 && // Not first line
      line.length > 3 && 
      line.length < 50 &&
      /^[A-Z][a-z]+/.test(line) && // Starts with capital letter
      !line.includes('University') &&
      !line.includes('College')
    );
    
    // Check for affiliation (university/institution name)
    const hasAffiliation = lines.some(line => 
      line.includes('University') || 
      line.includes('College') || 
      line.includes('Institute') ||
      line.includes('Department')
    );
    
    return {
      hasTitle,
      hasAuthor,
      hasAffiliation,
      hasAll: hasTitle && hasAuthor && hasAffiliation
    };
  }

  /**
   * Validate section breaks and headers consistency
   */
  validateSectionBreaks(headersFooters, text) {
    const issues = [];
    
    // Check if there are multiple header/footer definitions (indicating section breaks)
    const headerCount = headersFooters.headers?.length || 0;
    const footerCount = headersFooters.footers?.length || 0;
    
    if (headerCount > 3 || footerCount > 3) {
      // Multiple section breaks detected
      issues.push({
        title: "Multiple section breaks detected",
        description: "Document has multiple section breaks which may cause header/footer inconsistencies",
        severity: "Minor",
        category: "headers",
        hasFix: false,
        explanation: "APA format typically uses consistent headers throughout. Avoid unnecessary section breaks unless needed for landscape pages or appendices."
      });
    }
    
    // Check for consistency across headers
    if (headersFooters.headers && headersFooters.headers.length > 1) {
      const firstHeader = headersFooters.headers[0];
      const inconsistentHeaders = headersFooters.headers.filter(h => 
        h.text !== firstHeader.text && 
        !h.text.includes('Running head')
      );
      
      if (inconsistentHeaders.length > 0) {
        issues.push({
          title: "Inconsistent headers across document",
          description: "Headers vary across different sections of the document",
          severity: "Minor",
          category: "headers",
          hasFix: false,
          explanation: "Maintain consistent headers throughout the document, except for the title page which may have 'Running head:' prefix."
        });
      }
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\IncrementalAPAAnalyzer.js
'use client';

import { EnhancedAPAAnalyzer } from './enhancedApaAnalyzer';

/**
 * Incremental APA Analyzer - Optimized for DocumentModel architecture
 * Provides 90% performance improvement through smart caching and incremental analysis
 */
export class IncrementalAPAAnalyzer extends EnhancedAPAAnalyzer {
  constructor(validators = {}) {
    super(validators);

    // Analysis cache for paragraphs
    this.paragraphCache = new Map(); // paragraph-hash -> analysis-results
    this.documentCache = new Map(); // document-hash -> document-level-issues

    // Performance tracking
    this.performanceStats = {
      fullAnalysisCount: 0,
      incrementalAnalysisCount: 0,
      cacheHitCount: 0,
      avgFullAnalysisTime: 0,
      avgIncrementalAnalysisTime: 0
    };

    this.maxCacheSize = 1000; // Limit cache size for memory management
  }

  /**
   * Analyze document with intelligent incremental processing
   */
  analyzeDocument(documentData, options = {}) {
    const startTime = Date.now();
    const {
      changedParagraphs = null,
      preserveUnchanged = true,
      force = false
    } = options;

    if (process.env.NODE_ENV === 'development') {
      console.log(`🧠 Starting APA analysis (${changedParagraphs ? 'incremental' : 'full'})...`);
    }

    let issues = [];

    if (changedParagraphs && changedParagraphs.length > 0 && preserveUnchanged && !force) {
      // Incremental analysis
      issues = this._performIncrementalAnalysis(documentData, changedParagraphs);
      this.performanceStats.incrementalAnalysisCount++;
    } else {
      // Full analysis
      issues = this._performFullAnalysis(documentData);
      this.performanceStats.fullAnalysisCount++;
    }

    const analysisTime = Date.now() - startTime;

    // Update performance stats
    if (changedParagraphs) {
      this.performanceStats.avgIncrementalAnalysisTime =
        (this.performanceStats.avgIncrementalAnalysisTime + analysisTime) / 2;
    } else {
      this.performanceStats.avgFullAnalysisTime =
        (this.performanceStats.avgFullAnalysisTime + analysisTime) / 2;
    }

    if (process.env.NODE_ENV === 'development') {
      console.log(`✅ Analysis complete: ${issues.length} issues found in ${analysisTime}ms`);
    }

    return this.prioritizeAndDeduplicateIssues(issues);
  }

  /**
   * Perform full analysis with caching
   */
  _performFullAnalysis(documentData) {
    const issues = [];

    // Clear paragraph cache for full reanalysis
    this.paragraphCache.clear();

    // Analyze document structure and formatting (always full analysis)
    issues.push(...this._analyzeDocumentLevel(documentData));

    // Analyze each paragraph with caching
    if (documentData.formatting?.paragraphs) {
      documentData.formatting.paragraphs.forEach((paragraph, index) => {
        const paragraphIssues = this._analyzeParagraphWithCache(paragraph, index, documentData);
        issues.push(...paragraphIssues);
      });
    }

    // Analyze cross-paragraph dependencies
    issues.push(...this._analyzeCrossParagraphDependencies(documentData));

    return issues;
  }

  /**
   * Perform incremental analysis on changed paragraphs only
   */
  _performIncrementalAnalysis(documentData, changedParagraphs) {
    const issues = [];

    // Get existing issues from cache (document-level issues)
    const documentHash = this._hashDocumentStructure(documentData);
    const cachedDocumentIssues = this.documentCache.get(documentHash) || [];

    // Only re-analyze document-level issues if structure changed significantly
    if (this._hasStructuralChanges(documentData, changedParagraphs)) {
      const documentIssues = this._analyzeDocumentLevel(documentData);
      this.documentCache.set(documentHash, documentIssues);
      issues.push(...documentIssues);
    } else {
      issues.push(...cachedDocumentIssues);
    }

    // Analyze only changed paragraphs
    const changedParagraphIds = new Set(changedParagraphs.map(p => p.id));

    // Get paragraph data for analysis
    if (documentData.formatting?.paragraphs) {
      documentData.formatting.paragraphs.forEach((paragraph, index) => {
        const paragraphId = changedParagraphs.find(cp => cp.index === index)?.id;

        if (paragraphId && changedParagraphIds.has(paragraphId)) {
          // Analyze changed paragraph
          const paragraphIssues = this._analyzeParagraphWithCache(paragraph, index, documentData, true);
          issues.push(...paragraphIssues);
        } else {
          // Load from cache if available
          const paragraphHash = this._hashParagraph(paragraph);
          const cachedIssues = this.paragraphCache.get(paragraphHash);

          if (cachedIssues) {
            issues.push(...cachedIssues);
            this.performanceStats.cacheHitCount++;
          } else {
            // Analyze and cache
            const paragraphIssues = this._analyzeParagraphWithCache(paragraph, index, documentData);
            issues.push(...paragraphIssues);
          }
        }
      });
    }

    // Analyze cross-paragraph dependencies for changed paragraphs
    if (this._affectsCrossParagraphRules(changedParagraphs)) {
      issues.push(...this._analyzeCrossParagraphDependencies(documentData));
    }

    return issues;
  }

  /**
   * Analyze paragraph with caching
   */
  _analyzeParagraphWithCache(paragraph, index, documentData, forceReanalysis = false) {
    const paragraphHash = this._hashParagraph(paragraph);

    // Check cache first
    if (!forceReanalysis && this.paragraphCache.has(paragraphHash)) {
      this.performanceStats.cacheHitCount++;
      return this.paragraphCache.get(paragraphHash);
    }

    // Analyze paragraph
    const issues = this._analyzeSingleParagraph(paragraph, index, documentData);

    // Cache results
    this._cacheParagraphResult(paragraphHash, issues);

    return issues;
  }

  /**
   * Analyze single paragraph (all paragraph-level rules)
   */
  _analyzeSingleParagraph(paragraph, index, documentData) {
    const issues = [];

    try {
      // Extract paragraph text
      const paragraphText = paragraph.text || '';
      if (!paragraphText.trim()) {
        return issues;
      }

      // Citation analysis (paragraph level)
      issues.push(...this._analyzeParagraphCitations(paragraphText, index));

      // Quotation analysis
      issues.push(...this._analyzeParagraphQuotations(paragraphText, index));

      // Statistical notation analysis
      issues.push(...this._analyzeParagraphStatistics(paragraphText, index));

      // Bias-free language analysis
      issues.push(...this._analyzeParagraphBiasLanguage(paragraphText, index));

      // Formatting analysis (paragraph level)
      issues.push(...this._analyzeParagraphFormatting(paragraph, index));

      // List and series analysis
      issues.push(...this._analyzeParagraphLists(paragraphText, index));

      // Abbreviation analysis
      issues.push(...this._analyzeParagraphAbbreviations(paragraphText, index));

    } catch (error) {
      console.error(`Error analyzing paragraph ${index}:`, error);
      issues.push(this.createErrorIssue(
        `paragraph-${index}-error`,
        `Paragraph ${index + 1} analysis failed`,
        error.message
      ));
    }

    return issues;
  }

  /**
   * Analyze document-level issues (structure, references, etc.)
   */
  _analyzeDocumentLevel(documentData) {
    const issues = [];

    try {
      // Document formatting analysis
      if (documentData.formatting) {
        issues.push(...this.analyzeFormatting(documentData.formatting));
      }

      // Document structure analysis
      if (documentData.structure) {
        issues.push(...this.analyzeStructure(documentData.structure, documentData.text));
      }

      // References analysis (full document)
      issues.push(...this._analyzeDocumentReferences(documentData));

      // Headers and footers
      if (documentData.structure?.headersFooters) {
        const headerFooterIssues = this.headerFooterValidator.validateHeadersFooters(
          documentData.text,
          documentData.structure
        );
        issues.push(...(Array.isArray(headerFooterIssues) ? headerFooterIssues : []));
      }

      // Tables and figures (document level)
      if (documentData.structure?.tables || documentData.structure?.figures) {
        const tableFigureIssues = this.tableFigureValidator.validateTablesAndFigures(
          documentData.text,
          documentData.structure,
          documentData.formatting
        );
        issues.push(...(Array.isArray(tableFigureIssues) ? tableFigureIssues : []));
      }

    } catch (error) {
      console.error('Error in document-level analysis:', error);
      issues.push(this.createErrorIssue(
        'document-level-error',
        'Document-level analysis failed',
        error.message
      ));
    }

    return issues;
  }

  /**
   * Analyze cross-paragraph dependencies (references, citations, etc.)
   */
  _analyzeCrossParagraphDependencies(documentData) {
    const issues = [];

    try {
      // Reference validation (cross-paragraph)
      if (documentData.text) {
        const referenceIssues = this.referenceValidator.validateReferences(
          documentData.text,
          documentData.structure,
          documentData.structure?.italicizedText || []
        );
        issues.push(...(Array.isArray(referenceIssues) ? referenceIssues : []));
      }

      // Citation cross-referencing
      const crossRefIssues = this._validateCitationCrossReferences(documentData);
      issues.push(...crossRefIssues);

      // Sequential numbering (tables, figures)
      const sequenceIssues = this._validateSequentialNumbering(documentData);
      issues.push(...sequenceIssues);

    } catch (error) {
      console.error('Error in cross-paragraph analysis:', error);
      issues.push(this.createErrorIssue(
        'cross-paragraph-error',
        'Cross-paragraph analysis failed',
        error.message
      ));
    }

    return issues;
  }

  // === PARAGRAPH-LEVEL ANALYZERS ===

  _analyzeParagraphCitations(text, paragraphIndex) {
    const issues = [];

    // Basic citation patterns
    const citationPattern = /\(([^)]+),\s*(\d{4})\)/g;
    let match;

    while ((match = citationPattern.exec(text)) !== null) {
      const fullCitation = match[0];
      const authorPart = match[1];

      // Check for "and" vs "&" in parenthetical citations
      if (authorPart.includes(' and ') && !authorPart.includes('et al')) {
        issues.push({
          id: `citation-and-${paragraphIndex}-${match.index}`,
          title: 'Use & instead of "and" in parenthetical citations',
          description: 'Parenthetical citations should use & to connect author names',
          text: fullCitation,
          highlightText: fullCitation,
          severity: 'Minor',
          category: 'citations',
          location: {
            paragraphIndex,
            charOffset: match.index,
            length: fullCitation.length,
            type: 'text'
          },
          hasFix: true,
          fixAction: 'fixParentheticalConnector',
          fixValue: {
            original: fullCitation,
            replacement: fullCitation.replace(' and ', ' & ')
          },
          explanation: 'In parenthetical citations, use & to connect author names, not "and".'
        });
      }

      // Check for comma before et al. (APA 7th doesn't use comma)
      if (authorPart.includes(', et al.')) {
        issues.push({
          id: `citation-et-al-${paragraphIndex}-${match.index}`,
          title: 'Remove comma before "et al." in citations',
          description: 'APA 7th edition does not use comma before "et al."',
          text: fullCitation,
          highlightText: fullCitation,
          severity: 'Minor',
          category: 'citations',
          location: {
            paragraphIndex,
            charOffset: match.index,
            length: fullCitation.length,
            type: 'text'
          },
          hasFix: true,
          fixAction: 'fixEtAlFormatting',
          fixValue: {
            original: fullCitation,
            replacement: fullCitation.replace(', et al.', ' et al.')
          },
          explanation: 'APA 7th edition format: (Smith et al., 2021), not (Smith, et al., 2021).'
        });
      }
    }

    return issues;
  }

  _analyzeParagraphQuotations(text, paragraphIndex) {
    const issues = [];

    // Check for direct quotes without page numbers
    const quotePattern = /[""][^""]{10,}[""]\s*(\([^)]+\))/g;
    let match;

    while ((match = quotePattern.exec(text)) !== null) {
      const citation = match[1];
      if (!citation.match(/,\s*p\.?\s*\d+/)) {
        issues.push({
          id: `quote-page-${paragraphIndex}-${match.index}`,
          title: 'Direct quote missing page number',
          description: 'Direct quotations must include page numbers',
          text: match[0],
          highlightText: match[0],
          severity: 'Major',
          category: 'citations',
          location: {
            paragraphIndex,
            charOffset: match.index,
            length: match[0].length,
            type: 'text'
          },
          hasFix: false,
          explanation: 'All direct quotations must include a page number to help readers locate the original text.'
        });
      }
    }

    return issues;
  }

  _analyzeParagraphStatistics(text, paragraphIndex) {
    const issues = [];

    // Check for statistical values that should be italicized
    const statPattern = /\b(p|t|F|r|M|SD|N|n)\s*[=<>]\s*[\d.]+/g;
    let match;

    while ((match = statPattern.exec(text)) !== null) {
      const statSymbol = match[1];

      // Check if it's already italicized (simple heuristic)
      if (!this._isTextItalicized(text, match.index, match[0].length)) {
        issues.push({
          id: `stat-italic-${paragraphIndex}-${match.index}`,
          title: `Statistical symbol "${statSymbol}" should be italicized`,
          description: 'Statistical symbols should be italicized in APA format',
          text: match[0],
          highlightText: match[0],
          severity: 'Minor',
          category: 'formatting',
          location: {
            paragraphIndex,
            charOffset: match.index,
            length: match[0].length,
            type: 'text'
          },
          hasFix: true,
          fixAction: 'italicizeStatSymbol',
          explanation: 'Statistical symbols (p, t, F, r, M, SD) should be italicized according to APA guidelines.'
        });
      }
    }

    return issues;
  }

  _analyzeParagraphBiasLanguage(text, paragraphIndex) {
    const issues = [];

    // Define bias-free language patterns
    const biasTerms = [
      { term: 'chairman', replacement: 'chairperson', reason: 'Use gender-neutral language' },
      { term: 'mankind', replacement: 'humankind', reason: 'Use inclusive language' },
      { term: 'normal people', replacement: 'people without disabilities', reason: 'Avoid ableist language' },
      { term: 'handicapped', replacement: 'person with a disability', reason: 'Use person-first language' }
    ];

    biasTerms.forEach(({ term, replacement, reason }) => {
      const regex = new RegExp(`\\b${term}\\b`, 'gi');
      let match;

      while ((match = regex.exec(text)) !== null) {
        issues.push({
          id: `bias-${term}-${paragraphIndex}-${match.index}`,
          title: `Consider replacing "${match[0]}" with "${replacement}"`,
          description: reason,
          text: match[0],
          highlightText: match[0],
          severity: 'Minor',
          category: 'language',
          location: {
            paragraphIndex,
            charOffset: match.index,
            length: match[0].length,
            type: 'text'
          },
          hasFix: true,
          fixAction: 'replaceBiasedTerm',
          fixValue: { original: match[0], replacement },
          explanation: `APA encourages bias-free language. ${reason}.`
        });
      }
    });

    return issues;
  }

  _analyzeParagraphFormatting(paragraph, paragraphIndex) {
    const issues = [];

    // Check for ALL CAPS headings
    const text = paragraph.text?.trim() || '';
    if (text.length >= 3 &&
        text === text.toUpperCase() &&
        !text.includes('\n') &&
        !text.includes('(') &&
        !text.includes(',') &&
        text.split(' ').length <= 8 &&
        /^[A-Z\s]+$/.test(text)) {
      // Convert to Title Case (capitalize first letter of each word)
      const titleCase = text
        .toLowerCase()
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');

      issues.push({
        id: `all-caps-heading-${paragraphIndex}`,
        title: 'ALL CAPS heading detected',
        description: 'Headings should use title case or sentence case, not ALL CAPS',
        text: text,
        highlightText: text,
        severity: 'Minor',
        category: 'formatting',
        location: {
          paragraphIndex,
          charOffset: 0,
          length: text.length,
          type: 'text'
        },
        hasFix: true,
        fixAction: 'fixAllCapsHeading',
        fixValue: {
          original: text,
          replacement: titleCase
        },
        explanation: 'APA 7th edition headings should use title case (Level 1-3) or sentence case (Level 4-5), not ALL CAPS.'
      });
    }

    // Check paragraph indentation
    if (paragraph.indentation?.firstLine) {
      const indent = paragraph.indentation.firstLine;
      if (Math.abs(indent - 0.5) > 0.05) {
        issues.push({
          id: `indent-${paragraphIndex}`,
          title: 'Incorrect paragraph indentation',
          description: `Paragraph has ${indent}" indentation instead of 0.5"`,
          severity: 'Minor',
          category: 'formatting',
          location: {
            paragraphIndex,
            type: 'paragraph'
          },
          hasFix: true,
          fixAction: 'fixParagraphIndentation',
          fixValue: 0.5,
          explanation: 'APA format requires 0.5-inch first-line indentation for all paragraphs.'
        });
      }
    }

    return issues;
  }

  _analyzeParagraphLists(text, paragraphIndex) {
    const issues = [];

    // Check for serial comma issues
    const serialCommaPattern = /(\w+),\s*(\w+)\s+and\s+(\w+)/g;
    let match;

    while ((match = serialCommaPattern.exec(text)) !== null) {
      issues.push({
        id: `serial-comma-${paragraphIndex}-${match.index}`,
        title: 'Missing serial comma',
        description: 'APA style requires serial commas in series of three or more items',
        text: match[0],
        highlightText: match[0],
        severity: 'Minor',
        category: 'grammar',
        location: {
          paragraphIndex,
          charOffset: match.index,
          length: match[0].length,
          type: 'text'
        },
        hasFix: true,
        fixAction: 'addSerialComma',
        explanation: 'Use commas to separate three or more items in a series, including before "and".'
      });
    }

    return issues;
  }

  _analyzeParagraphAbbreviations(text, paragraphIndex) {
    const issues = [];

    // Skip if the entire text is an ALL CAPS heading (3+ chars, all uppercase, single line)
    const trimmedText = text.trim();
    if (trimmedText.length >= 3 &&
        trimmedText === trimmedText.toUpperCase() &&
        !trimmedText.includes('\n') &&
        !trimmedText.includes('(') &&
        !trimmedText.includes(',') &&
        trimmedText.split(' ').length <= 8 &&
        /^[A-Z\s]+$/.test(trimmedText)) {
      // This is likely an ALL CAPS heading, skip abbreviation checking
      return issues;
    }

    // Check for abbreviations that might need definition
    const abbrPattern = /\b([A-Z]{2,})\b/g;
    let match;

    while ((match = abbrPattern.exec(text)) !== null) {
      const abbr = match[1];

      // Skip common abbreviations
      if (!['USA', 'UK', 'US', 'APA', 'HTML', 'PDF', 'URL'].includes(abbr)) {
        issues.push({
          id: `abbr-definition-${abbr}-${paragraphIndex}-${match.index}`,
          title: `Consider defining abbreviation "${abbr}"`,
          description: 'Abbreviations should be defined on first use',
          text: abbr,
          highlightText: abbr,
          severity: 'Minor',
          category: 'style',
          location: {
            paragraphIndex,
            charOffset: match.index,
            length: abbr.length,
            type: 'text'
          },
          hasFix: false,
          explanation: 'Define abbreviations on first use: Full Term (FT) and then use FT throughout.'
        });
      }
    }

    return issues;
  }

  // === UTILITY METHODS ===

  _hashParagraph(paragraph) {
    const content = {
      text: paragraph.text || '',
      formatting: paragraph.formatting || {},
      runs: paragraph.runs?.map(r => ({ text: r.text, font: r.font })) || []
    };

    const str = JSON.stringify(content);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }

  _hashDocumentStructure(documentData) {
    const structure = {
      headings: documentData.structure?.headings || [],
      sections: documentData.structure?.sections || [],
      documentFormatting: documentData.formatting?.document || {}
    };

    const str = JSON.stringify(structure);
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      const char = str.charCodeAt(i);
      hash = ((hash << 5) - hash) + char;
      hash = hash & hash;
    }
    return Math.abs(hash).toString(36);
  }

  _hasStructuralChanges(documentData, changedParagraphs) {
    // Check if any changed paragraphs contain headings or structural elements
    const headingIndices = documentData.structure?.headings?.map(h => h.paragraphIndex) || [];
    return changedParagraphs.some(p => headingIndices.includes(p.index));
  }

  _affectsCrossParagraphRules(changedParagraphs) {
    // Check if changes affect rules that span paragraphs (references, citations, etc.)
    return changedParagraphs.some(p =>
      p.text?.toLowerCase().includes('references') ||
      p.text?.toLowerCase().includes('bibliography') ||
      /\([^)]+,\s*\d{4}\)/.test(p.text || '') // Contains citations
    );
  }

  _isTextItalicized(text, startIndex, length) {
    // Simple heuristic - check for italic markers around text
    const beforeText = text.substring(Math.max(0, startIndex - 5), startIndex);
    const afterText = text.substring(startIndex + length, startIndex + length + 5);

    return (beforeText.includes('*') && afterText.includes('*')) ||
           (beforeText.includes('_') && afterText.includes('_'));
  }

  _cacheParagraphResult(hash, issues) {
    // Manage cache size
    if (this.paragraphCache.size >= this.maxCacheSize) {
      // Remove oldest 20% of entries
      const keysToRemove = Array.from(this.paragraphCache.keys()).slice(0, Math.floor(this.maxCacheSize * 0.2));
      keysToRemove.forEach(key => this.paragraphCache.delete(key));
    }

    this.paragraphCache.set(hash, issues);
  }

  _analyzeDocumentReferences(documentData) {
    // Use existing reference validator but cache document-level aspects
    if (!documentData.text) return [];

    try {
      const referenceIssues = this.referenceValidator.validateReferences(
        documentData.text,
        documentData.structure,
        documentData.structure?.italicizedText || []
      );
      return Array.isArray(referenceIssues) ? referenceIssues : [];
    } catch (error) {
      console.error('Error in reference analysis:', error);
      return [this.createErrorIssue('reference-error', 'Reference analysis failed', error.message)];
    }
  }

  _validateCitationCrossReferences(documentData) {
    // Implement citation cross-reference validation
    return []; // TODO: Implement cross-referencing logic
  }

  _validateSequentialNumbering(documentData) {
    // Implement sequential numbering validation for tables/figures
    return []; // TODO: Implement sequential numbering logic
  }

  /**
   * Get performance statistics
   */
  getPerformanceStats() {
    return {
      ...this.performanceStats,
      cacheSize: this.paragraphCache.size,
      documentCacheSize: this.documentCache.size,
      cacheHitRate: this.performanceStats.cacheHitCount /
                   (this.performanceStats.fullAnalysisCount + this.performanceStats.incrementalAnalysisCount) || 0
    };
  }

  /**
   * Clear analysis cache
   */
  clearCache() {
    this.paragraphCache.clear();
    this.documentCache.clear();
    if (process.env.NODE_ENV === 'development') {
      console.log('🧹 Analysis cache cleared');
    }
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\indexedDBManager.js
'use client';

import { openDB } from 'idb';

/**
 * IndexedDB Manager for local document persistence
 * Provides reload safety by storing Tiptap JSON locally
 *
 * Three-layer architecture:
 * 1. In-memory: Tiptap editor state (immediate edits)
 * 2. IndexedDB: Local persistence (reload safety) <- THIS LAYER
 * 3. Supabase: Long-term storage (multi-device sync)
 */

const DB_NAME = 'apa-checker';
const DB_VERSION = 1;
const STORE_NAME = 'documents';

class IndexedDBManager {
  constructor() {
    this.db = null;
    this.isSupported = typeof window !== 'undefined' && 'indexedDB' in window;
  }

  /**
   * Initialize the IndexedDB database
   */
  async init() {
    if (!this.isSupported) {
      console.warn('⚠️ IndexedDB not supported in this environment');
      return null;
    }

    if (this.db) {
      return this.db;
    }

    try {
      this.db = await openDB(DB_NAME, DB_VERSION, {
        upgrade(db) {
          // Create documents store if it doesn't exist
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });

            // Create indexes for efficient querying
            store.createIndex('lastSaved', 'lastSaved');
            store.createIndex('documentId', 'documentId');

            console.log('✅ IndexedDB object store created');
          }
        },
      });

      console.log('✅ IndexedDB initialized');
      return this.db;
    } catch (error) {
      console.error('❌ Failed to initialize IndexedDB:', error);
      this.isSupported = false;
      return null;
    }
  }

  /**
   * Save document to IndexedDB
   * Called on every edit (debounced 2-3 seconds)
   *
   * @param {string} documentId - Document ID (from Supabase or temporary)
   * @param {object} tiptapContent - Tiptap JSON content
   * @param {object} metadata - Additional metadata
   */
  async saveToIndexedDB(documentId, tiptapContent, metadata = {}) {
    if (!this.isSupported) {
      return { success: false, error: 'IndexedDB not supported' };
    }

    try {
      await this.init();

      if (!this.db) {
        throw new Error('IndexedDB not initialized');
      }

      const documentData = {
        id: `doc-${documentId}`, // Prefix to avoid collisions
        documentId: documentId,
        tiptapContent: tiptapContent,
        lastSaved: Date.now(),
        metadata: {
          ...metadata,
          version: metadata.version || 1,
          userAgent: navigator.userAgent.substring(0, 100),
        }
      };

      await this.db.put(STORE_NAME, documentData);

      if (process.env.NODE_ENV === 'development') {
        console.log(`💾 Saved to IndexedDB: ${documentId}`, {
          size: JSON.stringify(tiptapContent).length,
          timestamp: new Date(documentData.lastSaved).toISOString()
        });
      }

      return {
        success: true,
        savedAt: documentData.lastSaved
      };

    } catch (error) {
      console.error('❌ Failed to save to IndexedDB:', error);

      // Check for quota exceeded error
      if (error.name === 'QuotaExceededError') {
        return {
          success: false,
          error: 'Storage quota exceeded',
          shouldClearOld: true
        };
      }

      return {
        success: false,
        error: error.message
      };
    }
  }

  /**
   * Load document from IndexedDB
   * Called on page load/reload to restore unsaved changes
   *
   * @param {string} documentId - Document ID to load
   * @returns {object|null} Document data or null if not found
   */
  async loadFromIndexedDB(documentId) {
    if (!this.isSupported) {
      return null;
    }

    try {
      await this.init();

      if (!this.db) {
        return null;
      }

      const documentData = await this.db.get(STORE_NAME, `doc-${documentId}`);

      if (documentData) {
        if (process.env.NODE_ENV === 'development') {
          console.log(`📂 Loaded from IndexedDB: ${documentId}`, {
            lastSaved: new Date(documentData.lastSaved).toISOString(),
            age: Math.round((Date.now() - documentData.lastSaved) / 1000) + 's'
          });
        }

        return {
          tiptapContent: documentData.tiptapContent,
          lastSaved: documentData.lastSaved,
          metadata: documentData.metadata
        };
      }

      return null;

    } catch (error) {
      console.error('❌ Failed to load from IndexedDB:', error);
      return null;
    }
  }

  /**
   * Clear document from IndexedDB
   * Called after successful Supabase save to prevent stale data
   *
   * @param {string} documentId - Document ID to clear
   */
  async clearFromIndexedDB(documentId) {
    if (!this.isSupported) {
      return { success: false };
    }

    try {
      await this.init();

      if (!this.db) {
        return { success: false };
      }

      await this.db.delete(STORE_NAME, `doc-${documentId}`);

      if (process.env.NODE_ENV === 'development') {
        console.log(`🗑️ Cleared from IndexedDB: ${documentId}`);
      }

      return { success: true };

    } catch (error) {
      console.error('❌ Failed to clear from IndexedDB:', error);
      return { success: false, error: error.message };
    }
  }

  /**
   * Check if document exists in IndexedDB
   *
   * @param {string} documentId - Document ID to check
   * @returns {boolean} True if document exists
   */
  async hasLocalDraft(documentId) {
    if (!this.isSupported) {
      return false;
    }

    try {
      await this.init();

      if (!this.db) {
        return false;
      }

      const data = await this.db.get(STORE_NAME, `doc-${documentId}`);
      return !!data;

    } catch (error) {
      console.error('❌ Failed to check IndexedDB:', error);
      return false;
    }
  }

  /**
   * Get all stored documents (for debugging/cleanup)
   */
  async getAllDocuments() {
    if (!this.isSupported) {
      return [];
    }

    try {
      await this.init();

      if (!this.db) {
        return [];
      }

      return await this.db.getAll(STORE_NAME);

    } catch (error) {
      console.error('❌ Failed to get all documents:', error);
      return [];
    }
  }

  /**
   * Clear old drafts (older than specified days)
   * Helps prevent quota issues
   *
   * @param {number} daysOld - Delete drafts older than this many days
   */
  async clearOldDrafts(daysOld = 7) {
    if (!this.isSupported) {
      return { success: false, cleared: 0 };
    }

    try {
      await this.init();

      if (!this.db) {
        return { success: false, cleared: 0 };
      }

      const cutoffTime = Date.now() - (daysOld * 24 * 60 * 60 * 1000);
      const allDocs = await this.db.getAll(STORE_NAME);

      let clearedCount = 0;

      for (const doc of allDocs) {
        if (doc.lastSaved < cutoffTime) {
          await this.db.delete(STORE_NAME, doc.id);
          clearedCount++;
        }
      }

      if (clearedCount > 0) {
        console.log(`🗑️ Cleared ${clearedCount} old draft(s) from IndexedDB`);
      }

      return { success: true, cleared: clearedCount };

    } catch (error) {
      console.error('❌ Failed to clear old drafts:', error);
      return { success: false, cleared: 0, error: error.message };
    }
  }

  /**
   * Get storage usage estimate
   */
  async getStorageEstimate() {
    if (!this.isSupported || !navigator.storage || !navigator.storage.estimate) {
      return null;
    }

    try {
      const estimate = await navigator.storage.estimate();

      return {
        usage: estimate.usage,
        quota: estimate.quota,
        usagePercent: estimate.quota > 0 ? (estimate.usage / estimate.quota * 100).toFixed(2) : 0,
        usageMB: (estimate.usage / (1024 * 1024)).toFixed(2),
        quotaMB: (estimate.quota / (1024 * 1024)).toFixed(2)
      };

    } catch (error) {
      console.error('❌ Failed to get storage estimate:', error);
      return null;
    }
  }

  /**
   * Check if storage is approaching quota
   * Returns true if usage > 80%
   */
  async isStorageNearQuota() {
    const estimate = await this.getStorageEstimate();

    if (!estimate) {
      return false;
    }

    return parseFloat(estimate.usagePercent) > 80;
  }
}

// Export singleton instance
export const indexedDBManager = new IndexedDBManager();

// Export class for testing
export { IndexedDBManager };


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\quotationValidator.js
// src/utils/quotationValidator.js - Quotation and block quote validation
'use client';

export class QuotationValidator {
  constructor() {
    this.blockQuoteMinWords = 40;
  }

  /**
   * Validate quotation handling and formatting
   */
  validateQuotations(text, structure) {
    const issues = [];
    
    // Block quote detection and formatting
    issues.push(...this.validateBlockQuotes(text));
    
    // Ellipsis usage
    issues.push(...this.validateEllipsisUsage(text));
    
    // Square brackets for modifications
    issues.push(...this.validateSquareBrackets(text));
    
    // Quote integration
    issues.push(...this.validateQuoteIntegration(text));
    
    // Quote accuracy indicators
    issues.push(...this.validateQuoteAccuracy(text));
    
    return issues;
  }

  /**
   * Validate block quote formatting (40+ words)
   */
  validateBlockQuotes(text) {
    const issues = [];
    
    // Find all quoted text
    const quotePattern = /[""]([^""]+)[""]/g;
    const quotes = [...text.matchAll(quotePattern)];
    
    quotes.forEach(match => {
      const quoteText = match[1];
      const wordCount = quoteText.split(/\s+/).filter(w => w.length > 0).length;
      
      // Check if quote is 40+ words
      if (wordCount >= this.blockQuoteMinWords) {
        // Check if it's formatted as block quote (usually indented paragraph)
        const quotePosition = match.index;
        const beforeQuote = text.substring(Math.max(0, quotePosition - 50), quotePosition);
        const afterQuote = text.substring(quotePosition + match[0].length, Math.min(text.length, quotePosition + match[0].length + 50));

        // FIXED: Block quotes (40+ words) should NOT have quotation marks
        // If we found a 40+ word quote WITH quotation marks, it's incorrectly formatted
        if (match[0].includes('"') || match[0].includes('"') || match[0].includes('"') || match[0].includes('"')) {
          issues.push({
            title: "Long quote incorrectly formatted with quotation marks",
            description: `Quote with ${wordCount} words should be a block quote without quotation marks`,
            text: quoteText.substring(0, 50) + '...',
            severity: "Major",
            category: "quotations",
            hasFix: true,
            fixAction: "convertToBlockQuote",
            explanation: "Quotes of 40+ words should be in block format: indented 0.5\", no quotation marks"
          });
        }
        
        // Check for citation after block quote
        if (!afterQuote.match(/^\s*\([^)]+\)/)) {
          issues.push({
            title: "Block quote missing citation",
            description: "Block quote should be followed immediately by citation",
            text: quoteText.substring(0, 30) + '...',
            severity: "Major",
            category: "quotations",
            hasFix: false,
            explanation: "Place citation after final punctuation of block quote: ...end of quote. (Author, Year, p. #)"
          });
        }
      } else if (wordCount > 30 && wordCount < this.blockQuoteMinWords) {
        // Warning for quotes approaching block quote length
        issues.push({
          title: "Long inline quote",
          description: `Quote with ${wordCount} words is long for inline format`,
          text: quoteText.substring(0, 50) + '...',
          severity: "Minor",
          category: "quotations",
          hasFix: false,
          explanation: "Consider paraphrasing or using block quote format for lengthy quotes"
        });
      }
    });
    
    // Check for improperly formatted block quotes (indented but with quotes)
    const indentedQuotes = text.match(/\n\s{4,}[""].*[""]/g) || [];
    indentedQuotes.forEach(quote => {
      issues.push({
        title: "Block quote with quotation marks",
        description: "Block quotes should not have quotation marks",
        text: quote.trim().substring(0, 50),
        severity: "Major",
        category: "quotations",
        hasFix: true,
        fixAction: "removeBlockQuoteMarks",
        explanation: "Block quotes use indentation only, no quotation marks"
      });
    });

    // Also check for potential block quotes that are properly indented (40+ words without quotes)
    // This is to catch block quotes that might be correctly formatted
    const blockQuotePattern = /\n\s{4,}([^\n]{160,})/g; // 160+ chars ≈ 40+ words
    const potentialBlockQuotes = [...text.matchAll(blockQuotePattern)];

    potentialBlockQuotes.forEach(match => {
      const content = match[1];
      const wordCount = content.split(/\s+/).filter(w => w.length > 0).length;

      // If it's 40+ words and properly indented without quotes, this is likely correct
      if (wordCount >= this.blockQuoteMinWords &&
          !content.includes('"') && !content.includes('"') &&
          !content.includes('"') && !content.includes('"')) {
        // This is a properly formatted block quote - no issue needed
        // Could add positive feedback here if desired
      }
    });
    
    return issues;
  }

  /**
   * Validate ellipsis usage in quotes
   */
  validateEllipsisUsage(text) {
    const issues = [];
    
    // Find ellipses in quotes
    const quotesWithEllipsis = text.match(/[""][^""]*\.\.\.+[^""]*[""]/g) || [];
    
    quotesWithEllipsis.forEach(quote => {
      // Check for correct ellipsis format (three dots with spaces)
      const ellipsisVariants = quote.match(/\.\.+/g) || [];
      
      ellipsisVariants.forEach(ellipsis => {
        if (ellipsis !== '...' && ellipsis !== '. . .') {
          issues.push({
            title: "Incorrect ellipsis format",
            description: "Use three dots for ellipsis (...) or spaced (. . .)",
            text: quote.substring(quote.indexOf(ellipsis) - 10, quote.indexOf(ellipsis) + 20),
            severity: "Minor",
            category: "quotations",
            hasFix: true,
            fixAction: "fixEllipsisFormat",
            explanation: "Ellipsis should be exactly three dots, with or without spaces"
          });
        }
      });
      
      // Check for ellipsis at beginning (usually not needed)
      if (quote.match(/[""]\.\.\./) || quote.match(/[""]\s*\.\.\./)) {
        issues.push({
          title: "Ellipsis at quote beginning",
          description: "Ellipsis at start of quote usually unnecessary",
          text: quote.substring(0, 30),
          severity: "Minor",
          category: "quotations",
          hasFix: false,
          explanation: "Begin quotes at natural starting point without ellipsis unless showing continuation"
        });
      }
      
      // Check for four dots (period + ellipsis)
      if (quote.includes('....')) {
        issues.push({
          title: "Four dots in quote",
          description: "Use three dots for ellipsis, even at sentence end",
          text: quote.substring(quote.indexOf('....') - 10, quote.indexOf('....') + 20),
          severity: "Minor",
          category: "quotations",
          hasFix: true,
          fixAction: "fixFourDots",
          explanation: "APA 7th uses three dots only, not four dots for end of sentence"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate square bracket usage for modifications
   */
  validateSquareBrackets(text) {
    const issues = [];
    
    // Find square brackets in quotes
    const quotesWithBrackets = text.match(/[""][^""]*\[[^\]]*\][^""]*[""]/g) || [];
    
    quotesWithBrackets.forEach(quote => {
      const brackets = quote.match(/\[([^\]]*)\]/g) || [];
      
      brackets.forEach(bracket => {
        const content = bracket.slice(1, -1);
        
        // Check for [sic] usage
        if (content.toLowerCase() === 'sic') {
          // Check if [sic] is italicized (in some formats)
          const position = quote.indexOf(bracket);
          if (position > 0 && quote[position - 1] !== ' ') {
            issues.push({
              title: "Missing space before [sic]",
              description: "[sic] should have space before it",
              text: quote.substring(position - 10, position + 10),
              severity: "Minor",
              category: "quotations",
              hasFix: true,
              fixAction: "addSpaceBeforeSic",
              explanation: "Format: 'original text [sic]' with space before bracket"
            });
          }
        }
        
        // Check for clarifications
        else if (content.length > 20) {
          issues.push({
            title: "Long text in square brackets",
            description: "Keep bracketed clarifications brief",
            text: bracket,
            severity: "Minor",
            category: "quotations",
            hasFix: false,
            explanation: "Use square brackets sparingly for brief clarifications only"
          });
        }
        
        // Check for capital letter changes
        else if (content.length === 1 && /[A-Z]/.test(content)) {
          // This is likely a capitalization change, which is correct
          // No issue
        }
        
        // Check for ellipsis in brackets (should be without brackets)
        else if (content === '...') {
          issues.push({
            title: "Ellipsis in square brackets",
            description: "Ellipsis should not be in square brackets",
            text: bracket,
            severity: "Minor",
            category: "quotations",
            hasFix: true,
            fixAction: "removeEllipsisBrackets",
            explanation: "Use ... without brackets for omitted material"
          });
        }
      });
    });
    
    return issues;
  }

  /**
   * Validate quote integration (floating quotes, etc.)
   */
  validateQuoteIntegration(text) {
    const issues = [];
    
    // Check for floating quotes (quotes without introduction)
    const sentences = text.split(/[.!?]+/);
    
    sentences.forEach(sentence => {
      if (sentence.trim().startsWith('"') || sentence.trim().startsWith('"')) {
      }
    });
    
    
    return issues;
  }

  /**
   * Validate quote accuracy indicators
   */
  validateQuoteAccuracy(text) {
    const issues = [];
    
    // Check for quotes with emphasis added
    const emphasisPattern = /[""][^""]*(?:\*[^*]+\*|_[^_]+_)[^""]*[""]/g;
    const emphasisQuotes = text.match(emphasisPattern) || [];
    
    emphasisQuotes.forEach(quote => {
      // Check if "emphasis added" is noted
      const quoteEnd = text.indexOf(quote) + quote.length;
      const afterQuote = text.substring(quoteEnd, quoteEnd + 100);
      
      if (!afterQuote.includes('emphasis added') && !afterQuote.includes('[emphasis added]')) {
        issues.push({
          title: "Emphasis without attribution",
          description: "Added emphasis in quote should be noted",
          text: quote.substring(0, 50) + '...',
          severity: "Minor",
          category: "quotations",
          hasFix: true,
          fixAction: "addEmphasisNote",
          explanation: "Note added emphasis: (Author, Year, p. #, emphasis added)"
        });
      }
    });
    
    // Check for translated quotes
    const translationIndicators = ['translated from', 'trans.', 'translation', 'my translation'];
    translationIndicators.forEach(indicator => {
      if (text.includes(indicator)) {
        const position = text.indexOf(indicator);
        const context = text.substring(Math.max(0, position - 100), position + 50);
        
        if (context.includes('"') || context.includes('"')) {
          // Found a likely translated quote
          if (!context.includes('trans.') && !context.includes('translation')) {
            issues.push({
              title: "Translation not properly noted",
              description: "Translated quotes should be clearly marked",
              text: context.substring(0, 50),
              severity: "Minor",
              category: "quotations",
              hasFix: false,
              explanation: "Note translations: (Author, Year, p. #, my translation)"
            });
          }
        }
      }
    });
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\referenceValidator.js
// src/utils/referenceValidator.js - Comprehensive reference list validation
'use client';

export class ReferenceValidator {
  constructor() {
    // Enhanced DOI pattern with validation
    this.doiPattern = /(?:https?:\/\/)?(?:dx\.)?doi\.org\/([0-9.]+\/[^\s]+)|doi:\s*([0-9.]+\/[^\s]+)/i;
    this.urlPattern = /https?:\/\/[^\s)]+/g;
    // Valid DOI prefix pattern (10.xxxx)
    this.validDoiPrefix = /^10\.\d{4,}/;
  }

  /**
   * Main validation function for references section with deep formatting
   */
  validateReferences(text, structure, italicizedText = []) {
    const issues = [];

    if (!text) return issues;

    // Extract references section
    const referencesMatch = text.match(/(?:^|\n)(?:references|REFERENCES|References)\s*\n([\s\S]*?)(?=\n(?:appendix|APPENDIX|Appendix)|$)/i);

    if (!referencesMatch) {
      // Check if there are citations that need references
      const hasCitations = /\([^)]+,\s*\d{4}\)/.test(text);
      if (hasCitations) {
        issues.push({
          title: "Missing references section",
          description: "Document contains citations but no references section",
          severity: "Critical",
          category: "references",
          hasFix: false,
          explanation: "All cited sources must be listed in the References section at the end of the document."
        });
      }
      return issues;
    }

    const referencesText = referencesMatch[1].trim();

    // Check for empty references section
    if (referencesText.length < 50 || !referencesText.match(/[A-Z]/)) {
      issues.push({
        title: "Empty references section",
        description: "References section exists but contains no entries",
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "The References section must contain full citations for all sources cited in the text."
      });
      return issues;
    }

    // Use DocumentModel's paragraph map if available (most accurate)
    // Otherwise fall back to text splitting (less accurate due to empty line handling)
    let paragraphMap;

    if (structure?.paragraphMap && Array.isArray(structure.paragraphMap)) {
      paragraphMap = structure.paragraphMap;
    } else {
      // Fallback: Build paragraph map from text splitting
      paragraphMap = [];
      let charOffset = 0;

      text.split('\n').forEach((paraText) => {
        if (paraText.trim()) { // Only non-empty paragraphs (matches DocumentModel.getPlainText filter)
          paragraphMap.push({
            index: paragraphMap.length,
            text: paraText,
            charStart: charOffset,
            charEnd: charOffset + paraText.length
          });
        }
        charOffset += paraText.length + 1; // +1 for newline
      });
    }

    // Parse individual references with paragraph mapping
    const referenceEntries = this.parseReferenceEntries(referencesText, text, paragraphMap);

    // Run all validation checks including deep formatting with italicized text
    issues.push(...this.checkAlphabeticalOrder(referenceEntries));
    issues.push(...this.checkHangingIndent(referenceEntries, referencesText));
    issues.push(...this.checkReferenceFormatting(referenceEntries, italicizedText));
    issues.push(...this.crossCheckCitationsAndReferences(text, referenceEntries));
    issues.push(...this.checkDuplicateReferences(referenceEntries));
    issues.push(...this.checkDOIAndURLFormatting(referenceEntries));

    return issues;
  }

  /**
   * Parse reference entries from text with accurate paragraph index mapping
   */
  parseReferenceEntries(referencesText, fullText, paragraphMap) {
    const entries = [];
    const lines = referencesText.split('\n');
    let currentEntry = '';
    let entryStartLine = 0;

    // Helper function to find paragraph index for entry text using paragraph map
    const findParagraphIndex = (entryText) => {
      // Search for the first 50 characters of the entry to find which paragraph contains it
      const searchText = entryText.substring(0, Math.min(50, entryText.length));

      for (let i = 0; i < paragraphMap.length; i++) {
        if (paragraphMap[i].text.includes(searchText)) {
          return paragraphMap[i].index;
        }
      }

      // Fallback: search by character position in full text (if charStart/charEnd available)
      const entryIndex = fullText.indexOf(entryText.substring(0, 30));
      if (entryIndex !== -1) {
        // Find which paragraph this character position falls into
        for (let i = 0; i < paragraphMap.length; i++) {
          if (paragraphMap[i].charStart !== undefined &&
              paragraphMap[i].charEnd !== undefined &&
              entryIndex >= paragraphMap[i].charStart &&
              entryIndex <= paragraphMap[i].charEnd) {
            return paragraphMap[i].index;
          }
        }
      }

      return null;
    };

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();

      // Check if this is a new reference entry (starts with capital letter, previous entry has year)
      const isNewEntry = trimmedLine.length > 0 &&
                         /^[A-Z]/.test(trimmedLine) &&
                         currentEntry.includes('(') &&
                         currentEntry.includes(')');

      if (trimmedLine.length === 0 || isNewEntry) {
        if (currentEntry.trim().length > 10) {
          const entryText = currentEntry.trim();
          const paragraphIndex = findParagraphIndex(entryText);

          const entry = {
            text: entryText,
            firstAuthor: this.extractFirstAuthor(currentEntry),
            year: this.extractYear(currentEntry),
            hasMultipleAuthors: this.hasMultipleAuthors(currentEntry),
            type: this.detectReferenceType(currentEntry),
            lineNumber: entryStartLine,
            paragraphIndex: paragraphIndex,
            indentation: this.checkIndentation(currentEntry, lines.slice(entryStartLine, i))
          };

          entries.push(entry);
        }

        if (isNewEntry) {
          currentEntry = trimmedLine;
          entryStartLine = i;
        } else {
          currentEntry = '';
        }
      } else if (trimmedLine.length > 0) {
        currentEntry += (currentEntry ? ' ' : '') + trimmedLine;
      }
    }

    // Add last entry
    if (currentEntry.trim().length > 10) {
      const entryText = currentEntry.trim();
      const paragraphIndex = findParagraphIndex(entryText);

      const entry = {
        text: entryText,
        firstAuthor: this.extractFirstAuthor(currentEntry),
        year: this.extractYear(currentEntry),
        hasMultipleAuthors: this.hasMultipleAuthors(currentEntry),
        type: this.detectReferenceType(currentEntry),
        lineNumber: entryStartLine,
        paragraphIndex: paragraphIndex,
        indentation: this.checkIndentation(currentEntry, lines.slice(entryStartLine))
      };

      entries.push(entry);
    }

    return entries;
  }

  /**
   * Extract first author's surname from reference
   */
  extractFirstAuthor(reference) {
    // Match pattern: Surname, F. M. or Surname, First Middle
    const match = reference.match(/^([A-Z][a-zA-Z'-]+(?:\s+[A-Z][a-zA-Z'-]+)?),/);
    return match ? match[1] : '';
  }

  /**
   * Extract year from reference
   */
  extractYear(reference) {
    // Match (YYYY) or (YYYY, Month) or (n.d.)
    const match = reference.match(/\((\d{4}[a-z]?|n\.d\.)[^)]*\)/);
    return match ? match[1] : '';
  }

  /**
   * Check if reference has multiple authors
   */
  hasMultipleAuthors(reference) {
    return reference.includes('&') || reference.includes(', &') || 
           reference.split(',').length > 3;
  }

  /**
   * Detect reference type (journal, book, website, etc.)
   */
  detectReferenceType(reference) {
    if (reference.match(/\d+\(\d+\),?\s*\d+-\d+/)) return 'journal';
    if (reference.includes('http') || reference.includes('doi')) return 'online';
    if (reference.match(/\([^)]*Ed(?:s)?\.\)/)) return 'book';
    if (reference.includes('In ')) return 'chapter';
    return 'other';
  }

  /**
   * Check indentation of reference entry
   */
  checkIndentation(entry, lines) {
    if (lines.length <= 1) return 'single-line';
    
    // Check if second line has more indentation than first
    const firstLineIndent = lines[0].match(/^(\s*)/)[1].length;
    const secondLineIndent = lines[1] ? lines[1].match(/^(\s*)/)[1].length : 0;
    
    return secondLineIndent > firstLineIndent ? 'hanging' : 'no-hanging';
  }

  /**
   * Check alphabetical order
   */
  checkAlphabeticalOrder(entries) {
    const issues = [];
    if (entries.length < 2) return issues;
    
    for (let i = 1; i < entries.length; i++) {
      const current = entries[i].firstAuthor.toLowerCase();
      const previous = entries[i-1].firstAuthor.toLowerCase();
      
      if (current && previous && current < previous) {
        // Check for same author, different years
        const currentBase = current.replace(/[a-z]$/, '');
        const previousBase = previous.replace(/[a-z]$/, '');
        
        if (currentBase !== previousBase) {
          issues.push({
            title: "References not in alphabetical order",
            description: `"${entries[i].firstAuthor}" should come before "${entries[i-1].firstAuthor}"`,
            text: `${entries[i].firstAuthor} (${entries[i].year})`,
            severity: "Major",
            category: "references",
            hasFix: true,
            fixAction: "sortReferences",
            explanation: "References must be listed in alphabetical order by the first author's surname."
          });
          break; // Only report first occurrence
        }
      }
      
      // Check same author, year order
      if (current === previous && entries[i].year && entries[i-1].year) {
        const currentYear = entries[i].year;
        const previousYear = entries[i-1].year;
        
        if (currentYear < previousYear && !currentYear.includes('n.d.')) {
          issues.push({
            title: "Same author references not in chronological order",
            description: `${entries[i].firstAuthor}'s works should be ordered by year`,
            text: `${previousYear} comes before ${currentYear}`,
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "sortReferencesByYear",
            explanation: "When the same author has multiple works, order them chronologically (oldest first)."
          });
        }
      }
    }
    
    return issues;
  }

  /**
   * Check hanging indent
   */
  checkHangingIndent(entries, referencesText) {
    const issues = [];
    let noHangingCount = 0;
    
    entries.forEach((entry) => {
      if (entry.indentation === 'no-hanging' && entry.text.length > 80) {
        noHangingCount++;
      }
    });
    
    if (noHangingCount > entries.length * 0.3) { // If >30% lack hanging indent
      issues.push({
        title: "Missing hanging indent in references",
        description: "Reference entries should have 0.5\" hanging indent for lines after the first",
        text: `${noHangingCount} of ${entries.length} references lack proper indentation`,
        severity: "Minor",
        category: "references",
        hasFix: true,
        fixAction: "fixReferenceIndent",
        explanation: "Each reference entry should have a hanging indent of 0.5 inches for continuation lines."
      });
    }
    
    return issues;
  }

  /**
   * Enhanced deep reference formatting validation
   */
  checkReferenceFormatting(entries, italicizedText) {
    const issues = [];
    const reportedTypes = new Set();

    entries.forEach((entry, index) => {
      // Deep validation of author format
      const authorIssues = this.validateAuthorFormat(entry);
      if (authorIssues && !reportedTypes.has('author-format')) {
        issues.push(authorIssues);
        reportedTypes.add('author-format');
      }

      // Check for missing year
      if (!entry.year && !reportedTypes.has('year')) {
        issues.push({
          title: "Missing year in reference",
          description: "Reference entry missing publication year",
          text: entry.text.substring(0, 60) + '...',
          severity: "Major",
          category: "references",
          hasFix: false,
          explanation: "All references must include the publication year in parentheses after the author(s)."
        });
        reportedTypes.add('year');
      }

      // Deep validation based on reference type
      const typeSpecificIssues = this.validateReferenceByType(entry, italicizedText);
      typeSpecificIssues.forEach(issue => {
        if (!reportedTypes.has(issue.type)) {
          issues.push(issue);
          reportedTypes.add(issue.type);
        }
      });

      // Check for missing DOI/URL in journal articles
      if (entry.type === 'journal' &&
          !entry.text.match(/(?:https?:\/\/|doi:|DOI:)/) &&
          !reportedTypes.has('doi')) {
        issues.push({
          title: "Missing DOI or URL in journal article",
          description: "Journal articles should include DOI or stable URL",
          text: entry.text.substring(0, 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: false,
          explanation: "Include DOI (preferred) or stable URL for all journal articles when available."
        });
        reportedTypes.add('doi');
      }

      // Check for "and" instead of "&"
      if (entry.hasMultipleAuthors && entry.text.includes(', and ')) {
        issues.push({
          title: "Incorrect connector in reference",
          description: "Use '&' instead of 'and' between authors",
          text: entry.text.substring(0, 60) + '...',
          highlightText: entry.text, // Full text for search fallback
          severity: "Minor",
          category: "references",
          location: {
            paragraphIndex: entry.paragraphIndex, // Use entry's paragraph index
            charOffset: 0,
            length: entry.text.length,
            type: 'text'
          },
          hasFix: true,
          fixAction: "fixReferenceConnector",
          fixValue: {
            original: entry.text,
            replacement: entry.text.replace(', and ', ', & ')
          },
          explanation: "In reference lists, use & (ampersand) to connect the last two author names."
        });
      }
      
      // Check for consistent punctuation
      if (!entry.text.endsWith('.') && !entry.text.match(/\)\.?$/) && !reportedTypes.has('period')) {
        issues.push({
          title: "Missing period at end of reference",
          description: "References should end with a period",
          text: entry.text.substring(entry.text.length - 30),
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "addReferencePeriod",
          explanation: "Each reference entry must end with a period."
        });
        reportedTypes.add('period');
      }
    });
    
    return issues;
  }

  /**
   * Cross-check citations with references
   */
  crossCheckCitationsAndReferences(text, referenceEntries) {
    const issues = [];
    
    // Split text into paragraphs for position tracking
    const paragraphs = text.split('\n');
    const referencesStartIndex = paragraphs.findIndex(p => /^references/i.test(p.trim()));
    
    // Extract all in-text citations
    const citationPattern = /\(([A-Za-z][A-Za-z\s&.,'-]+?)(?:,?\s+et\s+al\.)?(?:,\s+)?(\d{4}[a-z]?|n\.d\.)\)/g;
    const citations = new Map();
    let match;
    
    while ((match = citationPattern.exec(text)) !== null) {
      const author = match[1].trim().replace(/,$/, '').split(/\s+&\s+|\s+and\s+/)[0];
      const year = match[2];
      const key = `${author.toLowerCase()}_${year}`;
      
      if (!citations.has(key)) {
        citations.set(key, { author, year, full: match[0], count: 1 });
      } else {
        citations.get(key).count++;
      }
    }
    
    // Create reference map
    const references = new Map();
    referenceEntries.forEach(ref => {
      if (ref.firstAuthor && ref.year) {
        const key = `${ref.firstAuthor.toLowerCase()}_${ref.year}`;
        references.set(key, ref);
      }
    });
    
    // Find citations without references
    const missingRefs = [];
    citations.forEach((citation, key) => {
      // Try exact match first
      if (!references.has(key)) {
        // Try fuzzy match (first 3 letters)
        const authorStart = citation.author.toLowerCase().substring(0, 3);
        const found = Array.from(references.keys()).some(refKey => 
          refKey.startsWith(authorStart) && refKey.includes(citation.year)
        );
        
        if (!found) {
          missingRefs.push(citation);
        }
      }
    });
    
    // Report missing references (max 3)
    missingRefs.slice(0, 3).forEach(citation => {
      issues.push({
        title: "Citation without reference",
        description: `Citation "${citation.full}" not found in references`,
        text: citation.full,
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "Every in-text citation must have a corresponding entry in the References section."
      });
    });
    
    // Find orphaned references
    const orphanedRefs = [];
    references.forEach((ref, key) => {
      const authorPart = key.split('_')[0];
      const yearPart = key.split('_')[1];
      
      // Check if this reference is cited
      const found = Array.from(citations.keys()).some(citKey => {
        const citAuthor = citKey.split('_')[0];
        const citYear = citKey.split('_')[1];
        return citAuthor.startsWith(authorPart.substring(0, 3)) && citYear === yearPart;
      });
      
      if (!found) {
        orphanedRefs.push(ref);
      }
    });
    
    // Report orphaned references (max 3) with position tracking
    orphanedRefs.slice(0, 3).forEach(ref => {
      // Find the paragraph containing this reference
      let paragraphIndex = -1;
      let charOffset = 0;
      
      if (referencesStartIndex >= 0) {
        for (let i = referencesStartIndex; i < paragraphs.length; i++) {
          const para = paragraphs[i];
          if (para.includes(ref.firstAuthor) && para.includes(ref.year)) {
            paragraphIndex = i;
            charOffset = para.indexOf(ref.firstAuthor);
            break;
          }
        }
      }
      
      // If we couldn't find it in paragraphs, search in the full reference text
      if (paragraphIndex === -1) {
        const refIndex = text.indexOf(ref.text);
        if (refIndex !== -1) {
          // Count newlines before this position to get paragraph index
          const textBefore = text.substring(0, refIndex);
          paragraphIndex = (textBefore.match(/\n/g) || []).length;
          // Get offset within the paragraph
          const lastNewline = textBefore.lastIndexOf('\n');
          charOffset = refIndex - lastNewline - 1;
        }
      }
      
      issues.push({
        title: "Orphaned reference",
        description: `Reference for ${ref.firstAuthor} (${ref.year}) not cited in text`,
        text: ref.text.substring(0, 60) + '...',
        highlightText: ref.text.substring(0, 100), // More text for better matching
        severity: "Major",
        category: "references",
        location: {
          paragraphIndex: paragraphIndex >= 0 ? paragraphIndex : null,
          charOffset: charOffset >= 0 ? charOffset : 0,
          length: Math.min(100, ref.text.length),
          type: 'text'
        },
        hasFix: false,
        explanation: "Only include references that are cited in the document text."
      });
    });
    
    return issues;
  }

  /**
   * Check for duplicate references
   */
  checkDuplicateReferences(entries) {
    const issues = [];
    const seen = new Map();
    
    entries.forEach(entry => {
      const key = `${entry.firstAuthor}_${entry.year}`.toLowerCase();
      
      if (key && entry.firstAuthor && entry.year) {
        if (seen.has(key)) {
          const existing = seen.get(key);
          
          // Check if texts are actually different (not just formatting)
          const normalizedCurrent = entry.text.replace(/\s+/g, ' ').toLowerCase();
          const normalizedExisting = existing.text.replace(/\s+/g, ' ').toLowerCase();
          
          if (normalizedCurrent !== normalizedExisting) {
            issues.push({
              title: "Possible duplicate reference",
              description: `Multiple references for ${entry.firstAuthor} (${entry.year})`,
              text: entry.text.substring(0, 60) + '...',
              severity: "Major",
              category: "references",
              hasFix: false,
              explanation: "Each source should appear only once. Use 'a', 'b' suffixes for multiple works by same author in same year."
            });
          }
        } else {
          seen.set(key, entry);
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate author format in references
   */
  validateAuthorFormat(entry) {
    const text = entry.text;
    
    // Check for proper author format: Lastname, F. M.
    const authorPattern = /^([A-Z][a-zA-Z'-]+),\s+([A-Z]\.(?:\s*[A-Z]\.)*)/;
    
    if (!authorPattern.test(text)) {
      // Check for common formatting errors
      
      // Missing initials
      if (/^[A-Z][a-zA-Z'-]+,\s+[A-Z][a-z]+/.test(text)) {
        return {
          title: "Full first names instead of initials",
          description: "Use initials instead of full first names in references",
          text: text.substring(0, 50) + '...',
          severity: "Major",
          category: "references",
          hasFix: false,
          type: 'author-format',
          explanation: "Author names should use initials: Smith, J. D., not Smith, John David."
        };
      }
      
      // Missing comma after surname
      if (/^[A-Z][a-zA-Z'-]+\s+[A-Z]\./.test(text)) {
        return {
          title: "Missing comma after author surname",
          description: "Author surname should be followed by a comma",
          text: text.substring(0, 50) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixAuthorComma",
          type: 'author-format',
          explanation: "Format: Lastname, F. M., not Lastname F. M."
        };
      }
      
      // Missing periods after initials
      if (/^[A-Z][a-zA-Z'-]+,\s+[A-Z]\s+[A-Z]/.test(text)) {
        return {
          title: "Missing periods after author initials",
          description: "Each initial should be followed by a period",
          text: text.substring(0, 50) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixAuthorInitials",
          type: 'author-format',
          explanation: "Format: Smith, J. D., not Smith, J D"
        };
      }
    }
    
    // Check for up to 20 authors rule (APA 7th)
    const authorCount = (text.match(/[A-Z][a-zA-Z'-]+,\s+[A-Z]\./g) || []).length;
    if (authorCount > 20) {
      return {
        title: "Too many authors listed",
        description: "List first 19 authors, then ... and the last author",
        text: text.substring(0, 50) + '...',
        severity: "Minor",
        category: "references",
        hasFix: false,
        type: 'author-format',
        explanation: "For 21+ authors: list first 19, then ellipsis (...), then final author."
      };
    }
    
    return null;
  }
  
  /**
   * Validate reference by type with deep formatting checks
   */
  validateReferenceByType(entry, italicizedText = []) {
    const issues = [];
    const text = entry.text;
    
    if (entry.type === 'journal') {
      // Journal article specific validation
      
      // Check for journal name italicization
      const journalMatch = text.match(/\)\.\s+([^,]+),\s*\d+/);
      if (journalMatch) {
        const journalName = journalMatch[1];
        const isItalicized = italicizedText?.some(item => 
          item.text.includes(journalName) || journalName.includes(item.text)
        );
        
        if (!isItalicized && journalName.length > 3) {
          issues.push({
            title: "Journal name not italicized",
            description: "Journal names must be italicized in references",
            text: journalName,
            severity: "Major",
            category: "references",
            hasFix: false,
            type: 'journal-italics',
            explanation: "Journal titles should be in italics: Journal of Psychology, not Journal of Psychology"
          });
        }
      }
      
      // Check for volume number italicization
      const volumeMatch = text.match(/,\s*(\d+)(?:\(|,)/);
      if (volumeMatch) {
        const volume = volumeMatch[1];
        const volumeContext = text.substring(
          text.indexOf(volume) - 10, 
          text.indexOf(volume) + volume.length + 10
        );
        
        const volumeItalicized = italicizedText?.some(item => 
          item.text.includes(volume) && item.context?.includes(journalMatch?.[1])
        );
        
        if (!volumeItalicized) {
          issues.push({
            title: "Volume number not italicized",
            description: "Journal volume numbers should be italicized",
            text: volumeContext,
            severity: "Minor",
            category: "references",
            hasFix: false,
            type: 'volume-italics',
            explanation: "Volume numbers should be italicized: Psychology Today, 45(3), not Psychology Today, 45(3)"
          });
        }
      }
      
      // Check for issue number format
      const issueMatch = text.match(/\d+\((\d+)\)/);
      if (issueMatch) {
        const issueContext = text.substring(
          text.indexOf(issueMatch[0]) - 5,
          text.indexOf(issueMatch[0]) + issueMatch[0].length + 5
        );
        
        // Issue number should NOT be italicized
        const issueItalicized = italicizedText?.some(item => 
          item.text.includes(`(${issueMatch[1]})`)
        );
        
        if (issueItalicized) {
          issues.push({
            title: "Issue number incorrectly italicized",
            description: "Issue numbers in parentheses should not be italicized",
            text: issueContext,
            severity: "Minor",
            category: "references",
            hasFix: false,
            type: 'issue-italics',
            explanation: "Only volume is italicized, not issue: 45(3), where 45 is italic but (3) is not"
          });
        }
      }
      
      // Check page range format
      const pageMatch = text.match(/,\s*(\d+)[–-](\d+)/);
      if (pageMatch) {
        // Check for en dash vs hyphen
        if (text.includes(`${pageMatch[1]}-${pageMatch[2]}`)) {
          issues.push({
            title: "Hyphen instead of en dash in page range",
            description: "Use en dash (–) not hyphen (-) for page ranges",
            text: `${pageMatch[1]}-${pageMatch[2]}`,
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "fixPageRangeDash",
            type: 'page-dash',
            explanation: "Page ranges use en dash: 123–456, not 123-456"
          });
        }
      }
      
    } else if (entry.type === 'book') {
      // Book specific validation
      
      // Check for book title italicization
      const titleMatch = text.match(/\)\.\s+([^.]+)\./);
      if (titleMatch) {
        const bookTitle = titleMatch[1];
        const isItalicized = italicizedText?.some(item => 
          item.text.includes(bookTitle) || bookTitle.includes(item.text)
        );
        
        if (!isItalicized && bookTitle.length > 3) {
          issues.push({
            title: "Book title not italicized",
            description: "Book titles must be italicized in references",
            text: bookTitle.substring(0, 50),
            severity: "Major",
            category: "references",
            hasFix: false,
            type: 'book-italics',
            explanation: "Book titles should be in italics throughout the reference"
          });
        }
        
        // Check for sentence case in book titles
        const words = bookTitle.split(/\s+/);
        const hasExcessiveCapitals = words.filter(w => 
          w.length > 3 && w[0] === w[0].toUpperCase()
        ).length > words.length * 0.5;
        
        if (hasExcessiveCapitals) {
          issues.push({
            title: "Book title not in sentence case",
            description: "Book titles should use sentence case, not title case",
            text: bookTitle.substring(0, 50),
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "fixBookTitleCase",
            type: 'book-case',
            explanation: "Book titles use sentence case: 'The psychology of learning' not 'The Psychology of Learning'"
          });
        }
      }
      
      // Check for edition format
      const editionMatch = text.match(/\((\d+)(?:st|nd|rd|th)\s+[Ee]d(?:ition)?\)/);
      if (editionMatch) {
        if (!text.includes(`(${editionMatch[1]}th ed.)`) && 
            !text.includes(`(${editionMatch[1]}nd ed.)`) &&
            !text.includes(`(${editionMatch[1]}rd ed.)`) &&
            !text.includes(`(${editionMatch[1]}st ed.)`)) {
          issues.push({
            title: "Incorrect edition format",
            description: "Edition should be formatted as '(2nd ed.)'",
            text: editionMatch[0],
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "fixEditionFormat",
            type: 'edition-format',
            explanation: "Format editions as: (2nd ed.), (3rd ed.), etc."
          });
        }
      }
      
      // Check for publisher location (not needed in APA 7th)
      if (text.match(/[A-Z][a-z]+,\s+[A-Z]{2}:\s+[A-Z]/) || 
          text.includes('New York:') || 
          text.includes('London:')) {
        issues.push({
          title: "Publisher location included",
          description: "APA 7th edition no longer requires publisher location",
          text: text.substring(0, 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "removePublisherLocation",
          type: 'publisher-location',
          explanation: "APA 7th edition omits publisher location. Use just publisher name."
        });
      }
    }
    
    return issues;
  }

  /**
   * Check DOI and URL formatting
   */
  checkDOIAndURLFormatting(entries) {
    const issues = [];
    const reportedTypes = new Set();
    
    entries.forEach(entry => {
      // Check for "Retrieved from" (outdated in APA 7)
      if (entry.text.includes('Retrieved from') && !reportedTypes.has('retrieved')) {
        issues.push({
          title: "Outdated 'Retrieved from' phrase",
          description: "APA 7th edition no longer uses 'Retrieved from' before URLs",
          text: entry.text.substring(entry.text.indexOf('Retrieved'), 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "removeRetrievedFrom",
          explanation: "APA 7th edition omits 'Retrieved from' before URLs unless a retrieval date is needed."
        });
        reportedTypes.add('retrieved');
      }
      
      // Check DOI format and validity
      const doiMatch = entry.text.match(this.doiPattern);
      if (doiMatch) {
        const doi = doiMatch[1] || doiMatch[2];
        
        // Validate DOI structure
        if (doi && !this.validDoiPrefix.test(doi) && !reportedTypes.has('invalid-doi')) {
          issues.push({
            title: "Invalid DOI format",
            description: "DOI appears malformed",
            text: doiMatch[0],
            severity: "Major",
            category: "references",
            hasFix: false,
            explanation: "DOIs should start with '10.' followed by a registrant code"
          });
          reportedTypes.add('invalid-doi');
        }
        
        // FIXED: Check if formatted properly - APA 7th allows both formats
        const hasHyperlinkFormat = entry.text.includes('https://doi.org/');
        const hasPlainFormat = entry.text.match(/doi:\s*10\./i);

        if (!hasHyperlinkFormat && !hasPlainFormat && !reportedTypes.has('doi-format')) {
          issues.push({
            title: "DOI format issue",
            description: "DOI should be formatted as hyperlink or plain DOI",
            text: doiMatch[0],
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "formatDOI",
            explanation: "Format DOIs as: https://doi.org/10.xxxx/xxxxx (preferred) or doi:10.xxxx/xxxxx (acceptable)"
          });
          reportedTypes.add('doi-format');
        }
      }
      
      // Check for electronic sources without retrieval date when needed
      if (entry.text.includes('http') && !entry.text.includes('doi') && 
          !reportedTypes.has('retrieval-date')) {
        // Check if it's a source that changes (wiki, news, etc.)
        const needsRetrievalDate = /wikipedia|wiki|news|blog|press release/i.test(entry.text);
        if (needsRetrievalDate && !entry.text.includes('Retrieved')) {
          issues.push({
            title: "Missing retrieval date",
            description: "Online sources that change need retrieval dates",
            text: entry.text.substring(0, 60) + '...',
            severity: "Minor",
            category: "references",
            hasFix: false,
            explanation: "Add 'Retrieved [Month Day, Year], from' before URL for changing content"
          });
          reportedTypes.add('retrieval-date');
        }
      }
    });
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\statisticalValidator.js
// src/utils/statisticalValidator.js - Statistical and numerical formatting validation
'use client';

export class StatisticalValidator {
  constructor() {
    this.statisticalSymbols = {
      p: 'probability',
      t: 't test',
      F: 'F test',
      r: 'correlation',
      R: 'multiple correlation',
      n: 'sample size',
      N: 'total sample',
      M: 'mean',
      SD: 'standard deviation',
      SE: 'standard error',
      df: 'degrees of freedom',
      χ2: 'chi-square',
      α: 'alpha',
      β: 'beta',
      η: 'eta',
      ω: 'omega'
    };
  }

  /**
   * Validate statistical and numerical formatting
   */
  validateStatistical(text, structure) {
    const issues = [];
    
    // Statistical notation italicization
    issues.push(...this.validateStatisticalItalics(text, structure));
    
    // Decimal places consistency
    issues.push(...this.validateDecimalPlaces(text));
    
    // Number presentation rules
    issues.push(...this.validateNumberPresentation(text));
    
    // Percentage formatting
    issues.push(...this.validatePercentageFormat(text));
    
    // Statistical results reporting
    issues.push(...this.validateStatisticalReporting(text));
    
    // Mathematical operators spacing
    issues.push(...this.validateMathOperators(text));
    
    return issues;
  }

  /**
   * Validate statistical notation italicization
   */
  validateStatisticalItalics(text, structure) {
    const issues = [];
    const italicizedText = structure?.italicizedText || [];
    
    // Check for statistical symbols that should be italicized - with improved context awareness
    const reportedSymbols = new Set();
    
    Object.entries(this.statisticalSymbols).forEach(([symbol, name]) => {
      // Skip if already reported
      if (reportedSymbols.has(symbol)) return;
      
      // Skip uppercase letters that might be regular text
      if (symbol.length === 1 && /[A-Z]/.test(symbol)) {
        // Look for clear statistical context with more specific patterns
        const statPatterns = [
          new RegExp(`\\b${symbol}\\s*[=<>≤≥]\\s*[\\d.-]+`, 'g'), // With value
          new RegExp(`\\(${symbol}\\s*[=<>≤≥]\\s*[\\d.-]+\\)`, 'g'), // In parentheses
          new RegExp(`\\b${symbol}\\s*\\([\\d,\\s]+\\)\\s*[=<>≤≥]`, 'g'), // With df like F(2, 147)
          new RegExp(`\\b${symbol}\\s+test\\b`, 'gi'), // Explicitly named test
          new RegExp(`\\btest.*\\b${symbol}\\s*[=<>≤≥]`, 'gi') // Test statistic
        ];
        
        let foundStatistical = false;
        for (const statPattern of statPatterns) {
          const matches = text.match(statPattern) || [];
          if (matches.length > 0) {
            foundStatistical = true;
            const match = matches[0];
            const isItalicized = italicizedText.some(item => item.text.includes(symbol));
            if (!isItalicized) {
              issues.push({
                title: `Statistical symbol '${symbol}' not italicized`,
                description: `'${symbol}' should be italicized when used as ${name}`,
                text: match,
                severity: "Minor",
                category: "statistical",
                hasFix: false,
                explanation: `Statistical symbols like ${symbol} must be italicized: *${symbol}* = value`
              });
              reportedSymbols.add(symbol);
              break;
            }
          }
        }
      } else {
        // For lowercase letters and multi-character symbols (more strict matching)
        const statContextPatterns = [
          new RegExp(`\\b${symbol}\\s*[=<>≤≥]\\s*[\\d.-]+`, 'g'),
          new RegExp(`\\(${symbol}\\s*[=<>≤≥]\\s*[\\d.-]+\\)`, 'g'),
          new RegExp(`\\b${symbol}\\s*\\([\\d,\\s]+\\)`, 'g')
        ];
        
        for (const pattern of statContextPatterns) {
          const matches = text.match(pattern) || [];
          if (matches.length > 0) {
            const match = matches[0];
            const isItalicized = italicizedText.some(item => item.text.includes(symbol));
            if (!isItalicized && !reportedSymbols.has(symbol)) {
              issues.push({
                title: `Statistical symbol '${symbol}' not italicized`,
                description: `'${symbol}' should be italicized in statistical context`,
                text: match,
                severity: "Minor",
                category: "statistical",
                hasFix: false,
                explanation: `Italicize statistical notation: *${symbol}*`
              });
              reportedSymbols.add(symbol);
              break;
            }
          }
        }
      }
    });
    
    return issues.slice(0, 5); // Limit to avoid overwhelming
  }

  /**
   * Validate decimal places consistency
   */
  validateDecimalPlaces(text) {
    const issues = [];
    
    // Find all decimal numbers
    const decimalPattern = /\b\d+\.\d+\b/g;
    const decimals = text.match(decimalPattern) || [];
    
    // Group by context (p-values, correlations, means, etc.)
    const pValues = decimals.filter(d => {
      const pos = text.indexOf(d);
      return text.substring(Math.max(0, pos - 10), pos).includes('p');
    });
    
    const correlations = decimals.filter(d => {
      const pos = text.indexOf(d);
      const context = text.substring(Math.max(0, pos - 10), pos);
      return context.includes('r') || context.includes('R');
    });
    
    // Check p-value formatting
    pValues.forEach(pValue => {
      const value = parseFloat(pValue);
      const decimalPlaces = pValue.split('.')[1].length;

      // p-values should have 2-3 decimal places
      if (decimalPlaces > 3 || decimalPlaces < 2) {
        issues.push({
          title: "Inconsistent p-value decimal places",
          description: `p-value '${pValue}' should have 2-3 decimal places`,
          text: `p = ${pValue}`,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "fixPValueDecimals",
          explanation: "Report p-values to 2-3 decimal places: p = .045 or p = .001"
        });
      }

      // FIXED: Check for leading zero - p-values CANNOT exceed 1.0, so no leading zero
      if (value < 1 && pValue.startsWith('0.')) {
        issues.push({
          title: "Leading zero in p-value",
          description: "Omit leading zero for p-values (cannot exceed 1)",
          text: `p = ${pValue}`,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "removeLeadingZero",
          explanation: "Use p = .05 not p = 0.05 (p-values cannot exceed 1.0)"
        });
      }
    });
    
    // Check correlation formatting
    correlations.forEach(correlation => {
      const value = parseFloat(correlation);

      // FIXED: Correlations CANNOT exceed 1.0 (range is -1.0 to +1.0), so no leading zero
      if (Math.abs(value) <= 1 && correlation.startsWith('0.')) {
        issues.push({
          title: "Leading zero in correlation",
          description: "Omit leading zero for correlations (cannot exceed 1.0)",
          text: `r = ${correlation}`,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "removeLeadingZero",
          explanation: "Use r = .45 not r = 0.45 (correlations range from -1.0 to 1.0)"
        });
      }
    });

    // NEW: Check for values that SHOULD have leading zeros (can exceed 1.0)
    // Examples: measurements, ages, test scores, effect sizes like Cohen's d
    const measurementPattern = /(?:age|weight|height|score|time|distance|Cohen's d|effect size|mean|M|SD|SE)\s*[=:]\s*(\.\d+)/gi;
    const measurementMatches = [...text.matchAll(measurementPattern)];

    measurementMatches.forEach(match => {
      const value = match[1]; // e.g., ".75" from "age = .75"
      const measurementType = match[0].split(/[=:]/)[0].trim();

      // These values CAN exceed 1.0, so they should have leading zeros
      issues.push({
        title: "Missing leading zero for measurement",
        description: `${measurementType} should have leading zero (can exceed 1.0)`,
        text: match[0],
        severity: "Minor",
        category: "statistical",
        hasFix: true,
        fixAction: "addLeadingZero",
        explanation: `Use ${measurementType} = 0${value} not ${measurementType} = ${value} (measurements can exceed 1.0)`
      });
    });

    return issues.slice(0, 5); // Limit to avoid overwhelming
  }

  /**
   * Validate number presentation rules (spell out below 10)
   */
  validateNumberPresentation(text) {
    const issues = [];
    
    // Find numbers at beginning of sentences with position tracking
    const paragraphs = text.split('\n');
    paragraphs.forEach((para, paraIndex) => {
      const sentenceStartPattern = /(?:^|\. )(\d+)/g;
      let match;
      
      while ((match = sentenceStartPattern.exec(para)) !== null) {
        const fullMatch = match[0];
        const number = match[1];
        const charOffset = match.index;
        
        // Get more context for highlighting
        const contextEnd = Math.min(charOffset + 50, para.length);
        const contextText = para.substring(charOffset, contextEnd);
        
        issues.push({
          title: "Number at sentence beginning",
          description: "Spell out numbers that begin sentences",
          text: fullMatch.trim() + '...',
          highlightText: contextText,
          severity: "Major",
          category: "statistical",
          location: {
            paragraphIndex: paraIndex,
            charOffset: charOffset,
            length: Math.min(50, contextText.length),
            type: 'text'
          },
          hasFix: false,
          explanation: `Write "Twenty-three participants..." not "${number} participants..."`
        });
      }
    });
    
    // Find single digit numbers (1-9) that should be spelled out
    const singleDigits = text.match(/\b[1-9]\b/g) || [];
    const reportedSingleDigit = false;
    
    singleDigits.forEach(digit => {
      if (reportedSingleDigit) return;
      
      const position = text.indexOf(digit);
      const context = text.substring(Math.max(0, position - 30), position + 30);
      
      // Check if it's in a measurement, age, time, etc. (where digits are OK)
      const isException = context.match(/\d+\s*(years?|months?|days?|hours?|minutes?|%)/) ||
                         context.match(/[Ff]igure\s+\d/) ||
                         context.match(/[Tt]able\s+\d/) ||
                         context.match(/[Pp]age\s+\d/) ||
                         context.match(/[Cc]hapter\s+\d/) ||
                         context.match(/\d+:\d+/) || // Time
                         context.match(/\$\d+/) || // Money
                         context.match(/\d+\.\d+/); // Decimal
      
      if (!isException) {
        issues.push({
          title: "Single digit not spelled out",
          description: `Number ${digit} should be spelled out (under 10)`,
          text: context,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "spellOutNumber",
          explanation: "Spell out numbers below 10: one, two, three... nine"
        });
      }
    });
    
    // Check for inconsistent number format in comparisons
    const comparisons = text.match(/\b\d+\s*(?:to|and|-)\s*\d+\b/g) || [];
    comparisons.forEach(comparison => {
      const numbers = comparison.match(/\d+/g);
      if (numbers && numbers.length === 2) {
        const first = parseInt(numbers[0]);
        const second = parseInt(numbers[1]);
        
        if ((first < 10 && second >= 10) || (first >= 10 && second < 10)) {
          issues.push({
            title: "Inconsistent number format in range",
            description: "Use consistent format for number ranges",
            text: comparison,
            severity: "Minor",
            category: "statistical",
            hasFix: false,
            explanation: "Be consistent: 'five to nine' or '5 to 15', not 'five to 15'"
          });
        }
      }
    });
    
    return issues.slice(0, 5);
  }

  /**
   * Validate percentage formatting
   */
  validatePercentageFormat(text) {
    const issues = [];
    
    // Find percentages
    const percentPattern = /\d+\.?\d*\s*(?:%|percent|per cent)/gi;
    const percentages = text.match(percentPattern) || [];
    
    percentages.forEach(percentage => {
      // Check for space before %
      if (percentage.includes(' %')) {
        issues.push({
          title: "Space before percent symbol",
          description: "No space between number and % symbol",
          text: percentage,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "removePercentSpace",
          explanation: "Use 75% not 75 %"
        });
      }
      
      // Check for 'percent' vs '%'
      if (percentage.includes('percent') || percentage.includes('per cent')) {
        const position = text.indexOf(percentage);
        const isStartOfSentence = position === 0 || text[position - 2] === '.';
        
        if (!isStartOfSentence) {
          issues.push({
            title: "Word 'percent' instead of symbol",
            description: "Use % symbol except at sentence beginning",
            text: percentage,
            severity: "Minor",
            category: "statistical",
            hasFix: true,
            fixAction: "usePercentSymbol",
            explanation: "Use % symbol: 25% not 25 percent"
          });
        }
      }
      
      // Check for percentages over 100 (unless clearly intentional)
      const value = parseFloat(percentage);
      if (value > 100 && value < 1000) {
        const position = text.indexOf(percentage);
        const context = text.substring(Math.max(0, position - 50), position + 50);
        
        if (!context.includes('increase') && !context.includes('growth')) {
          issues.push({
            title: "Percentage over 100%",
            description: "Verify percentage value exceeding 100%",
            text: percentage,
            severity: "Minor",
            category: "statistical",
            hasFix: false,
            explanation: "Double-check percentages over 100% for accuracy"
          });
        }
      }
    });
    
    return issues.slice(0, 3);
  }

  /**
   * Validate statistical results reporting format
   */
  validateStatisticalReporting(text) {
    const issues = [];
    
    // Check t-test reporting format
    const tTestPattern = /t\s*\([^)]+\)\s*=\s*[^,\s]+/gi;
    const tTests = text.match(tTestPattern) || [];
    
    tTests.forEach(tTest => {
      // Should include df in parentheses
      if (!tTest.match(/t\s*\(\d+(?:\.\d+)?\)/)) {
        issues.push({
          title: "t-test missing degrees of freedom",
          description: "t-test should include df: t(df) = value",
          text: tTest,
          severity: "Major",
          category: "statistical",
          hasFix: false,
          explanation: "Format: t(45) = 2.31, p = .025"
        });
      }
    });
    
    // Check F-test reporting format
    const fTestPattern = /F\s*\([^)]+\)\s*=\s*[^,\s]+/gi;
    const fTests = text.match(fTestPattern) || [];
    
    fTests.forEach(fTest => {
      // Should include two df values
      if (!fTest.match(/F\s*\(\d+,\s*\d+\)/)) {
        issues.push({
          title: "F-test incorrect df format",
          description: "F-test needs two df values: F(df1, df2)",
          text: fTest,
          severity: "Major",
          category: "statistical",
          hasFix: false,
          explanation: "Format: F(2, 147) = 5.67, p = .004"
        });
      }
    });
    
    // Check chi-square reporting
    const chiSquarePattern = /(?:χ2|chi-square|Chi-square)\s*\([^)]+\)/gi;
    const chiSquares = text.match(chiSquarePattern) || [];
    
    chiSquares.forEach(chiSquare => {
      if (!chiSquare.includes('χ²') && !chiSquare.includes('χ2')) {
        issues.push({
          title: "Chi-square symbol format",
          description: "Use χ² symbol for chi-square",
          text: chiSquare,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "fixChiSquareSymbol",
          explanation: "Use χ²(df) = value, not 'chi-square'"
        });
      }
    });
    
    // Check for p < .001 format
    const pValuePattern = /p\s*[<>=]\s*\.?\d+/gi;
    const pValues = text.match(pValuePattern) || [];
    
    pValues.forEach(pValue => {
      if (pValue.includes('0.000') || pValue.includes('.000')) {
        issues.push({
          title: "p-value reported as .000",
          description: "Report as p < .001 instead of p = .000",
          text: pValue,
          severity: "Major",
          category: "statistical",
          hasFix: true,
          fixAction: "fixPValueZero",
          explanation: "Never report p = .000, use p < .001"
        });
      }
      
      if (pValue.includes('=') && pValue.includes('.05')) {
        issues.push({
          title: "Exact p = .05",
          description: "Avoid reporting exactly p = .05",
          text: pValue,
          severity: "Minor",
          category: "statistical",
          hasFix: false,
          explanation: "Report actual p-value (e.g., p = .049 or p = .051)"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate mathematical operators spacing
   */
  validateMathOperators(text) {
    const issues = [];
    
    // Check for spaces around operators
    const operators = ['=', '<', '>', '≤', '≥', '±', '×'];
    
    operators.forEach(op => {
      // Find operator without proper spacing
      const noSpaceBefore = new RegExp(`\\S${op}`, 'g');
      const noSpaceAfter = new RegExp(`${op}\\S`, 'g');
      
      const matchesBefore = text.match(noSpaceBefore) || [];
      const matchesAfter = text.match(noSpaceAfter) || [];
      
      if (matchesBefore.length > 0 || matchesAfter.length > 0) {
        const example = matchesBefore[0] || matchesAfter[0];
        issues.push({
          title: "Missing spaces around operator",
          description: `Add spaces around '${op}' operator`,
          text: example,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "addOperatorSpaces",
          explanation: `Use spaces: n ${op} 50, not n${op}50`
        });
      }
    });
    
    // Check for minus sign vs hyphen
    const minusPattern = /\b\d+\s*-\s*\d+\b/g;
    const minusMatches = text.match(minusPattern) || [];
    
    minusMatches.forEach(match => {
      const position = text.indexOf(match);
      const context = text.substring(Math.max(0, position - 10), position + match.length + 10);
      
      // Check if it's a range (should use en dash) or subtraction
      if (!context.includes('minus') && !context.includes('negative')) {
        // Likely a range, covered elsewhere
      } else {
        // Subtraction should have spaces
        if (!match.includes(' - ')) {
          issues.push({
            title: "Missing spaces around minus sign",
            description: "Add spaces around minus operator",
            text: match,
            severity: "Minor",
            category: "statistical",
            hasFix: true,
            fixAction: "addMinusSpaces",
            explanation: "Use: 10 - 5 = 5, not 10-5=5"
          });
        }
      }
    });
    
    return issues.slice(0, 3);
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\tableFigureValidator.js
// src/utils/tableFigureValidator.js - Table and Figure APA compliance validation
'use client';

export class TableFigureValidator {
  constructor() {
    this.tablePattern = /(?:Table|TABLE)\s+(\d+\.?\d*)/gi;
    this.figurePattern = /(?:Figure|FIGURE|Fig\.|FIG\.)\s+(\d+\.?\d*)/gi;
    this.tableTitlePattern = /(?:Table|TABLE)\s+\d+\.?\d*\s*\n\s*([^\n]+)/gi;
    this.figureTitlePattern = /(?:Figure|FIGURE|Fig\.|FIG\.)\s+\d+\.?\d*\s*\n\s*([^\n]+)/gi;
  }

  /**
   * Main validation function for tables and figures
   */
  validateTablesAndFigures(text, structure, formatting) {
    const issues = [];
    
    if (!text) return issues;
    
    // Extract tables and figures
    const tables = this.extractTables(text, structure);
    const figures = this.extractFigures(text, structure);
    
    // Validate tables
    issues.push(...this.validateTables(tables, text));
    
    // Validate figures  
    issues.push(...this.validateFigures(figures, text));
    
    // Check in-text callouts
    issues.push(...this.validateCallouts(tables, figures, text));
    
    // Check for table/figure formatting in document structure
    if (formatting?.tables || formatting?.figures) {
      issues.push(...this.validateFormattingCompliance(formatting));
    }
    
    return issues;
  }

  /**
   * Extract tables from document
   */
  extractTables(text, structure) {
    const tables = [];
    const tableMatches = [...text.matchAll(this.tablePattern)];
    
    tableMatches.forEach((match, index) => {
      const number = match[1];
      const position = match.index;
      
      // Extract title
      const titleMatch = text.substring(position, position + 200).match(/Table\s+\d+\.?\d*\s*\n\s*([^\n]+)/i);
      const title = titleMatch ? titleMatch[1].trim() : '';
      
      // Extract note if present
      const noteMatch = text.substring(position, position + 500).match(/Note[.:]\s*([^\n]+)/i);
      const note = noteMatch ? noteMatch[1].trim() : '';
      
      tables.push({
        number: parseFloat(number),
        numberText: number,
        title: title,
        note: note,
        position: position,
        fullMatch: match[0],
        hasTitle: title.length > 0,
        hasNote: note.length > 0,
        titleCase: this.checkTitleCase(title),
        location: this.getLocationContext(text, position)
      });
    });
    
    return tables;
  }

  /**
   * Extract figures from document
   */
  extractFigures(text, structure) {
    const figures = [];
    const figureMatches = [...text.matchAll(this.figurePattern)];
    
    figureMatches.forEach((match, index) => {
      const number = match[1];
      const position = match.index;
      
      // Extract caption
      const captionMatch = text.substring(position, position + 200).match(/(?:Figure|Fig\.)\s+\d+\.?\d*\s*\.?\s*([^\n]+)/i);
      const caption = captionMatch ? captionMatch[1].trim() : '';
      
      // Extract note if present
      const noteMatch = text.substring(position, position + 500).match(/Note[.:]\s*([^\n]+)/i);
      const note = noteMatch ? noteMatch[1].trim() : '';
      
      figures.push({
        number: parseFloat(number),
        numberText: number,
        caption: caption,
        note: note,
        position: position,
        fullMatch: match[0],
        hasCaption: caption.length > 0,
        hasNote: note.length > 0,
        captionCase: this.checkSentenceCase(caption),
        location: this.getLocationContext(text, position)
      });
    });
    
    return figures;
  }

  /**
   * Get location context for table/figure
   */
  getLocationContext(text, position) {
    const before = text.substring(Math.max(0, position - 100), position);
    const after = text.substring(position, Math.min(text.length, position + 100));
    
    // Check if it's in references section
    const inReferences = before.toLowerCase().includes('references') || 
                        text.substring(Math.max(0, position - 500), position).toLowerCase().includes('references');
    
    // Check if it's in appendix
    const inAppendix = before.toLowerCase().includes('appendix') ||
                      text.substring(Math.max(0, position - 500), position).toLowerCase().includes('appendix');
    
    return {
      inReferences,
      inAppendix,
      contextBefore: before.substring(before.length - 50),
      contextAfter: after.substring(0, 50)
    };
  }

  /**
   * Check if text is in title case
   */
  checkTitleCase(text) {
    if (!text) return false;
    
    const words = text.split(/\s+/);
    const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 
                       'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet', 'with'];
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const isSmallWord = smallWords.includes(word.toLowerCase());
      const isFirstOrLast = i === 0 || i === words.length - 1;
      
      // First and last words should be capitalized
      if (isFirstOrLast && word[0] !== word[0].toUpperCase()) {
        return false;
      }
      
      // Small words in middle should be lowercase
      if (!isFirstOrLast && isSmallWord && word[0] === word[0].toUpperCase()) {
        return false;
      }
      
      // Other words should be capitalized
      if (!isFirstOrLast && !isSmallWord && word[0] !== word[0].toUpperCase()) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * Check if text is in sentence case
   */
  checkSentenceCase(text) {
    if (!text) return false;
    
    // First letter should be capital
    if (text[0] !== text[0].toUpperCase()) return false;
    
    // Check for proper nouns and acronyms (allow those to be capitalized)
    const words = text.split(/\s+/);
    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      
      // Skip acronyms (all caps)
      if (word === word.toUpperCase() && word.length > 1) continue;
      
      // Skip words after colons
      if (i > 0 && words[i-1].endsWith(':')) continue;
      
      // Regular words should be lowercase
      if (word[0] === word[0].toUpperCase() && word !== word.toUpperCase()) {
        // Could be a proper noun, but flag if too many
        const capsCount = words.filter(w => w[0] === w[0].toUpperCase()).length;
        if (capsCount > words.length * 0.3) return false;
      }
    }
    
    return true;
  }

  /**
   * Validate tables
   */
  validateTables(tables, text) {
    const issues = [];
    
    // Check numbering sequence
    const numberingIssues = this.checkNumberingSequence(tables, 'Table');
    issues.push(...numberingIssues);
    
    tables.forEach((table, index) => {
      // Check for missing title
      if (!table.hasTitle || table.title.length < 5) {
        issues.push({
          title: "Missing or incomplete table title",
          description: `Table ${table.numberText} lacks a descriptive title`,
          text: table.fullMatch,
          severity: "Major",
          category: "tables",
          hasFix: false,
          explanation: "Every table must have a brief, descriptive title in title case placed above the table."
        });
      } else if (!table.titleCase) {
        // Check title case
        issues.push({
          title: "Incorrect table title capitalization",
          description: `Table ${table.numberText} title should use title case`,
          text: table.title,
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "fixTableTitleCase",
          explanation: "Table titles should use title case capitalization (major words capitalized)."
        });
      }
      
      // Check table placement
      if (table.location.inReferences) {
        issues.push({
          title: "Table in references section",
          description: `Table ${table.numberText} appears in the References section`,
          text: table.fullMatch,
          severity: "Major",
          category: "tables",
          hasFix: false,
          explanation: "Tables should appear in the main text or appendices, not in the References section."
        });
      }
      
      // Check for table note formatting
      if (table.hasNote && !table.note.startsWith('Note.')) {
        issues.push({
          title: "Incorrect table note format",
          description: `Table ${table.numberText} note should start with 'Note.' in italics`,
          text: table.note.substring(0, 50),
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "fixTableNoteFormat",
          explanation: "Table notes should begin with 'Note.' in italics, followed by the note text."
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate figures
   */
  validateFigures(figures, text) {
    const issues = [];
    
    // Check numbering sequence
    const numberingIssues = this.checkNumberingSequence(figures, 'Figure');
    issues.push(...numberingIssues);
    
    figures.forEach((figure, index) => {
      // Check for missing caption
      if (!figure.hasCaption || figure.caption.length < 5) {
        issues.push({
          title: "Missing or incomplete figure caption",
          description: `Figure ${figure.numberText} lacks a descriptive caption`,
          text: figure.fullMatch,
          severity: "Major",
          category: "figures",
          hasFix: false,
          explanation: "Every figure must have a brief, descriptive caption in sentence case placed below the figure."
        });
      } else if (!figure.captionCase) {
        // Check sentence case
        issues.push({
          title: "Incorrect figure caption capitalization",
          description: `Figure ${figure.numberText} caption should use sentence case`,
          text: figure.caption,
          severity: "Minor",
          category: "figures",
          hasFix: true,
          fixAction: "fixFigureCaptionCase",
          explanation: "Figure captions should use sentence case (only first word and proper nouns capitalized)."
        });
      }
      
      // Check figure placement
      if (figure.location.inReferences) {
        issues.push({
          title: "Figure in references section",
          description: `Figure ${figure.numberText} appears in the References section`,
          text: figure.fullMatch,
          severity: "Major",
          category: "figures",
          hasFix: false,
          explanation: "Figures should appear in the main text or appendices, not in the References section."
        });
      }
      
      // Check for copyright/permission note if needed
      const needsCopyright = figure.caption.includes('from') || 
                            figure.caption.includes('adapted') || 
                            figure.caption.includes('reprinted');
      
      if (needsCopyright && !figure.note.includes('Copyright') && !figure.note.includes('permission')) {
        issues.push({
          title: "Missing copyright information",
          description: `Figure ${figure.numberText} may need copyright attribution`,
          text: figure.caption.substring(0, 50),
          severity: "Minor",
          category: "figures",
          hasFix: false,
          explanation: "Figures adapted or reprinted from other sources need copyright attribution in the note."
        });
      }
    });
    
    return issues;
  }

  /**
   * Check numbering sequence with appendix support
   */
  checkNumberingSequence(items, type) {
    const issues = [];
    
    if (items.length < 2) return issues;
    
    // Separate main document items from appendix items
    const mainItems = [];
    const appendixItems = new Map(); // Map of appendix letter to items
    
    items.forEach(item => {
      // Check if it's an appendix table/figure (e.g., Table A1, Figure B2)
      const appendixMatch = item.numberText.match(/^([A-Z])(\d+)$/);
      if (appendixMatch) {
        const appendixLetter = appendixMatch[1];
        const appendixNumber = parseInt(appendixMatch[2]);
        
        if (!appendixItems.has(appendixLetter)) {
          appendixItems.set(appendixLetter, []);
        }
        appendixItems.get(appendixLetter).push({
          ...item,
          appendixLetter,
          appendixNumber
        });
      } else if (!item.numberText.includes('.') || item.numberText.match(/^\d+\.\d+$/)) {
        // Regular numbered item or sub-numbered item (2.1, 2.2)
        mainItems.push(item);
      }
    });
    
    // Check main document sequence
    if (mainItems.length > 1) {
      const sortedMain = [...mainItems].sort((a, b) => a.position - b.position);
      let expectedNumber = 1;
      
      for (let i = 0; i < sortedMain.length; i++) {
        const item = sortedMain[i];
        const isSubNumber = item.numberText.includes('.');
        
        if (!isSubNumber && item.number !== expectedNumber) {
          if (Math.abs(item.number - expectedNumber) > 0.1) {
            issues.push({
              title: `${type} numbering sequence error`,
              description: `${type} ${item.numberText} appears out of sequence (expected ${type} ${expectedNumber})`,
              text: item.fullMatch,
              severity: "Major",
              category: type.toLowerCase() + 's',
              hasFix: true,
              fixAction: `fix${type}Numbering`,
              explanation: `${type}s must be numbered consecutively in the order they appear in the text.`
            });
            break;
          }
        }
        
        if (!isSubNumber) {
          expectedNumber = item.number + 1;
        }
      }
    }
    
    // Check appendix sequences (each appendix has its own sequence)
    appendixItems.forEach((appendixItemList, appendixLetter) => {
      if (appendixItemList.length > 1) {
        const sortedAppendix = [...appendixItemList].sort((a, b) => a.position - b.position);
        let expectedAppendixNumber = 1;
        
        for (let i = 0; i < sortedAppendix.length; i++) {
          const item = sortedAppendix[i];
          
          if (item.appendixNumber !== expectedAppendixNumber) {
            issues.push({
              title: `Appendix ${appendixLetter} ${type} numbering error`,
              description: `${type} ${item.numberText} out of sequence (expected ${type} ${appendixLetter}${expectedAppendixNumber})`,
              text: item.fullMatch,
              severity: "Major",
              category: type.toLowerCase() + 's',
              hasFix: true,
              fixAction: `fixAppendix${type}Numbering`,
              explanation: `Appendix ${type}s must be numbered consecutively within each appendix.`
            });
            break;
          }
          expectedAppendixNumber++;
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate in-text callouts
   */
  validateCallouts(tables, figures, text) {
    const issues = [];
    const reportedMissing = new Set();
    
    // Check table callouts
    tables.forEach(table => {
      const calloutPattern = new RegExp(`(?:see |See |shown in |displayed in |presented in )?Table\\s+${table.numberText}(?![\\d.])`, 'gi');
      const hasCallout = calloutPattern.test(text.substring(0, table.position));
      
      if (!hasCallout && !reportedMissing.has('table')) {
        issues.push({
          title: "Missing table callout",
          description: `Table ${table.numberText} is not referenced in the text before it appears`,
          text: `Table ${table.numberText}`,
          severity: "Major",
          category: "tables",
          hasFix: false,
          explanation: "Every table must be called out (mentioned) in the text before it appears."
        });
        reportedMissing.add('table');
      }
    });
    
    // Check figure callouts
    figures.forEach(figure => {
      const calloutPattern = new RegExp(`(?:see |See |shown in |displayed in |illustrated in )?(?:Figure|Fig\\.)\\s+${figure.numberText}(?![\\d.])`, 'gi');
      const hasCallout = calloutPattern.test(text.substring(0, figure.position));
      
      if (!hasCallout && !reportedMissing.has('figure')) {
        issues.push({
          title: "Missing figure callout",
          description: `Figure ${figure.numberText} is not referenced in the text before it appears`,
          text: `Figure ${figure.numberText}`,
          severity: "Major",
          category: "figures",
          hasFix: false,
          explanation: "Every figure must be called out (mentioned) in the text before it appears."
        });
        reportedMissing.add('figure');
      }
    });
    
    // Check for callouts to non-existent tables/figures
    const tableCalloutPattern = /(?:see |See |shown in |displayed in |presented in )?Table\s+(\d+\.?\d*)/gi;
    const existingTableNumbers = new Set(tables.map(t => t.numberText));
    
    let match;
    while ((match = tableCalloutPattern.exec(text)) !== null) {
      const calledNumber = match[1];
      if (!existingTableNumbers.has(calledNumber) && !reportedMissing.has('missing-table-' + calledNumber)) {
        issues.push({
          title: "Reference to non-existent table",
          description: `Text references Table ${calledNumber} which doesn't exist`,
          text: match[0],
          severity: "Critical",
          category: "tables",
          hasFix: false,
          explanation: "All tables referenced in the text must actually exist in the document."
        });
        reportedMissing.add('missing-table-' + calledNumber);
      }
    }
    
    const figureCalloutPattern = /(?:see |See |shown in |displayed in |illustrated in )?(?:Figure|Fig\.)\s+(\d+\.?\d*)/gi;
    const existingFigureNumbers = new Set(figures.map(f => f.numberText));
    
    while ((match = figureCalloutPattern.exec(text)) !== null) {
      const calledNumber = match[1];
      if (!existingFigureNumbers.has(calledNumber) && !reportedMissing.has('missing-figure-' + calledNumber)) {
        issues.push({
          title: "Reference to non-existent figure",
          description: `Text references Figure ${calledNumber} which doesn't exist`,
          text: match[0],
          severity: "Critical",
          category: "figures",
          hasFix: false,
          explanation: "All figures referenced in the text must actually exist in the document."
        });
        reportedMissing.add('missing-figure-' + calledNumber);
      }
    }
    
    return issues;
  }

  /**
   * Validate formatting compliance from document structure
   */
  validateFormattingCompliance(formatting) {
    const issues = [];
    
    // Check table formatting if available
    if (formatting.tables) {
      formatting.tables.forEach((table, index) => {
        // Check for vertical lines (APA doesn't use them)
        if (table.hasVerticalLines) {
          issues.push({
            title: "Vertical lines in table",
            description: `Table ${index + 1} contains vertical lines`,
            text: `Table ${index + 1}`,
            severity: "Minor",
            category: "tables",
            hasFix: true,
            fixAction: "removeTableVerticalLines",
            explanation: "APA style tables should not use vertical lines, only horizontal lines for clarity."
          });
        }
        
        // Check for borders
        if (table.hasFullBorders) {
          issues.push({
            title: "Excessive borders in table",
            description: `Table ${index + 1} has full borders instead of APA style`,
            text: `Table ${index + 1}`,
            severity: "Minor",
            category: "tables",
            hasFix: true,
            fixAction: "fixTableBorders",
            explanation: "APA tables use minimal borders: top and bottom of table, and below column headings."
          });
        }
      });
    }
    
    // Check figure formatting if available
    if (formatting.figures) {
      formatting.figures.forEach((figure, index) => {
        // Check image quality/resolution notes
        if (figure.lowResolution) {
          issues.push({
            title: "Low resolution figure",
            description: `Figure ${index + 1} appears to have low resolution`,
            text: `Figure ${index + 1}`,
            severity: "Minor",
            category: "figures",
            hasFix: false,
            explanation: "Figures should be high resolution for clarity in print and digital formats."
          });
        }
      });
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\tiptapDocumentConverter.js
// Tiptap document converter - converts server formatting to Tiptap JSON
import { createFormattedParagraph, createFormattedContent } from './tiptapFormattingExtensions';

export class TiptapDocumentConverter {
  constructor() {
    this.memoryMonitor = {
      enabled: typeof performance !== 'undefined' && performance.memory,
      initialMemory: 0,
      peakMemory: 0
    };
  }

  /**
   * Yield control back to the UI thread
   */
  async yieldToUI() {
    return new Promise(resolve => {
      // Use MessageChannel for proper yielding if available, otherwise setTimeout
      if (typeof MessageChannel !== 'undefined') {
        const channel = new MessageChannel();
        channel.port2.onmessage = () => resolve();
        channel.port1.postMessage(null);
      } else {
        setTimeout(resolve, 0);
      }
    });
  }

  /**
   * Monitor memory usage during processing
   */
  checkMemoryUsage() {
    if (this.memoryMonitor.enabled) {
      const currentMemory = performance.memory.usedJSHeapSize;
      this.memoryMonitor.peakMemory = Math.max(this.memoryMonitor.peakMemory, currentMemory);

      // Warn if memory usage is high
      if (currentMemory > 100 * 1024 * 1024) { // 100MB threshold
        console.warn(`⚠️ High memory usage detected: ${Math.round(currentMemory / 1024 / 1024)}MB`);
      }

      return {
        current: currentMemory,
        peak: this.memoryMonitor.peakMemory,
        initial: this.memoryMonitor.initialMemory
      };
    }
    return null;
  }

  /**
   * Convert server document formatting to Tiptap JSON format (async with UI yielding)
   */
  async convertToTiptapDocument(documentText, documentFormatting) {
    // Initialize memory monitoring
    if (this.memoryMonitor.enabled) {
      this.memoryMonitor.initialMemory = performance.memory.usedJSHeapSize;
      this.memoryMonitor.peakMemory = this.memoryMonitor.initialMemory;
    }

    if (!documentFormatting?.paragraphs?.length) {
      return {
        type: 'doc',
        content: [{
          type: 'paragraph',
          content: [{
            type: 'text',
            text: documentText || ' ' // Ensure non-empty text
          }]
        }]
      };
    }

    const content = [];
    const paragraphsToProcess = documentFormatting.paragraphs;

    // Dynamic batch sizing based on document size
    const batchSize = paragraphsToProcess.length > 1000 ? 50 : 100;
    const yieldInterval = 10; // Yield to UI every 10 batches
    let processedBatches = 0;
    const startTime = performance.now();

    console.log(`📄 Processing ${paragraphsToProcess.length} paragraphs in batches of ${batchSize}...`);

    // Log initial memory usage
    const initialMemory = this.checkMemoryUsage();
    if (initialMemory) {
      console.log(`💾 Initial memory usage: ${Math.round(initialMemory.current / 1024 / 1024)}MB`);
    }

    for (let i = 0; i < paragraphsToProcess.length; i += batchSize) {
      const batch = paragraphsToProcess.slice(i, Math.min(i + batchSize, paragraphsToProcess.length));

      // Process batch synchronously but yield to UI between batches
      batch.forEach((paraFormatting, batchIndex) => {
        const index = i + batchIndex;
        try {
          const paragraph = this.createParagraphNode(paraFormatting);
          if (paragraph) {
            content.push(paragraph);
          }
        } catch (error) {
          console.warn(`Failed to create paragraph ${index}:`, error);
          // Add a simple fallback paragraph - ensure text is not empty
          const fallbackText = paraFormatting.text || ' '; // Use space if empty
          content.push({
            type: 'paragraph',
            content: [{
              type: 'text',
              text: fallbackText
            }]
          });
        }
      });

      processedBatches++;

      // Yield to UI thread every few batches for large documents
      if (processedBatches % yieldInterval === 0) {
        await this.yieldToUI();

        // Check memory usage
        const memoryInfo = this.checkMemoryUsage();

        // Log progress for large documents
        if (paragraphsToProcess.length > 500) {
          const processed = Math.min(i + batchSize, paragraphsToProcess.length);
          const percent = Math.round((processed / paragraphsToProcess.length) * 100);
          const memoryText = memoryInfo ? ` | Memory: ${Math.round(memoryInfo.current / 1024 / 1024)}MB` : '';
          console.log(`📊 Processed ${processed} of ${paragraphsToProcess.length} paragraphs (${percent}%)${memoryText}`);
        }
      }
    }

    // Log completion statistics
    const endTime = performance.now();
    const processingTime = endTime - startTime;
    const finalMemory = this.checkMemoryUsage();

    console.log(`✅ Document conversion completed in ${Math.round(processingTime)}ms`);
    if (finalMemory) {
      const memoryUsed = Math.round((finalMemory.peak - finalMemory.initial) / 1024 / 1024);
      console.log(`💾 Peak memory usage: ${Math.round(finalMemory.peak / 1024 / 1024)}MB (+${memoryUsed}MB)`);
    }

    // Ensure at least one paragraph with non-empty text
    if (content.length === 0) {
      content.push({
        type: 'paragraph',
        content: [{
          type: 'text',
          text: ' ' // Use space instead of empty string
        }]
      });
    }

    return {
      type: 'doc',
      content
    };
  }

  /**
   * Create a Tiptap paragraph node from server formatting
   */
  createParagraphNode(paraFormatting) {
    // Check if it's a heading or regular paragraph
    const nodeType = this.determineNodeType(paraFormatting);
    
    if (nodeType === 'heading') {
      // Create heading with formatting
      return {
        type: 'heading',
        attrs: {
          level: this.getHeadingLevel(paraFormatting.style || ''),
          originalFormatting: paraFormatting
        },
        content: createFormattedContent(paraFormatting)
      };
    } else {
      // Use the formatted paragraph creator for regular paragraphs
      return createFormattedParagraph(paraFormatting);
    }
  }

  /**
   * Determine node type from paragraph style
   */
  determineNodeType(paraFormatting) {
    if (paraFormatting?.style) {
      const style = paraFormatting.style.toLowerCase();
      if (style.includes('title')) return 'heading';
      if (style.includes('heading')) {
        return 'heading';
      }
    }
    return 'paragraph';
  }

  /**
   * Get heading level from style
   */
  getHeadingLevel(style) {
    const match = style.match(/heading\s*(\d+)/i);
    if (match) {
      return Math.min(6, Math.max(1, parseInt(match[1])));
    }
    return 1;
  }

  /**
   * Create content nodes from runs or text
   */
  createContentNodes(paraFormatting) {
    const content = [];
    
    if (paraFormatting.runs && paraFormatting.runs.length > 0) {
      // Process each run
      paraFormatting.runs.forEach(run => {
        if (run.text) {
          const textNode = this.createTextNode(run);
          if (textNode) {
            content.push(textNode);
          }
        }
      });
    } else if (paraFormatting.text) {
      // Fallback to paragraph text
      content.push({
        type: 'text',
        text: paraFormatting.text,
        marks: this.extractTextMarks({
          font: paraFormatting.font
        })
      });
    }

    return content;
  }

  /**
   * Create a text node with marks
   */
  createTextNode(run) {
    const node = {
      type: 'text',
      text: run.text
    };

    const marks = this.extractTextMarks(run);
    if (marks.length > 0) {
      node.marks = marks;
    }

    return node;
  }

  /**
   * Extract marks (formatting) for text
   */
  extractTextMarks(run) {
    const marks = [];
    
    if (run.font?.bold) {
      marks.push({ type: 'bold' });
    }
    
    if (run.font?.italic) {
      marks.push({ type: 'italic' });
    }
    
    if (run.font?.underline) {
      marks.push({ type: 'underline' });
    }
    
    // Font family
    if (run.font?.family) {
      marks.push({
        type: 'textStyle',
        attrs: {
          fontFamily: run.font.family
        }
      });
    }
    
    // Font size
    if (run.font?.size) {
      marks.push({
        type: 'textStyle',
        attrs: {
          fontSize: `${run.font.size}pt`
        }
      });
    }
    
    // Color
    if (run.color) {
      marks.push({
        type: 'textStyle',
        attrs: {
          color: run.color.startsWith('#') ? run.color : `#${run.color}`
        }
      });
    }

    return marks;
  }

  /**
   * Extract paragraph-level attributes
   */
  extractParagraphAttributes(paraFormatting) {
    const attrs = {};
    
    // For headings, set the level
    if (paraFormatting?.style?.toLowerCase().includes('heading')) {
      attrs.level = this.getHeadingLevel(paraFormatting.style);
    }
    
    // Text alignment
    if (paraFormatting.alignment && paraFormatting.alignment !== 'left') {
      attrs.textAlign = paraFormatting.alignment;
    }
    
    // Store original formatting data for reference
    attrs.originalFormatting = {
      spacing: paraFormatting.spacing,
      indentation: paraFormatting.indentation,
      font: paraFormatting.font,
      style: paraFormatting.style
    };

    return attrs;
  }

  /**
   * Apply custom CSS styles based on original formatting
   */
  getCustomStyles(formatting) {
    const styles = {};
    
    // Line spacing
    if (formatting?.spacing?.line) {
      styles.lineHeight = formatting.spacing.line;
    }
    
    // Paragraph spacing
    if (formatting?.spacing?.before) {
      styles.marginTop = `${formatting.spacing.before}pt`;
    }
    if (formatting?.spacing?.after) {
      styles.marginBottom = `${formatting.spacing.after}pt`;
    }
    
    // Indentation
    if (formatting?.indentation?.firstLine) {
      styles.textIndent = `${formatting.indentation.firstLine}in`;
    }
    if (formatting?.indentation?.left) {
      styles.paddingLeft = `${formatting.indentation.left}in`;
    }
    if (formatting?.indentation?.right) {
      styles.paddingRight = `${formatting.indentation.right}in`;
    }
    
    return styles;
  }

  /**
   * Create decorations for issue highlighting
   */
  createIssueDecorations(editor, issues, documentFormatting) {
    const decorations = [];
    
    issues.forEach(issue => {
      try {
        const positions = this.findIssuePositions(editor, issue, documentFormatting);
        
        positions.forEach(pos => {
          decorations.push({
            from: pos.from,
            to: pos.to,
            class: this.getIssueHighlightClass(issue.severity),
            attrs: {
              'data-issue-id': issue.id,
              'data-severity': issue.severity
            }
          });
        });
      } catch (error) {
        console.warn(`Failed to create decoration for issue ${issue.id}:`, error);
      }
    });
    
    return decorations;
  }

  /**
   * Find positions for issue highlighting in Tiptap document
   */
  findIssuePositions(editor, issue, documentFormatting) {
    const positions = [];
    const { state } = editor;
    const { doc } = state;
    
    // Get search text
    const searchText = issue.highlightText || issue.text;
    if (!searchText || searchText.length < 2) {
      return positions;
    }
    
    const cleanSearchText = searchText.endsWith('...') 
      ? searchText.slice(0, -3).trim() 
      : searchText;
    
    // Search in document
    let from = 0;
    doc.descendants((node, pos) => {
      if (node.isText) {
        const text = node.text;
        let index = text.indexOf(cleanSearchText);
        
        while (index !== -1) {
          positions.push({
            from: pos + index,
            to: pos + index + cleanSearchText.length
          });
          index = text.indexOf(cleanSearchText, index + 1);
        }
      }
    });
    
    return positions;
  }

  /**
   * Get CSS class for issue severity
   */
  getIssueHighlightClass(severity) {
    const baseClass = 'apa-issue-highlight';
    switch (severity) {
      case 'Critical':
        return `${baseClass} bg-red-100 border-b-2 border-red-500 hover:bg-red-200`;
      case 'Major':
        return `${baseClass} bg-orange-100 border-b-2 border-orange-500 hover:bg-orange-200`;
      case 'Minor':
        return `${baseClass} bg-blue-100 border-b-2 border-blue-500 hover:bg-blue-200`;
      default:
        return `${baseClass} bg-gray-100 border-b-2 border-gray-400`;
    }
  }
}

export const tiptapConverter = new TiptapDocumentConverter();

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\tiptapFormattingExtensions.js
// Custom Tiptap extensions to preserve DOCX formatting
import { Node, Mark, Extension } from '@tiptap/core';
import { Plugin } from '@tiptap/pm/state';

/**
 * Custom Paragraph node that preserves DOCX paragraph formatting
 */
export const FormattedParagraph = Node.create({
  name: 'paragraph', // Use 'paragraph' name to replace default
  
  priority: 1000,
  
  group: 'block',
  
  content: 'inline*',
  
  addAttributes() {
    return {
      // Spacing attributes
      lineHeight: { default: null },
      spaceBefore: { default: null },
      spaceAfter: { default: null },
      
      // Indentation attributes
      firstLineIndent: { default: null },
      leftIndent: { default: null },
      rightIndent: { default: null },
      hangingIndent: { default: null },
      
      // Alignment
      textAlign: { default: null },
      
      // Original style name from DOCX
      styleName: { default: null },
      
      // Store complete original formatting
      originalFormatting: { default: null }
    };
  },
  
  parseHTML() {
    return [
      {
        tag: 'p',
        getAttrs: (dom) => {
          const style = dom.getAttribute('style') || '';
          const attrs = {};
          
          // Parse inline styles
          style.split(';').forEach(rule => {
            const [property, value] = rule.split(':').map(s => s.trim());
            if (property && value) {
              switch(property) {
                case 'line-height':
                  attrs.lineHeight = value;
                  break;
                case 'margin-top':
                  attrs.spaceBefore = value;
                  break;
                case 'margin-bottom':
                  attrs.spaceAfter = value;
                  break;
                case 'text-indent':
                  attrs.firstLineIndent = value;
                  break;
                case 'padding-left':
                  attrs.leftIndent = value;
                  break;
                case 'padding-right':
                  attrs.rightIndent = value;
                  break;
                case 'text-align':
                  attrs.textAlign = value;
                  break;
              }
            }
          });
          
          return attrs;
        }
      }
    ];
  },
  
  renderHTML({ node, HTMLAttributes }) {
    const styles = [];
    
    // Apply line height
    if (node.attrs.lineHeight) {
      styles.push(`line-height: ${node.attrs.lineHeight}`);
    }
    
    // Apply spacing
    if (node.attrs.spaceBefore) {
      styles.push(`margin-top: ${node.attrs.spaceBefore}`);
    }
    if (node.attrs.spaceAfter) {
      styles.push(`margin-bottom: ${node.attrs.spaceAfter}`);
    }
    
    // Apply indentation
    if (node.attrs.firstLineIndent) {
      styles.push(`text-indent: ${node.attrs.firstLineIndent}`);
    }
    if (node.attrs.leftIndent) {
      styles.push(`padding-left: ${node.attrs.leftIndent}`);
    }
    if (node.attrs.rightIndent) {
      styles.push(`padding-right: ${node.attrs.rightIndent}`);
    }
    if (node.attrs.hangingIndent) {
      styles.push(`text-indent: -${node.attrs.hangingIndent}`);
      styles.push(`padding-left: ${node.attrs.hangingIndent}`);
    }
    
    // Apply alignment
    if (node.attrs.textAlign) {
      styles.push(`text-align: ${node.attrs.textAlign}`);
    }
    
    return ['p', { 
      ...HTMLAttributes, 
      style: styles.join('; '),
      'data-style-name': node.attrs.styleName
    }, 0];
  }
});

/**
 * Custom Text Style mark that preserves font properties
 */
export const FontFormatting = Mark.create({
  name: 'fontFormatting',
  
  priority: 101,
  
  addAttributes() {
    return {
      fontFamily: { default: null },
      fontSize: { default: null },
      color: { default: null }
    };
  },
  
  parseHTML() {
    return [
      {
        tag: 'span',
        getAttrs: (dom) => {
          const style = dom.getAttribute('style') || '';
          const attrs = {};
          
          style.split(';').forEach(rule => {
            const [property, value] = rule.split(':').map(s => s.trim());
            if (property && value) {
              switch(property) {
                case 'font-family':
                  attrs.fontFamily = value.replace(/['"]/g, '');
                  break;
                case 'font-size':
                  attrs.fontSize = value;
                  break;
                case 'color':
                  attrs.color = value;
                  break;
              }
            }
          });
          
          return Object.keys(attrs).length > 0 ? attrs : null;
        }
      }
    ];
  },
  
  renderHTML({ mark, HTMLAttributes }) {
    const styles = [];
    
    if (mark.attrs.fontFamily) {
      styles.push(`font-family: "${mark.attrs.fontFamily}"`);
    }
    if (mark.attrs.fontSize) {
      styles.push(`font-size: ${mark.attrs.fontSize}`);
    }
    if (mark.attrs.color) {
      styles.push(`color: ${mark.attrs.color}`);
    }
    
    return ['span', { ...HTMLAttributes, style: styles.join('; ') }, 0];
  }
});

/**
 * Extension to apply document-wide default formatting
 */
export const DocumentDefaults = Extension.create({
  name: 'documentDefaults',
  
  addOptions() {
    return {
      defaultFont: 'Times New Roman',
      defaultSize: '12pt',
      defaultLineHeight: 2,
      defaultSpacing: {
        before: 0,
        after: 0
      }
    };
  },
  
  addGlobalAttributes() {
    return [
      {
        types: ['paragraph', 'heading'],
        attributes: {
          preserveFormatting: {
            default: true,
            rendered: false
          }
        }
      }
    ];
  },
  
  addProseMirrorPlugins() {
    return [
      new Plugin({
        key: 'documentDefaults',
        props: {
          transformPasted(slice) {
            // Ensure pasted content preserves formatting
            return slice;
          }
        }
      })
    ];
  }
});

/**
 * Create a formatted paragraph node from DOCX data
 */
export function createFormattedParagraph(paraFormatting) {
  const attrs = {};
  
  // Extract spacing
  if (paraFormatting.spacing) {
    if (paraFormatting.spacing.line) {
      attrs.lineHeight = paraFormatting.spacing.line;
    }
    if (paraFormatting.spacing.before) {
      attrs.spaceBefore = `${paraFormatting.spacing.before}pt`;
    }
    if (paraFormatting.spacing.after) {
      attrs.spaceAfter = `${paraFormatting.spacing.after}pt`;
    }
  }
  
  // Extract indentation
  if (paraFormatting.indentation) {
    if (paraFormatting.indentation.firstLine) {
      attrs.firstLineIndent = `${paraFormatting.indentation.firstLine}in`;
    }
    if (paraFormatting.indentation.left) {
      attrs.leftIndent = `${paraFormatting.indentation.left}in`;
    }
    if (paraFormatting.indentation.right) {
      attrs.rightIndent = `${paraFormatting.indentation.right}in`;
    }
    if (paraFormatting.indentation.hanging) {
      attrs.hangingIndent = `${paraFormatting.indentation.hanging}in`;
    }
  }
  
  // Extract alignment
  if (paraFormatting.alignment) {
    attrs.textAlign = paraFormatting.alignment === 'both' ? 'justify' : paraFormatting.alignment;
  }
  
  // Store style name
  if (paraFormatting.style) {
    attrs.styleName = paraFormatting.style;
  }
  
  // Store complete original formatting
  attrs.originalFormatting = paraFormatting;
  
  return {
    type: 'paragraph', // Use 'paragraph' type name
    attrs,
    content: createFormattedContent(paraFormatting)
  };
}

/**
 * Create formatted content (text with marks) from runs
 */
export function createFormattedContent(paraFormatting) {
  const content = [];
  
  if (paraFormatting.runs && paraFormatting.runs.length > 0) {
    // Process all runs but optimize for performance
    const runsToProcess = paraFormatting.runs;
    
    runsToProcess.forEach(run => {
      // Skip completely empty runs
      if (!run.text || run.text.length === 0) return;
      
      const textNode = {
        type: 'text',
        text: run.text
      };
      
      const marks = [];
      
      // Add font formatting mark - always preserve formatting
      const fontAttrs = {};
      if (run.font?.family) {
        fontAttrs.fontFamily = run.font.family;
      }
      if (run.font?.size) {
        fontAttrs.fontSize = `${run.font.size}pt`;
      }
      if (run.color) {
        fontAttrs.color = run.color.startsWith('#') ? run.color : `#${run.color}`;
      }
      
      if (Object.keys(fontAttrs).length > 0) {
        marks.push({
          type: 'fontFormatting',
          attrs: fontAttrs
        });
      }
      
      // Add standard marks
      if (run.font?.bold) {
        marks.push({ type: 'bold' });
      }
      if (run.font?.italic) {
        marks.push({ type: 'italic' });
      }
      if (run.font?.underline) {
        marks.push({ type: 'underline' });
      }
      
      if (marks.length > 0) {
        textNode.marks = marks;
      }
      
      content.push(textNode);
    });
  } else if (paraFormatting.text) {
    // Fallback to plain text
    const textNode = {
      type: 'text',
      text: paraFormatting.text
    };
    
    // Apply paragraph-level font if available
    if (paraFormatting.font) {
      const fontAttrs = {};
      if (paraFormatting.font.family) {
        fontAttrs.fontFamily = paraFormatting.font.family;
      }
      if (paraFormatting.font.size) {
        fontAttrs.fontSize = `${paraFormatting.font.size}pt`;
      }
      
      if (Object.keys(fontAttrs).length > 0) {
        textNode.marks = [{
          type: 'fontFormatting',
          attrs: fontAttrs
        }];
      }
    }
    
    content.push(textNode);
  }
  
  // Ensure no empty text nodes - Tiptap doesn't allow them
  const validContent = content.filter(node => {
    if (node.type === 'text' && (!node.text || node.text.length === 0)) {
      return false;
    }
    return true;
  });
  
  // If no valid content, return a text node with at least a space
  return validContent.length > 0 ? validContent : [{ type: 'text', text: ' ' }];
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\tiptapIssueHighlighter.js
// Tiptap Issue Highlighter - Decoration-based highlighting for APA issues
import { Extension } from '@tiptap/core';
import { Plugin, PluginKey } from '@tiptap/pm/state';
import { Decoration, DecorationSet } from '@tiptap/pm/view';

const highlighterKey = new PluginKey('issueHighlighter');

// Helper functions defined outside the extension
function findTextInNode(text, searchText, basePos, positions, isTruncated) {
  let index = text.indexOf(searchText);
  
  while (index !== -1) {
    const from = basePos + index;
    const to = from + (isTruncated 
      ? Math.min(searchText.length + 20, text.length - index)
      : searchText.length);
    
    positions.push({ from, to });
    
    // Look for next occurrence
    index = text.indexOf(searchText, index + 1);
  }
}

function searchInParagraph(doc, searchText, paragraphIndex, positions, isTruncated) {
  let currentPara = 0;
  let found = false;

  doc.descendants((node, pos) => {
    if (found) return false;

    if (node.type.name === 'paragraph' || node.type.name === 'heading') {
      if (currentPara === paragraphIndex) {
        const text = node.textContent;
        findTextInNode(text, searchText, pos + 1, positions, isTruncated);
        found = true;
        return false;
      }
      currentPara++;
    }
  });
}

function searchInDocument(doc, searchText, positions, isTruncated) {
  doc.descendants((node, pos) => {
    if (node.isText) {
      const text = node.text;
      findTextInNode(text, searchText, pos, positions, isTruncated);
    } else if (node.type.name === 'paragraph' || node.type.name === 'heading') {
      // For block nodes, search their text content
      const text = node.textContent;
      if (text.includes(searchText)) {
        findTextInNode(text, searchText, pos + 1, positions, isTruncated);
      }
    }
  });
}

function findIssuePositions(doc, issue) {
  const positions = [];
  
  // Skip document-level issues without specific text
  if (issue.location?.type === 'document' && !issue.highlightText && !issue.text) {
    return positions;
  }
  
  // Determine search text
  let searchText = issue.highlightText || issue.text || '';
  if (!searchText || searchText.length < 2) {
    return positions;
  }
  
  // Handle truncated text
  const isTruncated = searchText.endsWith('...');
  if (isTruncated) {
    searchText = searchText.slice(0, -3).trim();
  }
  
  // Search strategy based on location
  if (issue.location?.paragraphIndex !== undefined) {
    // Search in specific paragraph
    searchInParagraph(doc, searchText, issue.location.paragraphIndex, positions, isTruncated);
  } else {
    // Search entire document
    searchInDocument(doc, searchText, positions, isTruncated);
  }
  
  return positions;
}

function getHighlightClass(severity, isActive) {
  const classes = ['apa-issue'];
  
  switch (severity) {
    case 'Critical':
      classes.push('apa-critical');
      if (isActive) classes.push('apa-active');
      break;
    case 'Major':
      classes.push('apa-major');
      if (isActive) classes.push('apa-active');
      break;
    case 'Minor':
      classes.push('apa-minor');
      if (isActive) classes.push('apa-active');
      break;
    default:
      classes.push('apa-default');
  }
  
  return classes.join(' ');
}

function createDecorations(doc, issues, activeIssueId, showHighlighting) {
  if (!showHighlighting || !issues || issues.length === 0) {
    return DecorationSet.empty;
  }

  const decorations = [];
  
  issues.forEach(issue => {
    try {
      const positions = findIssuePositions(doc, issue);
      
      positions.forEach(({ from, to }) => {
        const isActive = issue.id === activeIssueId;
        const className = getHighlightClass(issue.severity, isActive);
        
        const decoration = Decoration.inline(from, to, {
          class: className,
          nodeName: 'span',
          'data-issue-id': issue.id,
          'data-severity': issue.severity,
          'title': `${issue.severity} issue: ${issue.title || 'APA compliance issue'} • Ctrl+click to select`
        }, {
          issueId: issue.id,
          severity: issue.severity,
          inclusiveStart: false,
          inclusiveEnd: false
        });
        
        decorations.push(decoration);
      });
    } catch (error) {
      console.warn(`Failed to highlight issue ${issue.id}:`, error);
    }
  });
  
  // Sort decorations by position to avoid conflicts
  decorations.sort((a, b) => a.from - b.from);
  
  return DecorationSet.create(doc, decorations);
}

export const IssueHighlighter = Extension.create({
  name: 'issueHighlighter',

  addOptions() {
    return {
      issues: [],
      activeIssueId: null,
      showHighlighting: true,
      onIssueClick: null
    };
  },

  addProseMirrorPlugins() {
    const extension = this;

    return [
      new Plugin({
        key: highlighterKey,
        
        state: {
          init(_, state) {
            return {
              decorations: DecorationSet.empty,
              issues: extension.options.issues || []
            };
          },
          
          apply(tr, value, oldState, newState) {
            // Check for meta updates
            const meta = tr.getMeta(highlighterKey);
            
            if (meta?.updateHighlights) {
              // Rebuild decorations with new issues
              const decorations = createDecorations(
                newState.doc,
                meta.issues || extension.options.issues,
                meta.activeIssueId !== undefined ? meta.activeIssueId : extension.options.activeIssueId,
                meta.showHighlighting !== undefined ? meta.showHighlighting : extension.options.showHighlighting
              );
              return {
                decorations,
                issues: meta.issues || value.issues
              };
            }
            
            // Map decorations through document changes
            if (tr.docChanged) {
              return {
                decorations: value.decorations.map(tr.mapping, tr.doc),
                issues: value.issues
              };
            }
            
            return value;
          }
        },
        
        props: {
          decorations(state) {
            return this.getState(state)?.decorations || DecorationSet.empty;
          },
          
          handleClick(view, pos, event) {
            const target = event.target;

            // Check if clicked on a highlighted issue
            if (target && target.classList && target.classList.contains('apa-issue')) {
              const issueId = target.getAttribute('data-issue-id');

              // Only handle issue click if Ctrl/Cmd key is pressed
              // This allows normal editing when clicking without modifier keys
              if (issueId && extension.options.onIssueClick && (event.ctrlKey || event.metaKey)) {
                extension.options.onIssueClick(issueId);
                return true; // Consume the event only for Ctrl+click
              }

              // For normal clicks, let the editor handle it normally (return false/undefined)
              // This allows text selection and editing within highlighted text
            }
            
            // Check decorations at position
            const state = highlighterKey.getState(view.state);
            if (state?.decorations) {
              const decorations = state.decorations.find(pos, pos);
              if (decorations.length > 0) {
                const decoration = decorations[0];
                const issueId = decoration.spec?.issueId;

                // Only handle issue click if Ctrl/Cmd key is pressed
                if (issueId && extension.options.onIssueClick && (event.ctrlKey || event.metaKey)) {
                  extension.options.onIssueClick(issueId);
                  return true; // Consume the event only for Ctrl+click
                }

                // For normal clicks, allow normal editing behavior
              }
            }
            
            return false;
          }
        }
      })
    ];
  },

  addCommands() {
    return {
      updateIssueHighlights: (options = {}) => ({ tr, dispatch }) => {
        if (dispatch) {
          tr.setMeta(highlighterKey, {
            updateHighlights: true,
            ...options
          });
        }
        return true;
      },
      
      clearIssueHighlights: () => ({ tr, dispatch }) => {
        if (dispatch) {
          tr.setMeta(highlighterKey, {
            updateHighlights: true,
            issues: [],
            showHighlighting: false
          });
        }
        return true;
      },
      
      setActiveIssue: (issueId) => ({ tr, dispatch }) => {
        if (dispatch) {
          tr.setMeta(highlighterKey, {
            updateHighlights: true,
            activeIssueId: issueId
          });
        }
        return true;
      }
    };
  }
});

