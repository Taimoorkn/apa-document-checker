// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  /* Modern color palette */
  --primary: #6366f1;
  --primary-dark: #4f46e5;
  --primary-light: #818cf8;
  --secondary: #06b6d4;
  --secondary-dark: #0891b2;
  --accent: #8b5cf6;
  --success: #10b981;
  --error: #f43f5e;
  --warning: #f59e0b;
  --info: #3b82f6;
  
  /* Neutral colors */
  --background: #ffffff;
  --surface: #f8fafc;
  --surface-hover: #f1f5f9;
  --border: #e2e8f0;
  --border-light: #f1f5f9;
  --text: #0f172a;
  --text-secondary: #475569;
  --text-muted: #94a3b8;
  
  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --shadow-xl: 0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);
  
  /* Spacing */
  --radius: 0.75rem;
  --radius-sm: 0.5rem;
  --radius-lg: 1rem;
}

/* Base styling */
body {
  color: var(--text);
  background: linear-gradient(to bottom right, #f8fafc, #e0e7ff);
  min-height: 100vh;
}

/* Typography */
h1, h2, h3, h4, h5 {
  font-family: 'Inter', sans-serif;
}

body {
  font-family: 'Roboto', sans-serif;
}

/* APA styling for document viewer */
.prose {
  font-family: 'Times New Roman', Times, serif;
  max-width: none;
}

/* Issue highlighting styles */
mark[data-issue-id] {
  border-radius: 2px;
  cursor: pointer;
  padding: 0 1px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

mark[data-issue-id]::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform 0.3s ease;
}

mark[data-issue-id]:hover::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

.bg-red-200 {
  background-color: rgba(254, 202, 202, 0.7);
  border-bottom: 2px solid var(--error);
}

.bg-red-200:hover {
  background-color: rgba(254, 202, 202, 0.9);
}

.bg-red-200::after {
  background-color: var(--error);
}

.bg-orange-200 {
  background-color: rgba(254, 215, 170, 0.7);
  border-bottom: 2px solid var(--warning);
}

.bg-orange-200:hover {
  background-color: rgba(254, 215, 170, 0.9);
}

.bg-orange-200::after {
  background-color: var(--warning);
}

.bg-blue-200 {
  background-color: rgba(191, 219, 254, 0.7);
  border-bottom: 2px solid var(--primary);
}

.bg-blue-200:hover {
  background-color: rgba(191, 219, 254, 0.9);
}

.bg-blue-200::after {
  background-color: var(--primary);
}

/* Active issue highlighting */
.active-issue {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  animation: pulse 2s infinite;
}

/* Custom animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
  100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes progress {
  0% { width: 0%; }
  100% { width: 100%; }
}

/* Animation utilities (fallback for older Tailwind versions) */
.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 0.3s ease-out forwards;
}

.animate-pulse-blue {
  animation: pulse 2s infinite;
}

.animate-progress {
  animation: progress 2s ease-out infinite;
}

/* Apply animations to components */
.issue-category {
  animation: fadeIn 0.4s ease-out;
}

.issue-item {
  animation: slideIn 0.3s ease-out;
}

/* Staggered animations for issue items */
.issue-item:nth-child(1) { animation-delay: 0.05s; }
.issue-item:nth-child(2) { animation-delay: 0.1s; }
.issue-item:nth-child(3) { animation-delay: 0.15s; }
.issue-item:nth-child(4) { animation-delay: 0.2s; }
.issue-item:nth-child(5) { animation-delay: 0.25s; }

/* Custom utility classes */
.hover-shadow:hover {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-grow:hover {
  transform: scale(1.02);
}

/* Loading spinner */
.loading-spinner {
  border: 3px solid rgba(99, 102, 241, 0.1);
  border-radius: 50%;
  border-top: 3px solid var(--primary);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
}

/* Modern button styles */
.btn-primary {
  @apply bg-gradient-to-r from-indigo-500 to-indigo-600 text-white font-medium px-5 py-2.5 rounded-lg shadow-md hover:shadow-lg transform transition-all duration-200 hover:-translate-y-0.5 active:translate-y-0;
}

.btn-secondary {
  @apply bg-white text-gray-700 font-medium px-5 py-2.5 rounded-lg border border-gray-200 shadow-sm hover:shadow-md hover:bg-gray-50 transform transition-all duration-200 hover:-translate-y-0.5 active:translate-y-0;
}

.btn-success {
  @apply bg-gradient-to-r from-emerald-500 to-emerald-600 text-white font-medium px-4 py-2 rounded-lg shadow-sm hover:shadow-md transform transition-all duration-200 hover:-translate-y-0.5;
}

.btn-danger {
  @apply bg-gradient-to-r from-rose-500 to-rose-600 text-white font-medium px-4 py-2 rounded-lg shadow-sm hover:shadow-md transform transition-all duration-200 hover:-translate-y-0.5;
}

/* Card styles */
.card {
  @apply bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden transition-all duration-200 hover:shadow-md;
}

.card-header {
  @apply px-6 py-4 bg-gradient-to-r from-gray-50 to-gray-100 border-b border-gray-100;
}

.card-body {
  @apply p-6;
}

/* Modern input styles */
.input-modern {
  @apply w-full px-4 py-2.5 bg-white border border-gray-200 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent transition-all duration-200 text-gray-700 placeholder-gray-400;
}

/* Glass morphism effects */
.glass {
  @apply bg-white bg-opacity-70 backdrop-blur-lg border border-white border-opacity-20;
}

.glass-dark {
  @apply bg-gray-900 bg-opacity-70 backdrop-blur-lg border border-gray-700 border-opacity-20;
}

/* APA Document Base Styling */
.apa-document {
  max-width: 100%;
  overflow-wrap: break-word;
  /* font-family removed to preserve original document fonts */
}

.apa-document h1,
.apa-document h2,
.apa-document h3,
.apa-document h4,
.apa-document h5,
.apa-document h6 {
  text-indent: 0;
}

.apa-document strong,
.apa-document b {
  font-weight: bold;
}

.apa-document em,
.apa-document i {
  font-style: italic;
}

.apa-document u {
  text-decoration: underline;
}

/* References section specific styling */
.apa-document .hanging-indent {
  padding-left: 0.5in;
  text-indent: -0.5in;
}



/* Slate.js Editor Enhancements */
.slate-editor {
  @apply apa-document;
  color: #000;
}

/* Force exact pt values without browser conversion */
.slate-editor * {
  font-family: unset;
  font-size: unset !important;
}

/* Ensure pt units are preserved exactly as specified */
.slate-editor [style*="font-size"] {
  font-size: inherit !important;
}

/* Force 1:1 pt rendering */
.slate-editor {
  font-size-adjust: none;
  -webkit-text-size-adjust: none;
  text-size-adjust: none;
}

/* APA Issue Highlighting in Editor */
.active-issue {
  box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.3);
  border-radius: 2px;
}

/* Issue severity styles for editor */
mark[data-issue-id] {
  cursor: pointer;
  padding: 1px 2px;
  border-radius: 2px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}


/* Editor focus styles */
[data-slate-editor="true"] {
  outline: none;
}

[data-slate-editor="true"]:focus-within {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  border-radius: 4px;
}



// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\layout.js
import './globals.css'
import ErrorBoundary from '@/components/ErrorBoundary'

export const metadata = {
  title: 'APA 7th Edition Document Checker',
  description: 'Validate academic documents against APA 7th edition guidelines',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
      </head>
      <body className="font-sans antialiased text-gray-800 bg-gray-50">
        <ErrorBoundary showDetails={process.env.NODE_ENV === 'development'}>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\page.js
'use client';
import './globals.css';
import { useState } from 'react'; 
import IssuesPanel from '@/components/IssuesPanel';
import Header from '@/components/Header'; 
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import DocumentEditor from '@/components/DocumentEditor';

export default function Home() {
  const [splitRatio, setSplitRatio] = useState(60);
  const [isDragging, setIsDragging] = useState(false);
  const { documentText, issues } = useDocumentStore();

  return (
    <main className="flex flex-col h-screen bg-gradient-to-br from-gray-50 via-white to-indigo-50">
      <Header />
      
      <div className="flex-1 flex overflow-hidden relative">
        {/* Document Viewer (left panel) */}
        <div 
          className="relative bg-white shadow-xl border-r border-gray-100 transition-all duration-300"
          style={{ width: `${splitRatio}%` }}
        >
          <DocumentEditor />
        </div>
        
        {/* Modern Resize Handle */}
        <div 
          className={`w-1.5 cursor-col-resize relative group transition-all duration-200 ${
            isDragging ? 'bg-indigo-500 shadow-lg shadow-indigo-500/50' : 'bg-gray-200 hover:bg-indigo-400 hover:shadow-lg hover:shadow-indigo-400/30'
          }`}
          onMouseDown={(e) => {
            setIsDragging(true);
            const startX = e.clientX;
            const startWidth = splitRatio;
            
            const handleMouseMove = (moveEvent) => {
              const containerWidth = document.body.clientWidth;
              const newWidth = startWidth + ((moveEvent.clientX - startX) / containerWidth * 100);
              
              // Constrain between 35% and 75%
              const constrainedWidth = Math.max(35, Math.min(75, newWidth));
              setSplitRatio(constrainedWidth);
            };
            
            const handleMouseUp = () => {
              setIsDragging(false);
              document.removeEventListener('mousemove', handleMouseMove);
              document.removeEventListener('mouseup', handleMouseUp);
              document.body.style.cursor = 'default';
              document.body.style.userSelect = 'auto';
            };
            
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
          }}
        >
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-10">
            <div className={`flex flex-col space-y-1.5 px-1 py-3 rounded-full transition-all duration-200 ${
              isDragging ? 'bg-indigo-500 opacity-100' : 'bg-gray-400 opacity-0 group-hover:opacity-100'
            }`}>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
              <div className="w-1 h-1 bg-white rounded-full"></div>
            </div>
          </div>
        </div>
        
        {/* Issues Panel (right panel) */}
        <div 
          className="bg-white shadow-xl border-l border-gray-100 transition-all duration-300"
          style={{ width: `${100 - splitRatio}%` }}
        >
          <IssuesPanel />
        </div>
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\DocumentEditor.js
'use client';

import { useState, useCallback, useMemo, useRef, useEffect } from 'react';
import { createEditor, Editor, Transforms, Text, Element as SlateElement, Range } from 'slate';
import { Slate, Editable, withReact, ReactEditor } from 'slate-react';
import { withHistory } from 'slate-history';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import { 
  FileText, 
  InfoIcon, 
  CheckCircle2, 
  Play, 
  Eye, 
  EyeOff, 
  FileSearch, 
  Sparkles, 
  AlertCircle,
  Bold,
  Italic,
  Underline,
  Undo,
  Redo
} from 'lucide-react';

// Custom Slate.js element types for APA document structure
const ELEMENT_TYPES = {
  PARAGRAPH: 'paragraph',
  HEADING_1: 'heading-1',
  HEADING_2: 'heading-2',
  HEADING_3: 'heading-3',
  HEADING_4: 'heading-4',
  HEADING_5: 'heading-5',
  TITLE: 'title',
  CITATION: 'citation'
};

// Custom Slate.js marks for text formatting
const MARKS = {
  BOLD: 'bold',
  ITALIC: 'italic',
  UNDERLINE: 'underline',
  APA_ISSUE: 'apa-issue'
};

export default function DocumentEditor() {
  const { 
    documentText, 
    documentHtml, 
    activeIssueId, 
    issues, 
    setActiveIssue, 
    lastFixAppliedAt, 
    processingState, 
    documentFormatting,
    currentDocumentBuffer,
    analyzeDocument,
    showIssueHighlighting,
    toggleIssueHighlighting
  } = useDocumentStore();
  
  // Editor state
  const [editor] = useState(() => withHistory(withReact(createEditor())));
  const [value, setValue] = useState([{
    type: 'paragraph',
    children: [{ text: '' }]
  }]); // Default empty paragraph to prevent Slate errors
  
  // Refs for components
  const editorRef = useRef(null);
  
  const isLoading = processingState.isUploading || processingState.isAnalyzing;

  // Initialize editor content from document data - ONLY for server updates
  useEffect(() => {
    if (documentText && documentFormatting) {
      if (process.env.NODE_ENV === 'development') {
        console.log('=== DOCUMENT FORMATTING DEBUG ===');
        console.log('Raw document formatting from server:', documentFormatting);
        console.log('lastFixAppliedAt:', lastFixAppliedAt);
      }
      
      const newValue = convertTextToSlateNodes(documentText, documentFormatting);
      
      // Update in these cases:
      // 1. Initial load (value has only empty paragraph)
      // 2. A fix was recently applied (lastFixAppliedAt changed)
      const isInitialState = value.length === 1 && 
        value[0]?.type === 'paragraph' && 
        value[0]?.children?.length === 1 && 
        value[0]?.children[0]?.text === '';
      
      const shouldUpdate = isInitialState || lastFixAppliedAt;
      
      if (shouldUpdate) {
        console.log('🔄 Updating Slate editor with server data');
        console.log('Reasons:', {
          initialLoad: isInitialState,
          fixApplied: !!lastFixAppliedAt
        });
        
        // Force Slate to re-render by creating completely new value
        const freshValue = JSON.parse(JSON.stringify(newValue));
        setValue(freshValue);
      }
    }
  }, [documentText, documentFormatting, lastFixAppliedAt]);



  // Convert document with rich formatting data to Slate nodes
  const convertTextToSlateNodes = useCallback((text, formatting) => {
    console.log('🔄 convertTextToSlateNodes called with:', {
      hasText: !!text,
      hasFormatting: !!formatting,
      paragraphCount: formatting?.paragraphs?.length || 0
    });

    if (!formatting?.paragraphs?.length) {
      const fallback = [{ type: ELEMENT_TYPES.PARAGRAPH, children: [{ text: text || '' }] }];
      console.log('📄 Using fallback Slate nodes:', fallback);
      return fallback;
    }


    // Use ONLY the paragraph text from formatting data - ignore the raw text parameter
    const result = formatting.paragraphs.map((paraFormatting, index) => {
      
      // Determine paragraph type based on style and content
      const paraType = determineParagraphType(paraFormatting.text, paraFormatting);
      
      // Create children with rich formatting from runs
      let children = [];
      
      if (paraFormatting.runs && paraFormatting.runs.length > 0) {
        // Use run-level formatting for precise text formatting
        children = [];
        paraFormatting.runs.forEach((run, runIndex) => {
          
          const runText = run.text || '';
          
          // Handle line breaks within runs by splitting into multiple text nodes
          if (runText.includes('\n')) {
            const parts = runText.split('\n');
            parts.forEach((part, partIndex) => {
              if (partIndex > 0) {
                // Add line break between parts
                children.push({ text: '\n' });
              }
              if (part) {
                const leafNode = {
                  text: part,
                  bold: run.font?.bold === true,
                  italic: run.font?.italic === true,
                  underline: run.font?.underline === true,
                  fontFamily: run.font?.family || null,
                  fontSize: run.font?.size || null,
                  color: run.color || null
                };
                children.push(leafNode);
              }
            });
          } else {
            const leafNode = {
              text: runText,
              bold: run.font?.bold === true,
              italic: run.font?.italic === true,
              underline: run.font?.underline === true,
              fontFamily: run.font?.family || null,
              fontSize: run.font?.size || null,
              color: run.color || null
            };
            children.push(leafNode);
          }
        });
      } else {
        // Fallback to paragraph text if no runs
        const paraText = paraFormatting.text || '';
        if (paraText.includes('\n')) {
          // Handle line breaks in paragraph text
          const parts = paraText.split('\n');
          children = [];
          parts.forEach((part, partIndex) => {
            if (partIndex > 0) {
              children.push({ text: '\n' });
            }
            if (part) {
              children.push({ 
                text: part,
                fontFamily: paraFormatting.font?.family || null,
                fontSize: paraFormatting.font?.size || null
              });
            }
          });
        } else {
          children = [{ 
            text: paraText,
            fontFamily: paraFormatting.font?.family || null,
            fontSize: paraFormatting.font?.size || null
          }];
        }
      }
      
      // Ensure we have at least one child
      if (children.length === 0) {
        children = [{ text: '' }];
      }
      
      return {
        type: paraType,
        children: children,
        paraIndex: index,
        // Preserve complete formatting data including spacing, indentation, alignment
        formatting: {
          font: paraFormatting.font,
          spacing: paraFormatting.spacing,
          indentation: paraFormatting.indentation,
          alignment: paraFormatting.alignment,
          style: paraFormatting.style
        }
      };
    });
    
    // Safety check to ensure we never return undefined or empty array
    if (!Array.isArray(result) || result.length === 0) {
      console.warn('⚠️ convertTextToSlateNodes produced invalid result, using fallback');
      return [{ type: ELEMENT_TYPES.PARAGRAPH, children: [{ text: text || '' }] }];
    }
    
    console.log('✅ convertTextToSlateNodes produced', result.length, 'nodes');
    return result;
  }, []);

  // Determine paragraph type based on content and formatting
  const determineParagraphType = useCallback((text, formatting) => {
    // Check for headings based on Word styles first (most reliable)
    if (formatting?.style) {
      const style = formatting.style.toLowerCase();
      if (style.includes('title')) return ELEMENT_TYPES.TITLE;
      if (style.includes('heading1') || style === 'heading 1') return ELEMENT_TYPES.HEADING_1;
      if (style.includes('heading2') || style === 'heading 2') return ELEMENT_TYPES.HEADING_2;
      if (style.includes('heading3') || style === 'heading 3') return ELEMENT_TYPES.HEADING_3;
      if (style.includes('heading4') || style === 'heading 4') return ELEMENT_TYPES.HEADING_4;
      if (style.includes('heading5') || style === 'heading 5') return ELEMENT_TYPES.HEADING_5;
      if (style.includes('heading6') || style === 'heading 6') return ELEMENT_TYPES.HEADING_5; // Map H6 to H5
    }
    
    // All other content is treated as regular paragraphs
    return ELEMENT_TYPES.PARAGRAPH;
  }, []);

  // Apply issue highlighting to Slate editor
  const applyIssueHighlighting = useCallback(() => {
    if (!issues.length || !editor) return;

    // Remove existing highlights
    Editor.removeMark(editor, MARKS.APA_ISSUE);

    issues.forEach(issue => {
      if (!issue.text) return;

      // Find text in editor and apply highlighting
      try {
        const [match] = Editor.nodes(editor, {
          at: [],
          match: n => Text.isText(n) && n.text && n.text.includes(issue.text)
        });

        if (match) {
          const [node, path] = match;
          const text = node.text;
          const index = text.indexOf(issue.text);

          if (index !== -1) {
            const range = {
              anchor: { path, offset: index },
              focus: { path, offset: index + issue.text.length }
            };

            Transforms.select(editor, range);
            Editor.addMark(editor, MARKS.APA_ISSUE, {
              issueId: issue.id,
              severity: issue.severity,
              active: issue.id === activeIssueId
            });
          }
        }
      } catch (error) {
        console.warn('Error highlighting issue in editor:', error);
      }
    });

    // Deselect after highlighting
    Transforms.deselect(editor);
  }, [editor, issues, activeIssueId]);

  // Remove all issue highlighting from Slate editor
  const removeIssueHighlighting = useCallback(() => {
    if (!editor) return;

    console.log('🧹 Removing all issue highlights from editor');
    
    try {
      // Use Editor.withoutNormalizing to batch all operations
      Editor.withoutNormalizing(editor, () => {
        // Get all nodes with APA_ISSUE marks
        const allNodes = Array.from(Editor.nodes(editor, {
          at: [],
          match: n => Text.isText(n) && n[MARKS.APA_ISSUE],
          mode: 'all'
        }));

        console.log(`🧹 Found ${allNodes.length} nodes with issue highlighting`);

        // Remove marks in reverse order to avoid path conflicts
        allNodes.reverse().forEach(([node, path]) => {
          try {
            // Check if path still exists before trying to unset
            if (Editor.hasPath(editor, path) && Text.isText(node) && node[MARKS.APA_ISSUE]) {
              Transforms.unsetNodes(editor, MARKS.APA_ISSUE, {
                at: path,
                match: n => Text.isText(n)
              });
            }
          } catch (error) {
            console.warn('Error removing highlight at path:', path, error);
          }
        });
      });

      console.log(`🧹 Successfully removed all issue highlighting`);
    } catch (error) {
      console.error('Error in removeIssueHighlighting:', error);
      // If all else fails, regenerate the editor content without highlights
      console.log('🔄 Regenerating editor content to clear highlights');
      if (documentText && documentFormatting) {
        const newValue = convertTextToSlateNodes(documentText, documentFormatting);
        setValue(newValue);
      }
    }
  }, [editor, convertTextToSlateNodes]); // Remove documentText, documentFormatting from deps

  // Apply or remove issue highlighting when state changes
  useEffect(() => {
    // Skip highlighting during loading
    if (isLoading) {
      console.log('🎨 Skipping issue highlighting - loading');
      return;
    }

    // Apply highlighting when toggled or after fixes are applied
    if (value.length > 0) {
      if (showIssueHighlighting) {
        console.log('🎨 Applying issue highlighting to Slate editor');
        setTimeout(() => applyIssueHighlighting(), 100); // Delayed to prevent render conflicts
      } else {
        console.log('🎨 Removing issue highlighting from Slate editor');
        setTimeout(() => removeIssueHighlighting(), 100);
      }
    }
  }, [showIssueHighlighting, lastFixAppliedAt, isLoading, applyIssueHighlighting, removeIssueHighlighting]);

  // Cleanup function (no timeouts to clean up now)
  useEffect(() => {
    return () => {
      // Cleanup if needed
    };
  }, []);

  // Get CSS class for issue highlighting
  const getIssueClass = useCallback((severity) => {
    const baseClass = 'cursor-pointer border-b-2 transition-all duration-200';
    switch (severity) {
      case 'Critical':
        return `${baseClass} bg-red-200 border-red-500 hover:bg-red-300`;
      case 'Major':
        return `${baseClass} bg-orange-200 border-orange-500 hover:bg-orange-300`;
      case 'Minor':
        return `${baseClass} bg-blue-200 border-blue-500 hover:bg-blue-300`;
      default:
        return baseClass;
    }
  }, []);

  // Extract current formatting from Slate editor
  const extractCurrentFormatting = useCallback((slateValue) => {
    console.log('📊 Extracting current formatting from Slate editor...');
    
    // Analyze the actual formatting in the editor to detect issues
    let detectedFontFamily = null;
    let detectedFontSize = null;
    let detectedSpacing = null;
    let fontFamilyConsistent = true;
    let fontSizeConsistent = true;
    
    // Create a fresh formatting object based on current Slate content
    const paragraphs = slateValue.map((node, index) => {
      const paragraphText = node.children?.map(child => child.text || '').join('') || '';
      
      // Extract formatting from Slate node - DON'T use defaults, use actual values
      const formatting = node.formatting || {};
      const firstChild = node.children?.[0] || {};
      
      // Extract actual font properties from the node
      const actualFontFamily = firstChild.fontFamily || formatting.font?.family || null;
      const actualFontSize = firstChild.fontSize || formatting.font?.size || null;
      
      // Track detected fonts across document
      if (actualFontFamily) {
        if (!detectedFontFamily) {
          detectedFontFamily = actualFontFamily;
        } else if (detectedFontFamily !== actualFontFamily) {
          fontFamilyConsistent = false;
        }
      }
      
      if (actualFontSize) {
        if (!detectedFontSize) {
          detectedFontSize = actualFontSize;
        } else if (detectedFontSize !== actualFontSize) {
          fontSizeConsistent = false;
        }
      }
      
      return {
        text: paragraphText,
        index: index,
        font: {
          family: actualFontFamily, // Use actual font, not default
          size: actualFontSize      // Use actual size, not default
        },
        spacing: formatting.spacing || { line: detectedSpacing || 1.0 }, // Don't assume double spacing
        indentation: formatting.indentation || { firstLine: 0 }, // Don't assume correct indentation
        alignment: formatting.alignment || 'left',
        style: formatting.style || 'Normal',
        runs: node.children?.map(child => ({
          text: child.text || '',
          font: {
            family: child.fontFamily || actualFontFamily, // Use detected font
            size: child.fontSize || actualFontSize,       // Use detected size
            bold: child.bold || false,
            italic: child.italic || false,
            underline: child.underline || false
          },
          color: child.color || null
        })) || []
      };
    });

    console.log('📊 Detected formatting:', {
      fontFamily: detectedFontFamily,
      fontSize: detectedFontSize,
      fontFamilyConsistent,
      fontSizeConsistent
    });

    // Create document-level formatting based on detected values (not assumptions)
    const documentFormatting = {
      document: {
        font: { 
          family: detectedFontFamily,  // Use detected, not assumed
          size: detectedFontSize       // Use detected, not assumed
        },
        spacing: { line: detectedSpacing || 1.0 }, // Don't assume double spacing
        margins: { top: 1.0, bottom: 1.0, left: 1.0, right: 1.0 }, // These we can assume
        indentation: { firstLine: 0.0 } // Don't assume correct indentation
      },
      paragraphs: paragraphs,
      compliance: {
        overall: 50, // Lower base score to allow issues to be detected
        font: { 
          family: detectedFontFamily === 'Times New Roman',
          size: detectedFontSize === 12
        },
        spacing: { line: detectedSpacing === 2.0 },
        margins: { compliant: true } // Assume margins are correct for now
      }
    };

    console.log('📊 Generated formatting object for analysis:', {
      documentFont: documentFormatting.document.font,
      compliance: documentFormatting.compliance,
      paragraphCount: paragraphs.length
    });

    return documentFormatting;
  }, []);

  // Handle manual analysis trigger
  const handleManualAnalysis = useCallback(async () => {
    const { analyzeEditorContent, documentFormatting } = useDocumentStore.getState();
    
    if (analyzeEditorContent && !isLoading && value.length > 0) {
      console.log('🔍 Running manual analysis on current editor content');
      
      try {
        // Try to extract current formatting from Slate editor
        const extractedFormatting = extractCurrentFormatting(value);
        
        // Merge extracted formatting with original document formatting
        // This preserves original formatting (like spacing) while allowing font changes to be detected
        let currentFormatting = documentFormatting;
        
        if (extractedFormatting.document.font.family || extractedFormatting.document.font.size) {
          // User has made font changes, use hybrid approach
          currentFormatting = {
            ...documentFormatting,
            document: {
              ...documentFormatting.document,
              font: {
                family: extractedFormatting.document.font.family || documentFormatting.document?.font?.family,
                size: extractedFormatting.document.font.size || documentFormatting.document?.font?.size
              }
            },
            paragraphs: extractedFormatting.paragraphs.map((extractedPara, index) => {
              const originalPara = documentFormatting.paragraphs?.[index] || {};
              return {
                ...originalPara,
                text: extractedPara.text, // Use current text
                font: {
                  family: extractedPara.font.family || originalPara.font?.family,
                  size: extractedPara.font.size || originalPara.font?.size
                },
                // Preserve original spacing, margins, etc.
                spacing: originalPara.spacing || { line: 2.0 },
                indentation: originalPara.indentation || { firstLine: 0.5 },
                alignment: originalPara.alignment || 'left'
              };
            })
          };
        }
        
        console.log('📊 Using formatting for analysis:', {
          paragraphCount: currentFormatting.paragraphs?.length || 0,
          hasFormatting: !!currentFormatting,
          source: 'hybrid-current-original',
          fontFamily: currentFormatting.document?.font?.family,
          fontSize: currentFormatting.document?.font?.size,
          spacing: currentFormatting.document?.spacing?.line
        });

        // Analyze current editor state with the hybrid formatting
        await analyzeEditorContent(value, currentFormatting);
        console.log('✅ Manual analysis completed');
      } catch (error) {
        console.error('❌ Manual analysis failed:', error);
      }
    }
  }, [value, isLoading, extractCurrentFormatting]);

  // Handle editor value changes (NO automatic analysis)
  const handleEditorChange = useCallback((newValue) => {
    setValue(newValue);
    // NO automatic analysis, NO isUserEditing flag changes
    // Keep it simple - just update the editor content
  }, []);

  // Keyboard shortcut for Run Check (Ctrl/Cmd + Shift + C)
  useEffect(() => {
    const handleKeyDown = (event) => {
      if ((event.ctrlKey || event.metaKey) && event.shiftKey && event.key === 'C') {
        event.preventDefault();
        handleManualAnalysis();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [handleManualAnalysis]);

  // Listen for text replacement events from store
  useEffect(() => {
    const handleTextReplacement = (event) => {
      const { originalText, replacementText, issueId } = event.detail;
      
      console.log(`🔧 DocumentEditor received text replacement request:`, {
        originalText,
        replacementText,
        issueId
      });
      
      // Apply the text replacement directly in the Slate editor
      applyTextReplacementToEditor(originalText, replacementText);
    };

    window.addEventListener('applyTextReplacement', handleTextReplacement);
    return () => window.removeEventListener('applyTextReplacement', handleTextReplacement);
  }, []);

  // Apply text replacement directly in Slate editor
  const applyTextReplacementToEditor = useCallback((originalText, replacementText) => {
    try {
      console.log(`🔍 Searching for text in editor: "${originalText}"`);
      
      // Search through all text nodes in the editor
      const textNodes = Array.from(Editor.nodes(editor, {
        at: [],
        match: n => Text.isText(n) && n.text.includes(originalText),
        mode: 'all'
      }));

      console.log(`🔍 Found ${textNodes.length} matching text nodes`);

      if (textNodes.length > 0) {
        Editor.withoutNormalizing(editor, () => {
          // Replace text in each matching node (process in reverse order to avoid path conflicts)
          textNodes.reverse().forEach(([node, path]) => {
            if (Text.isText(node) && node.text.includes(originalText)) {
              const nodeText = node.text;
              const startIndex = nodeText.indexOf(originalText);
              
              if (startIndex !== -1) {
                const endIndex = startIndex + originalText.length;
                
                // Create range for the specific text to replace
                const startPoint = { path, offset: startIndex };
                const endPoint = { path, offset: endIndex };
                const range = { anchor: startPoint, focus: endPoint };
                
                // Select the range and replace the text
                Transforms.select(editor, range);
                Transforms.insertText(editor, replacementText);
                
                // Clear any issue highlighting marks from the replaced text
                const newEndPoint = { path, offset: startIndex + replacementText.length };
                const newRange = { anchor: startPoint, focus: newEndPoint };
                
                // Remove issue highlighting marks from the new text
                Transforms.unsetNodes(editor, [MARKS.APA_ISSUE], {
                  at: newRange,
                  match: n => Text.isText(n)
                });
                
                console.log(`✅ Replaced "${originalText}" with "${replacementText}" at path:`, path);
                console.log(`📍 Range: ${startIndex}-${endIndex} in text: "${nodeText}"`);
                console.log(`🧹 Cleared highlighting from new text range`);
              }
            }
          });
        });
        
        // Force re-render by updating value
        const currentValue = editor.children;
        setValue([...currentValue]);
        
        // Also trigger a full highlighting refresh after a short delay
        // This ensures any stale highlighting is cleaned up
        setTimeout(() => {
          console.log('🧹 Refreshing issue highlighting after fix');
          removeIssueHighlighting();
          setTimeout(() => {
            if (showIssueHighlighting) {
              applyIssueHighlighting();
            }
          }, 100);
        }, 50);
        
      } else {
        console.warn(`⚠️ Could not find text "${originalText}" in editor`);
      }
      
    } catch (error) {
      console.error('Error applying text replacement to editor:', error);
    }
  }, [editor, showIssueHighlighting, removeIssueHighlighting, applyIssueHighlighting]);

  // Custom rendering for different element types
  const renderElement = useCallback((props) => {
    const { attributes, children, element } = props;
    
    // Extract formatting from element when available
    const formatting = element.formatting || {};
    
    // Build comprehensive style object from extracted formatting
    const baseStyle = {};
    
    // Font properties (paragraph-level defaults)
    if (formatting.font?.family) {
      baseStyle.fontFamily = `"${formatting.font.family}", serif`;
    }
    if (formatting.font?.size) {
      // Force exact pixel size to match Word display
      baseStyle.fontSize = `${formatting.font.size}px`;
    }
    
    // Line spacing - use the exact value from the server
    if (formatting.spacing?.line) {
      // Use the line height value directly as the server should have converted it properly
      baseStyle.lineHeight = formatting.spacing.line;
    }
    
    // Paragraph spacing (before/after)
    if (formatting.spacing?.before) {
      baseStyle.marginTop = `${formatting.spacing.before}pt`;
    }
    if (formatting.spacing?.after) {
      baseStyle.marginBottom = `${formatting.spacing.after}pt`;
    }
    
    // Text indentation
    if (formatting.indentation?.firstLine) {
      baseStyle.textIndent = `${formatting.indentation.firstLine}in`;
    }
    if (formatting.indentation?.left) {
      baseStyle.paddingLeft = `${formatting.indentation.left}in`;
    }
    if (formatting.indentation?.right) {
      baseStyle.paddingRight = `${formatting.indentation.right}in`;
    }
    if (formatting.indentation?.hanging) {
      baseStyle.textIndent = `-${formatting.indentation.hanging}in`;
      baseStyle.paddingLeft = `${formatting.indentation.hanging}in`;
    }
    
    // Text alignment
    if (formatting.alignment) {
      const alignmentMap = {
        'left': 'left',
        'center': 'center', 
        'right': 'right',
        'both': 'justify',
        'justify': 'justify'
      };
      baseStyle.textAlign = alignmentMap[formatting.alignment] || formatting.alignment;
    }
    
    // Debug: Add data attributes to paragraphs for inspection
    const debugAttrs = {};
    if (formatting.font?.size) {
      debugAttrs['data-debug-para-font-size'] = formatting.font.size;
    }
    if (formatting.font?.family) {
      debugAttrs['data-debug-para-font-family'] = formatting.font.family;
    }
    
    switch (element.type) {
      case ELEMENT_TYPES.TITLE:
        return (
          <h1 
            {...attributes} 
            {...debugAttrs}
            style={baseStyle}
          >
            {children}
          </h1>
        );
      case ELEMENT_TYPES.HEADING_1:
        return (
          <h1 
            {...attributes} 
            {...debugAttrs}
            style={baseStyle}
          >
            {children}
          </h1>
        );
      case ELEMENT_TYPES.HEADING_2:
        return (
          <h2 
            {...attributes} 
            {...debugAttrs}
            style={baseStyle}
          >
            {children}
          </h2>
        );
      case ELEMENT_TYPES.HEADING_3:
        return (
          <h3 
            {...attributes} 
            {...debugAttrs}
            style={baseStyle}
          >
            {children}
          </h3>
        );
      default:
        return (
          <p 
            {...attributes} 
            {...debugAttrs}
            style={baseStyle}
          >
            {children}
          </p>
        );
    }
  }, []);

  // Custom rendering for text marks with rich formatting support
  const renderLeaf = useCallback((props) => {
    const { attributes, children, leaf } = props;
    
    // Build inline styles for font properties
    const leafStyle = {};
    const leafProps = { ...attributes };
    
    // Use a combination of inline styles and CSS class for better specificity
    if (leaf.fontFamily) {
      leafStyle.fontFamily = `"${leaf.fontFamily}", serif`;
    }
    if (leaf.fontSize) {
      // Force exact pixel size to match Word display (28pt should display as 28px equivalent)
      leafStyle.fontSize = `${leaf.fontSize}px`;
      leafProps.className = `${leafProps.className || ''} docx-original-formatting`.trim();
    }
    if (leaf.color) {
      leafStyle.color = leaf.color.startsWith('#') ? leaf.color : `#${leaf.color}`;
    }
    
    let element = <span {...leafProps} style={leafStyle}>{children}</span>;

    if (leaf.bold) {
      element = <strong style={leafStyle}>{element}</strong>;
    }
    if (leaf.italic) {
      element = <em style={leafStyle}>{element}</em>;
    }
    if (leaf.underline) {
      element = <u style={leafStyle}>{element}</u>;
    }
    if (leaf[MARKS.APA_ISSUE]) {
      const issueData = leaf[MARKS.APA_ISSUE];
      element = (
        <mark
          className={`${getIssueClass(issueData.severity)} ${issueData.active ? 'active-issue' : ''}`}
          data-issue-id={issueData.issueId}
          onClick={() => setActiveIssue(issueData.issueId)}
          title="APA issue detected - click for details"
          style={leafStyle}
        >
          {element}
        </mark>
      );
    }

    return element;
  }, [getIssueClass, setActiveIssue]);


  // Ensure we have valid Slate value
  const safeValue = Array.isArray(value) && value.length > 0 ? value : [{
    type: 'paragraph',
    children: [{ text: '' }]
  }];

  if (!documentText) {
    return (
      <div className="h-full flex flex-col items-center justify-center bg-gradient-to-br from-indigo-50 via-white to-purple-50 p-8">
        <div className="text-center max-w-lg">
          <div className="relative inline-block mb-8">
            <div className="w-28 h-28 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-3xl mx-auto flex items-center justify-center shadow-2xl transform rotate-3 hover:rotate-6 transition-transform duration-300">
              <FileText className="h-14 w-14 text-white transform -rotate-3" />
            </div>
            <div className="absolute -bottom-2 -right-2 w-8 h-8 bg-emerald-500 rounded-full flex items-center justify-center border-4 border-white shadow-lg">
              <Sparkles className="h-4 w-4 text-white" />
            </div>
          </div>
          
          <h2 className="text-3xl font-bold bg-gradient-to-r from-gray-900 to-gray-600 bg-clip-text text-transparent mb-4">
            Ready to Perfect Your Document
          </h2>
          <p className="text-gray-600 mb-10 text-lg leading-relaxed">
            Upload your academic paper to start editing with intelligent APA 7th edition validation
          </p>
          
          <div className="grid gap-4 max-w-md mx-auto">
            <div className="bg-white/80 backdrop-blur rounded-2xl p-5 border border-gray-100 shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
              <div className="flex items-center space-x-4">
                <div className="w-12 h-12 bg-gradient-to-br from-blue-500 to-blue-600 rounded-xl flex items-center justify-center flex-shrink-0">
                  <CheckCircle2 className="h-6 w-6 text-white" />
                </div>
                <div className="text-left">
                  <p className="font-semibold text-gray-900">Real-time Validation</p>
                  <p className="text-sm text-gray-600 mt-0.5">Instant APA compliance checking as you edit</p>
                </div>
              </div>
            </div>
            
            <div className="bg-white/80 backdrop-blur rounded-2xl p-5 border border-gray-100 shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
              <div className="flex items-center space-x-4">
                <div className="w-12 h-12 bg-gradient-to-br from-purple-500 to-purple-600 rounded-xl flex items-center justify-center flex-shrink-0">
                  <FileSearch className="h-6 w-6 text-white" />
                </div>
                <div className="text-left">
                  <p className="font-semibold text-gray-900">Smart Issue Detection</p>
                  <p className="text-sm text-gray-600 mt-0.5">Automatically finds and highlights APA violations</p>
                </div>
              </div>
            </div>
            
            <div className="bg-white/80 backdrop-blur rounded-2xl p-5 border border-gray-100 shadow-lg hover:shadow-xl transition-all duration-300 hover:-translate-y-1">
              <div className="flex items-center space-x-4">
                <div className="w-12 h-12 bg-gradient-to-br from-emerald-500 to-emerald-600 rounded-xl flex items-center justify-center flex-shrink-0">
                  <Sparkles className="h-6 w-6 text-white" />
                </div>
                <div className="text-left">
                  <p className="font-semibold text-gray-900">One-Click Fixes</p>
                  <p className="text-sm text-gray-600 mt-0.5">Apply automated corrections with confidence</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {isLoading ? (
        <div className="flex-1 flex flex-col items-center justify-center bg-gray-50 p-8">
          <div className="bg-white rounded-2xl p-8 shadow-sm border border-gray-200 flex flex-col items-center">
            <div className="loading-spinner mb-6"></div>
            <h3 className="text-lg font-semibold text-gray-900 mb-2">Processing Document</h3>
            <p className="text-sm text-gray-500 text-center max-w-sm">
              Analyzing your document with enhanced XML processing...
            </p>
          </div>
        </div>
      ) : (
        <div className="h-full flex flex-col">
          {/* Document Controls - Fixed Header */}
          <div className="bg-white border-b border-gray-200 flex-shrink-0">
            {/* Top Bar with Title and Actions */}
            <div className="px-6 py-4 border-b border-gray-100">
              <div className="flex justify-between items-center">
                <div className="flex items-center space-x-4">
                  <h3 className="text-lg font-semibold text-gray-900">Document Editor</h3>
                  {lastFixAppliedAt && (
                    <span className="inline-flex items-center px-2.5 py-1 rounded-full text-xs font-medium bg-green-100 text-green-800">
                      <div className="w-1.5 h-1.5 bg-green-400 rounded-full mr-1.5"></div>
                      Recently Updated
                    </span>
                  )}
                </div>
                <div className="flex items-center space-x-3">
                  {/* Run APA Check Button */}
                  <button 
                    onClick={handleManualAnalysis}
                    disabled={isLoading || processingState.isAnalyzing}
                    title="Run APA analysis on current document (Ctrl+Shift+C)"
                    className={`flex items-center space-x-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                      isLoading || processingState.isAnalyzing
                        ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                    }`}
                  >
                    {processingState.isAnalyzing ? (
                      <>
                        <div className="loading-spinner w-4 h-4"></div>
                        <span>Checking...</span>
                      </>
                    ) : (
                      <>
                        <CheckCircle2 className="h-4 w-4" />
                        <span>Run Check</span>
                      </>
                    )}
                  </button>
                  
                  {/* Show/Hide Issues Button */}
                  <button 
                    onClick={() => toggleIssueHighlighting()}
                    className={`flex items-center space-x-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
                      showIssueHighlighting 
                        ? 'bg-amber-100 text-amber-700 hover:bg-amber-200' 
                        : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                    }`}
                  >
                    {showIssueHighlighting ? (
                      <>
                        <EyeOff className="h-4 w-4" />
                        <span>Hide Issues</span>
                      </>
                    ) : (
                      <>
                        <Eye className="h-4 w-4" />
                        <span>Show Issues</span>
                      </>
                    )}
                  </button>
                  
                  {/* Issue Count */}
                  {issues.length > 0 && (
                    <div className="flex items-center space-x-2 px-3 py-1.5 bg-gray-50 rounded-lg border border-gray-200">
                      <AlertCircle className="h-4 w-4 text-gray-500" />
                      <span className="text-sm text-gray-600">
                        {issues.length} {issues.length === 1 ? 'issue' : 'issues'}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            </div>
            
            {/* Formatting Toolbar */}
            <div className="px-6 py-2 flex items-center space-x-1 bg-gray-50">
              {/* Undo/Redo */}
              <div className="flex items-center space-x-1 pr-3 border-r border-gray-200">
                <button 
                  className="p-2 text-gray-600 hover:bg-gray-100 rounded transition-colors"
                  title="Undo"
                  onClick={() => console.log('Undo clicked - not implemented')}
                >
                  <Undo className="h-4 w-4" />
                </button>
                <button 
                  className="p-2 text-gray-600 hover:bg-gray-100 rounded transition-colors"
                  title="Redo"
                  onClick={() => console.log('Redo clicked - not implemented')}
                >
                  <Redo className="h-4 w-4" />
                </button>
              </div>
              
              {/* Text Formatting */}
              <div className="flex items-center space-x-1 px-3">
                <button 
                  className={`p-2 rounded transition-colors ${
                    editor.marks?.bold ? 'bg-indigo-100 text-indigo-700' : 'text-gray-600 hover:bg-gray-100'
                  }`}
                  title="Bold"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    const isActive = editor.marks?.bold;
                    if (isActive) {
                      Editor.removeMark(editor, 'bold');
                    } else {
                      Editor.addMark(editor, 'bold', true);
                    }
                  }}
                >
                  <Bold className="h-4 w-4" />
                </button>
                <button 
                  className={`p-2 rounded transition-colors ${
                    editor.marks?.italic ? 'bg-indigo-100 text-indigo-700' : 'text-gray-600 hover:bg-gray-100'
                  }`}
                  title="Italic"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    const isActive = editor.marks?.italic;
                    if (isActive) {
                      Editor.removeMark(editor, 'italic');
                    } else {
                      Editor.addMark(editor, 'italic', true);
                    }
                  }}
                >
                  <Italic className="h-4 w-4" />
                </button>
                <button 
                  className={`p-2 rounded transition-colors ${
                    editor.marks?.underline ? 'bg-indigo-100 text-indigo-700' : 'text-gray-600 hover:bg-gray-100'
                  }`}
                  title="Underline"
                  onMouseDown={(e) => {
                    e.preventDefault();
                    const isActive = editor.marks?.underline;
                    if (isActive) {
                      Editor.removeMark(editor, 'underline');
                    } else {
                      Editor.addMark(editor, 'underline', true);
                    }
                  }}
                >
                  <Underline className="h-4 w-4" />
                </button>
              </div>
            </div>
          </div>

          {/* Document Content - Scrollable Area */}
          <div className="flex-1 overflow-auto bg-gray-50">
            <div className="p-6">
              <div className="mx-auto">
                {/* Document Editor */}
                <div 
                  className="bg-white rounded-lg shadow-sm border border-gray-200 p-8 min-h-[500px]"
                >
                  <div
                    ref={editorRef}
                  >
                    <Slate 
                      key={`slate-editor-${lastFixAppliedAt || 'initial'}`}
                      editor={editor} 
                      initialValue={safeValue}
                      onValueChange={handleEditorChange}
                    >
                      <Editable
                        renderElement={renderElement}
                        renderLeaf={renderLeaf}
                        placeholder="Start writing your APA document..."
                        className="min-h-96 outline-none"
                        data-slate-editor="true"
                      />
                    </Slate>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ErrorBoundary.js
'use client';

import { Component } from 'react';
import { AlertTriangle } from 'lucide-react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // You can log the error to an error reporting service
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
    this.setState({
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <div className="flex flex-col items-center justify-center p-6 bg-red-50 border border-red-200 rounded-lg shadow-sm text-center">
          <div className="bg-red-100 p-3 rounded-full mb-4">
            <AlertTriangle className="h-8 w-8 text-red-500" />
          </div>
          <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-sm text-red-600 mb-4">
            {this.state.error ? this.state.error.toString() : 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
          >
            Reload Page
          </button>
          {this.props.showDetails && this.state.errorInfo && (
            <div className="mt-6 w-full">
              <details className="text-left">
                <summary className="text-sm font-medium text-red-800 cursor-pointer">Error Details</summary>
                <pre className="mt-2 p-3 text-xs text-red-800 bg-red-100 overflow-auto rounded-md">
                  {this.state.errorInfo.componentStack}
                </pre>
              </details>
            </div>
          )}
        </div>
      );
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\Header.js
'use client';

import { useState, useEffect, useRef } from 'react';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import { 
  Upload, 
  Download, 
  FileText, 
  ChevronDown, 
  CheckCircle, 
  Sparkles,
  FileCheck,
  X,
  AlertCircle,
  User,
  Settings,
  LogOut,
  HelpCircle,
  Bell,
  CreditCard,
  Menu,
  Plus,
  History,
  Share2
} from 'lucide-react';

export default function Header() {
  const { 
    uploadDocument, 
    documentName, 
    analyzeDocument, 
    analyzeDocumentDebounced, 
    analysisScore, 
    exportDocument, 
    processingState,
    issues
  } = useDocumentStore();
  
  const [uploadError, setUploadError] = useState(null);
  const [showExportDropdown, setShowExportDropdown] = useState(false);
  const [showUserDropdown, setShowUserDropdown] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [showSuccessToast, setShowSuccessToast] = useState(false);
  const exportDropdownRef = useRef(null);
  const userDropdownRef = useRef(null);
  const fileInputRef = useRef(null);

  // Close dropdowns when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (exportDropdownRef.current && !exportDropdownRef.current.contains(event.target)) {
        setShowExportDropdown(false);
      }
      if (userDropdownRef.current && !userDropdownRef.current.contains(event.target)) {
        setShowUserDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Show success toast when document is uploaded
  useEffect(() => {
    if (documentName && !processingState.isUploading) {
      setShowSuccessToast(true);
      setTimeout(() => setShowSuccessToast(false), 3000);
    }
  }, [documentName, processingState.isUploading]);
  
  const handleFileUpload = async (e) => {
    setUploadError(null);
    
    const file = e.target.files[0];
    if (!file) return;
    
    if (!file.name.endsWith('.docx')) {
      setUploadError('Please upload a .docx file only');
      return;
    }
    
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      setUploadError(`File size exceeds limit (max ${maxSize / (1024 * 1024)}MB)`);
      return;
    }
    
    try {
      const success = await uploadDocument(file);
      
      if (success) {
        const analysisResult = await analyzeDocumentDebounced();
        
        if (!analysisResult?.success && analysisResult?.error) {
          setUploadError(`Analysis error: ${analysisResult.error}`);
        }
      } else {
        if (!processingState.lastError) {
          setUploadError('Failed to process document. Please try a different file.');
        }
      }
    } catch (error) {
      console.error('Error in file upload handler:', error);
      setUploadError(`Error: ${error.message || 'Failed to upload document'}`);
    } finally {
      e.target.value = '';
    }
  };

  const handleExport = async (format) => {
    setIsExporting(true);
    setShowExportDropdown(false);
    
    try {
      await exportDocument(format);
    } catch (error) {
      console.error('Export failed:', error);
      alert(`Failed to export ${format.toUpperCase()} document. Please try again.`);
    } finally {
      setIsExporting(false);
    }
  };
  
  return (
    <>
      <header className="h-16 bg-white border-b border-gray-200 sticky top-0 z-50">
        <div className="h-full px-4 flex items-center justify-between">
          {/* Left Section - Logo and Primary Actions */}
          <div className="flex items-center space-x-4">
            {/* Logo */}
            <div className="flex items-center space-x-3">
              <div className="w-9 h-9 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-lg flex items-center justify-center shadow-md">
                <FileCheck className="h-5 w-5 text-white" />
              </div>
              <span className="text-lg font-bold text-gray-900">APA Checker</span>
            </div>

            {/* Divider */}
            <div className="h-8 w-px bg-gray-200"></div>

            {/* Primary Actions */}
            <div className="flex items-center space-x-2">
              {/* New Document */}
              <button 
                onClick={() => fileInputRef.current?.click()}
                disabled={processingState.isUploading || processingState.isAnalyzing}
                className="flex items-center space-x-2 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
                title="Upload new document"
              >
                <Plus className="h-4 w-4" />
                <span>New</span>
              </button>

              <input
                ref={fileInputRef}
                type="file"
                accept=".docx"
                className="hidden"
                onChange={handleFileUpload}
                disabled={processingState.isUploading || processingState.isAnalyzing}
              />

              {/* Recent Documents */}
              <button 
                className="flex items-center space-x-2 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
                title="Recent documents"
              >
                <History className="h-4 w-4" />
                <span>Recent</span>
              </button>

              {/* Share */}
              {documentName && (
                <button 
                  className="flex items-center space-x-2 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
                  title="Share document"
                >
                  <Share2 className="h-4 w-4" />
                  <span>Share</span>
                </button>
              )}

              {/* Export */}
              {documentName && (
                <div className="relative" ref={exportDropdownRef}>
                  <button 
                    className="flex items-center space-x-2 px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
                    onClick={() => setShowExportDropdown(!showExportDropdown)}
                    disabled={isExporting}
                  >
                    <Download className="h-4 w-4" />
                    <span>{isExporting ? 'Exporting...' : 'Export'}</span>
                    <ChevronDown className={`h-3 w-3 transition-transform ${showExportDropdown ? 'rotate-180' : ''}`} />
                  </button>

                  {showExportDropdown && (
                    <div className="absolute left-0 top-full mt-1 w-48 bg-white rounded-lg shadow-lg border border-gray-200 overflow-hidden">
                      <button
                        onClick={() => handleExport('html')}
                        className="flex items-center w-full px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
                        disabled={isExporting}
                      >
                        <FileText className="h-4 w-4 mr-3 text-orange-500" />
                        <span>Export as HTML</span>
                      </button>
                      <button
                        onClick={() => handleExport('docx')}
                        className="flex items-center w-full px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition-colors"
                        disabled={isExporting}
                      >
                        <FileText className="h-4 w-4 mr-3 text-blue-500" />
                        <span>Export as DOCX</span>
                      </button>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>

          {/* Right Section - Secondary Actions and User Menu */}
          <div className="flex items-center space-x-3">
            {/* Help */}
            <button 
              className="p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
              title="Help & Support"
            >
              <HelpCircle className="h-5 w-5" />
            </button>

            {/* Notifications */}
            <button 
              className="relative p-2 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded-lg transition-colors"
              title="Notifications"
            >
              <Bell className="h-5 w-5" />
              {/* Notification badge */}
              <span className="absolute top-1.5 right-1.5 w-2 h-2 bg-red-500 rounded-full"></span>
            </button>

            {/* Divider */}
            <div className="h-8 w-px bg-gray-200"></div>

            {/* User Menu */}
            <div className="relative" ref={userDropdownRef}>
              <button 
                onClick={() => setShowUserDropdown(!showUserDropdown)}
                className="flex items-center space-x-2 px-3 py-1.5 hover:bg-gray-100 rounded-lg transition-colors"
              >
                <div className="w-8 h-8 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-full flex items-center justify-center">
                  <span className="text-sm font-medium text-white">JD</span>
                </div>
                <div className="text-left hidden md:block">
                  <p className="text-sm font-medium text-gray-900">John Doe</p>
                  <p className="text-xs text-gray-500">Free Plan</p>
                </div>
                <ChevronDown className={`h-4 w-4 text-gray-500 transition-transform ${showUserDropdown ? 'rotate-180' : ''}`} />
              </button>

              {/* User Dropdown Menu */}
              {showUserDropdown && (
                <div className="absolute right-0 top-full mt-1 w-64 bg-white rounded-lg shadow-lg border border-gray-200 overflow-hidden">
                  {/* User Info */}
                  <div className="px-4 py-3 border-b border-gray-100">
                    <p className="text-sm font-medium text-gray-900">John Doe</p>
                    <p className="text-xs text-gray-500">john.doe@example.com</p>
                  </div>

                  {/* Menu Items */}
                  <div className="py-1">
                    <button className="flex items-center w-full px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition-colors">
                      <User className="h-4 w-4 mr-3 text-gray-400" />
                      <span>Profile</span>
                    </button>
                    <button className="flex items-center w-full px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition-colors">
                      <Settings className="h-4 w-4 mr-3 text-gray-400" />
                      <span>Settings</span>
                    </button>
                    <button className="flex items-center w-full px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition-colors">
                      <CreditCard className="h-4 w-4 mr-3 text-gray-400" />
                      <span>Billing & Plans</span>
                      <span className="ml-auto px-2 py-0.5 text-xs bg-indigo-100 text-indigo-700 rounded-full">Free</span>
                    </button>
                  </div>

                  {/* Divider */}
                  <div className="border-t border-gray-100"></div>

                  {/* Logout */}
                  <div className="py-1">
                    <button className="flex items-center w-full px-4 py-2.5 text-sm text-gray-700 hover:bg-gray-50 transition-colors">
                      <LogOut className="h-4 w-4 mr-3 text-gray-400" />
                      <span>Log out</span>
                    </button>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      </header>

      {/* Error Alert */}
      {uploadError && (
        <div className="fixed top-20 right-6 z-50 animate-slide-in">
          <div className="bg-white rounded-lg shadow-lg border border-rose-100 p-4 flex items-start space-x-3 max-w-md">
            <div className="flex-shrink-0">
              <AlertCircle className="h-5 w-5 text-rose-500" />
            </div>
            <div className="flex-1">
              <p className="text-sm font-medium text-gray-900">Upload Error</p>
              <p className="text-sm text-gray-600 mt-1">{uploadError}</p>
            </div>
            <button
              onClick={() => setUploadError(null)}
              className="flex-shrink-0 ml-4 text-gray-400 hover:text-gray-600"
            >
              <X className="h-4 w-4" />
            </button>
          </div>
        </div>
      )}

      {/* Success Toast */}
      {showSuccessToast && (
        <div className="fixed top-20 right-6 z-50 animate-slide-in">
          <div className="bg-white rounded-lg shadow-lg border border-emerald-100 p-4 flex items-center space-x-3">
            <CheckCircle className="h-5 w-5 text-emerald-500" />
            <p className="text-sm font-medium text-gray-900">Document uploaded successfully!</p>
          </div>
        </div>
      )}
    </>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\IssuesPanel.js
'use client';

import { useState, useMemo, useCallback } from 'react';
import { useDocumentStore } from '@/store/enhancedDocumentStore';
import React from 'react';
import { 
  ClipboardList, 
  AlertTriangle, 
  AlertCircle, 
  AlertOctagon, 
  TrendingUp,
  Check,
  ChevronDown,
  FileText,
  Info,
  Zap,
  BarChart3,
  Activity,
  Target,
  Award,
  BookOpen,
  FileSearch,
  CheckCircle2,
  XCircle,
  Clock,
  Sparkles
} from 'lucide-react';

export default function IssuesPanel() {
  const { 
    issues, 
    activeIssueId, 
    setActiveIssue, 
    applyFix, 
    processingState,
    documentFormatting,
    documentStats,
    analysisScore
  } = useDocumentStore();
  
  const [expandedCategories, setExpandedCategories] = useState({
    Critical: true,
    Major: true,
    Minor: false
  });
  
  const [activeTab, setActiveTab] = useState('issues'); // 'issues' or 'stats'
  
  // Group issues by severity
  const groupedIssues = useMemo(() => {
    return (issues || []).reduce((acc, issue) => {
      if (!acc[issue.severity]) {
        acc[issue.severity] = [];
      }
      acc[issue.severity].push(issue);
      return acc;
    }, {});
  }, [issues]);
  
  // Count issues by severity
  const issueCounts = useMemo(() => ({
    Critical: groupedIssues.Critical?.length || 0,
    Major: groupedIssues.Major?.length || 0,
    Minor: groupedIssues.Minor?.length || 0
  }), [groupedIssues]);
  
  const totalIssues = issueCounts.Critical + issueCounts.Major + issueCounts.Minor;
  
  // Toggle category expansion
  const toggleCategory = useCallback((category) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  }, []);
  
  return (
    <div className="h-full bg-gradient-to-br from-gray-50 via-white to-indigo-50 flex flex-col">
      {/* Header with Tabs */}
      <div className="bg-white/95 backdrop-blur-sm border-b border-gray-200 px-6 py-4">
        <div className="flex justify-between items-center mb-4">
          <div className="flex items-center space-x-3">
            <div className="w-10 h-10 bg-gradient-to-br from-indigo-500 to-purple-600 rounded-xl flex items-center justify-center shadow-lg">
              <ClipboardList className="h-5 w-5 text-white" />
            </div>
            <div>
              <h2 className="text-lg font-bold text-gray-900">Analysis Panel</h2>
              <p className="text-xs text-gray-500">APA 7th Edition Compliance</p>
            </div>
          </div>
          
          {/* Compliance Badge */}
          {analysisScore !== null && (
            <div className={`px-4 py-2 rounded-xl font-semibold text-sm ${
              analysisScore >= 80 ? 'bg-gradient-to-r from-emerald-50 to-emerald-100 text-emerald-700 border border-emerald-200' :
              analysisScore >= 60 ? 'bg-gradient-to-r from-amber-50 to-amber-100 text-amber-700 border border-amber-200' :
              'bg-gradient-to-r from-rose-50 to-rose-100 text-rose-700 border border-rose-200'
            }`}>
              {analysisScore >= 80 ? '✨ Excellent' : analysisScore >= 60 ? '⚡ Good' : '🎯 Needs Work'}
            </div>
          )}
        </div>
        
        {/* Tab Navigation */}
        <div className="flex space-x-2">
          <button
            onClick={() => setActiveTab('issues')}
            className={`flex items-center space-x-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
              activeTab === 'issues'
                ? 'bg-gradient-to-r from-indigo-500 to-indigo-600 text-white shadow-lg'
                : 'bg-white text-gray-600 hover:bg-gray-50 border border-gray-200'
            }`}
          >
            <AlertCircle className="h-4 w-4" />
            <span>Issues ({totalIssues})</span>
          </button>
          <button
            onClick={() => setActiveTab('stats')}
            className={`flex items-center space-x-2 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-200 ${
              activeTab === 'stats'
                ? 'bg-gradient-to-r from-indigo-500 to-indigo-600 text-white shadow-lg'
                : 'bg-white text-gray-600 hover:bg-gray-50 border border-gray-200'
            }`}
          >
            <BarChart3 className="h-4 w-4" />
            <span>Statistics</span>
          </button>
        </div>
      </div>
      
      {/* Content Area */}
      <div className="flex-1 overflow-auto">
        {activeTab === 'issues' ? (
          <div className="p-6">
            {totalIssues > 0 ? (
              <div className="space-y-4">
                {/* Quick Stats Cards */}
                <div className="grid grid-cols-3 gap-3 mb-6">
                  {issueCounts.Critical > 0 && (
                    <div className="bg-gradient-to-br from-rose-50 to-rose-100 rounded-xl p-4 border border-rose-200">
                      <div className="flex items-center justify-between mb-2">
                        <AlertOctagon className="h-5 w-5 text-rose-600" />
                        <span className="text-2xl font-bold text-rose-700">{issueCounts.Critical}</span>
                      </div>
                      <p className="text-xs font-medium text-rose-600">Critical Issues</p>
                    </div>
                  )}
                  {issueCounts.Major > 0 && (
                    <div className="bg-gradient-to-br from-amber-50 to-amber-100 rounded-xl p-4 border border-amber-200">
                      <div className="flex items-center justify-between mb-2">
                        <AlertTriangle className="h-5 w-5 text-amber-600" />
                        <span className="text-2xl font-bold text-amber-700">{issueCounts.Major}</span>
                      </div>
                      <p className="text-xs font-medium text-amber-600">Major Issues</p>
                    </div>
                  )}
                  {issueCounts.Minor > 0 && (
                    <div className="bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl p-4 border border-blue-200">
                      <div className="flex items-center justify-between mb-2">
                        <Info className="h-5 w-5 text-blue-600" />
                        <span className="text-2xl font-bold text-blue-700">{issueCounts.Minor}</span>
                      </div>
                      <p className="text-xs font-medium text-blue-600">Minor Issues</p>
                    </div>
                  )}
                </div>
                
                {/* Issue Categories */}
                {issueCounts.Critical > 0 && (
                  <IssueCategory 
                    title="Critical Issues" 
                    count={issueCounts.Critical} 
                    severity="Critical"
                    expanded={expandedCategories.Critical}
                    toggleExpanded={() => toggleCategory('Critical')}
                  >
                    {expandedCategories.Critical && groupedIssues.Critical.map(issue => (
                      <IssueItem 
                        key={issue.id}
                        issue={issue}
                        isActive={activeIssueId === issue.id}
                        onSelect={() => setActiveIssue(issue.id)}
                        onApplyFix={() => applyFix(issue.id)}
                        isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                      />
                    ))}
                  </IssueCategory>
                )}
                
                {issueCounts.Major > 0 && (
                  <IssueCategory 
                    title="Major Issues" 
                    count={issueCounts.Major} 
                    severity="Major"
                    expanded={expandedCategories.Major}
                    toggleExpanded={() => toggleCategory('Major')}
                  >
                    {expandedCategories.Major && groupedIssues.Major.map(issue => (
                      <IssueItem 
                        key={issue.id}
                        issue={issue}
                        isActive={activeIssueId === issue.id}
                        onSelect={() => setActiveIssue(issue.id)}
                        onApplyFix={() => applyFix(issue.id)}
                        isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                      />
                    ))}
                  </IssueCategory>
                )}
                
                {issueCounts.Minor > 0 && (
                  <IssueCategory 
                    title="Minor Issues" 
                    count={issueCounts.Minor} 
                    severity="Minor"
                    expanded={expandedCategories.Minor}
                    toggleExpanded={() => toggleCategory('Minor')}
                  >
                    {expandedCategories.Minor && groupedIssues.Minor.map(issue => (
                      <IssueItem 
                        key={issue.id}
                        issue={issue}
                        isActive={activeIssueId === issue.id}
                        onSelect={() => setActiveIssue(issue.id)}
                        onApplyFix={() => applyFix(issue.id)}
                        isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                      />
                    ))}
                  </IssueCategory>
                )}
              </div>
            ) : issues.length === 0 ? (
              <div className="flex flex-col items-center justify-center py-20">
                <div className="w-20 h-20 bg-gradient-to-br from-gray-100 to-gray-200 rounded-2xl mb-6 flex items-center justify-center">
                  <FileText className="h-10 w-10 text-gray-400" />
                </div>
                <h3 className="text-lg font-semibold text-gray-900 mb-2">No Document Loaded</h3>
                <p className="text-gray-500 text-center max-w-sm">
                  Upload a document to check it against APA 7th Edition guidelines
                </p>
              </div>
            ) : (
              <div className="bg-gradient-to-br from-emerald-50 to-emerald-100 border border-emerald-200 rounded-2xl p-8">
                <div className="flex items-start space-x-4">
                  <div className="w-14 h-14 bg-gradient-to-br from-emerald-500 to-emerald-600 rounded-xl flex items-center justify-center flex-shrink-0 shadow-lg">
                    <Check className="h-7 w-7 text-white" />
                  </div>
                  <div>
                    <h3 className="text-xl font-bold text-emerald-900 mb-2">Perfect Compliance!</h3>
                    <p className="text-emerald-700 mb-1">
                      Your document meets all APA 7th Edition requirements.
                    </p>
                    <p className="text-sm text-emerald-600">
                      No formatting or citation issues detected.
                    </p>
                  </div>
                </div>
              </div>
            )}
          </div>
        ) : (
          <div className="p-6">
            {/* Statistics Tab Content */}
            <div className="space-y-6">
              {/* Compliance Score Card */}
              {analysisScore !== null && (
                <div className="bg-white rounded-2xl shadow-lg border border-gray-100 p-6">
                  <div className="flex items-center justify-between mb-6">
                    <h3 className="text-lg font-bold text-gray-900 flex items-center">
                      <Target className="h-5 w-5 mr-2 text-indigo-500" />
                      Compliance Score
                    </h3>
                    <div className={`px-3 py-1 rounded-full text-xs font-medium ${
                      analysisScore >= 80 ? 'bg-emerald-100 text-emerald-700' :
                      analysisScore >= 60 ? 'bg-amber-100 text-amber-700' :
                      'bg-rose-100 text-rose-700'
                    }`}>
                      {analysisScore >= 80 ? 'Excellent' : analysisScore >= 60 ? 'Good' : 'Needs Improvement'}
                    </div>
                  </div>
                  
                  <div className="flex items-center space-x-6">
                    <div className="relative">
                      <svg className="w-32 h-32 transform -rotate-90">
                        <circle
                          cx="64"
                          cy="64"
                          r="56"
                          stroke="#e5e7eb"
                          strokeWidth="12"
                          fill="none"
                        />
                        <circle
                          cx="64"
                          cy="64"
                          r="56"
                          stroke={analysisScore >= 80 ? '#10b981' : analysisScore >= 60 ? '#f59e0b' : '#f43f5e'}
                          strokeWidth="12"
                          fill="none"
                          strokeDasharray={`${(analysisScore / 100) * 351.86} 351.86`}
                          strokeLinecap="round"
                        />
                      </svg>
                      <div className="absolute inset-0 flex items-center justify-center">
                        <span className="text-3xl font-bold text-gray-900">{analysisScore}%</span>
                      </div>
                    </div>
                    
                    <div className="flex-1 space-y-3">
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-gray-600">Critical Issues</span>
                        <span className="text-sm font-semibold text-rose-600">{issueCounts.Critical}</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-gray-600">Major Issues</span>
                        <span className="text-sm font-semibold text-amber-600">{issueCounts.Major}</span>
                      </div>
                      <div className="flex items-center justify-between">
                        <span className="text-sm text-gray-600">Minor Issues</span>
                        <span className="text-sm font-semibold text-blue-600">{issueCounts.Minor}</span>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              
              {/* Document Statistics */}
              {documentStats && (
                <div className="bg-white rounded-2xl shadow-lg border border-gray-100 p-6">
                  <h3 className="text-lg font-bold text-gray-900 mb-4 flex items-center">
                    <Activity className="h-5 w-5 mr-2 text-indigo-500" />
                    Document Statistics
                  </h3>
                  
                  <div className="grid grid-cols-2 gap-4">
                    <div className="bg-gradient-to-br from-blue-50 to-blue-100 rounded-xl p-4 border border-blue-200">
                      <div className="flex items-center justify-between mb-2">
                        <BookOpen className="h-5 w-5 text-blue-600" />
                        <span className="text-2xl font-bold text-blue-700">{documentStats.wordCount}</span>
                      </div>
                      <p className="text-xs font-medium text-blue-600">Total Words</p>
                    </div>
                    
                    <div className="bg-gradient-to-br from-purple-50 to-purple-100 rounded-xl p-4 border border-purple-200">
                      <div className="flex items-center justify-between mb-2">
                        <FileText className="h-5 w-5 text-purple-600" />
                        <span className="text-2xl font-bold text-purple-700">{documentStats.paragraphCount}</span>
                      </div>
                      <p className="text-xs font-medium text-purple-600">Paragraphs</p>
                    </div>
                    
                    <div className="bg-gradient-to-br from-emerald-50 to-emerald-100 rounded-xl p-4 border border-emerald-200">
                      <div className="flex items-center justify-between mb-2">
                        <Zap className="h-5 w-5 text-emerald-600" />
                        <span className="text-2xl font-bold text-emerald-700">{documentStats.charCount}</span>
                      </div>
                      <p className="text-xs font-medium text-emerald-600">Characters</p>
                    </div>
                    
                    <div className="bg-gradient-to-br from-indigo-50 to-indigo-100 rounded-xl p-4 border border-indigo-200">
                      <div className="flex items-center justify-between mb-2">
                        <Clock className="h-5 w-5 text-indigo-600" />
                        <span className="text-2xl font-bold text-indigo-700">{Math.round(documentStats.wordCount / 200)}</span>
                      </div>
                      <p className="text-xs font-medium text-indigo-600">Min Read Time</p>
                    </div>
                  </div>
                </div>
              )}
              
              {/* Document Format Details */}
              {documentFormatting && (
                <div className="bg-white rounded-2xl shadow-lg border border-gray-100 p-6">
                  <h3 className="text-lg font-bold text-gray-900 mb-4 flex items-center">
                    <FileSearch className="h-5 w-5 mr-2 text-indigo-500" />
                    Format Analysis
                  </h3>
                  
                  <div className="space-y-3">
                    <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                      <span className="text-sm font-medium text-gray-600">Font Family</span>
                      <span className="text-sm font-semibold text-gray-900">
                        {documentFormatting.document?.font?.family || 'Not specified'}
                      </span>
                    </div>
                    <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                      <span className="text-sm font-medium text-gray-600">Font Size</span>
                      <span className="text-sm font-semibold text-gray-900">
                        {documentFormatting.document?.font?.size || 'Not specified'}pt
                      </span>
                    </div>
                    <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                      <span className="text-sm font-medium text-gray-600">Line Spacing</span>
                      <span className="text-sm font-semibold text-gray-900">
                        {documentFormatting.document?.spacing?.line || 'Not specified'}
                      </span>
                    </div>
                    <div className="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                      <span className="text-sm font-medium text-gray-600">Margins</span>
                      <span className="text-sm font-semibold text-gray-900">
                        {documentFormatting.document?.margins?.top || 'Not specified'}"
                      </span>
                    </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// Modern Issue Category Component
const IssueCategory = React.memo(function IssueCategory({ title, count, severity, expanded, toggleExpanded, children }) {
  const getStyles = () => {
    switch (severity) {
      case 'Critical': 
        return {
          gradient: 'from-rose-500 to-rose-600',
          bg: 'from-rose-50 to-rose-100',
          border: 'border-rose-200',
          text: 'text-rose-700',
          icon: <AlertOctagon className="h-5 w-5" />
        };
      case 'Major': 
        return {
          gradient: 'from-amber-500 to-amber-600',
          bg: 'from-amber-50 to-amber-100',
          border: 'border-amber-200',
          text: 'text-amber-700',
          icon: <AlertTriangle className="h-5 w-5" />
        };
      case 'Minor': 
        return {
          gradient: 'from-blue-500 to-blue-600',
          bg: 'from-blue-50 to-blue-100',
          border: 'border-blue-200',
          text: 'text-blue-700',
          icon: <Info className="h-5 w-5" />
        };
      default: 
        return {
          gradient: 'from-gray-500 to-gray-600',
          bg: 'from-gray-50 to-gray-100',
          border: 'border-gray-200',
          text: 'text-gray-700',
          icon: null
        };
    }
  };
  
  const styles = getStyles();
  
  return (
    <div className={`rounded-2xl overflow-hidden border ${styles.border} shadow-lg hover:shadow-xl transition-all duration-300`}>
      <button 
        onClick={toggleExpanded}
        className={`w-full flex justify-between items-center px-6 py-4 bg-gradient-to-r ${styles.bg} ${styles.text} transition-all duration-200 hover:opacity-90`}
      >
        <span className="font-semibold flex items-center text-base">
          <div className={`w-8 h-8 bg-gradient-to-br ${styles.gradient} rounded-lg flex items-center justify-center mr-3 text-white`}>
            {styles.icon}
          </div>
          {title}
        </span>
        <div className="flex items-center space-x-3">
          <span className={`px-3 py-1 bg-white rounded-full text-sm font-bold shadow-sm`}>
            {count}
          </span>
          <ChevronDown 
            className={`h-5 w-5 transition-transform duration-300 ${expanded ? 'rotate-180' : ''}`}
          />
        </div>
      </button>
      
      {expanded && (
        <div className="bg-white divide-y divide-gray-100">
          {children}
        </div>
      )}
    </div>
  );
});

// Modern Issue Item Component
const IssueItem = React.memo(function IssueItem({ 
  issue, 
  isActive, 
  onSelect, 
  onApplyFix,
  isApplyingFix = false
}) {
  return (
    <div 
      className={`px-6 py-5 hover:bg-gray-50 cursor-pointer transition-all duration-200 ${
        isActive ? 'bg-gradient-to-r from-indigo-50 to-purple-50 border-l-4 border-indigo-500' : ''
      }`}
      onClick={onSelect}
    >
      <div className="flex justify-between">
        <div className="flex-1 pr-4">
          <div className="flex items-start mb-2">
            <p className="text-sm font-semibold text-gray-900">{issue.title}</p>
          </div>
          <p className="text-xs text-gray-600 mb-3 leading-relaxed">{issue.description}</p>
          
          {issue.text && (
            <div className="mt-3 p-3 bg-gradient-to-r from-gray-50 to-gray-100 rounded-lg border border-gray-200">
              <p className="text-xs font-mono text-gray-700">"{issue.text}"</p>
            </div>
          )}
          
          {issue.explanation && (
            <div className="mt-3 p-3 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg border border-blue-200">
              <div className="flex items-start space-x-2">
                <Info className="h-3.5 w-3.5 text-blue-500 mt-0.5 flex-shrink-0" />
                <p className="text-xs text-blue-700">{issue.explanation}</p>
              </div>
            </div>
          )}
        </div>
        
        {issue.hasFix && (
          <div className="flex items-center">
            <button 
              onClick={(e) => {
                e.stopPropagation();
                if (!isApplyingFix) onApplyFix();
              }}
              disabled={isApplyingFix}
              className={`flex items-center space-x-2 px-4 py-2 rounded-xl text-xs font-medium transition-all duration-200 transform ${
                isApplyingFix 
                  ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
                  : 'bg-gradient-to-r from-emerald-500 to-emerald-600 text-white shadow-lg hover:shadow-xl hover:-translate-y-0.5 active:translate-y-0'
              }`}
            >
              {isApplyingFix ? (
                <>
                  <div className="loading-spinner w-3.5 h-3.5"></div>
                  <span>Fixing...</span>
                </>
              ) : (
                <>
                  <Sparkles className="h-3.5 w-3.5" />
                  <span>Apply Fix</span>
                </>
              )}
            </button>
          </div>
        )}
      </div>
    </div>
  );
});

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\store\enhancedDocumentStore.js
'use client';

import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

// Import the enhanced APA analyzer
import { EnhancedAPAAnalyzer } from '@/utils/enhancedApaAnalyzer';

export const useDocumentStore = create((set, get) => ({
  // Document state - now includes rich formatting data
  documentText: null,
  documentHtml: null,
  documentName: null,
  documentFormatting: null, // Rich formatting data from server
  documentStructure: null,  // Document structure data
  documentStyles: null,     // Document styles
  originalDocumentBuffer: null, // Original document buffer for first upload
  currentDocumentBuffer: null,  // Current document buffer (with applied fixes)
  
  // Editor state
  editorContent: null,      // Slate.js editor content
  editorChanged: false,     // Track if editor content has changed
  documentStats: {
    wordCount: 0,
    charCount: 0,
    paragraphCount: 0,
    processingTime: 0
  },
  
  // Issues and analysis state
  issues: [],
  activeIssueId: null,
  showIssueHighlighting: true, // Persist issue highlighting state
  analysisScore: null,
  complianceDetails: null, // Detailed compliance information
  lastFixAppliedAt: null,
  
  // Processing state
  processingState: {
    isUploading: false,
    isAnalyzing: false,
    isSchedulingAnalysis: false,
    isApplyingFix: false,
    lastError: null,
    progress: 0,
    currentFixId: null,
    stage: null
  },
  
  // Upload document with server-side processing
  uploadDocument: async (file) => {
    const SERVER_URL = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3001' 
      : '';
    
    try {
      set({
        processingState: {
          ...get().processingState,
          isUploading: true,
          lastError: null,
          progress: 10,
          stage: 'Uploading document...'
        }
      });
      
      // Validate file on client side
      if (!file.name.toLowerCase().endsWith('.docx')) {
        throw new Error('Please upload a .docx file only');
      }
      
      if (file.size > 10 * 1024 * 1024) { // 10MB
        throw new Error('File size must be less than 10MB');
      }
      
      // Store the original file buffer for fixes
      const fileBuffer = await file.arrayBuffer();
      const uint8Array = new Uint8Array(fileBuffer);
      
      // Create FormData for file upload
      const formData = new FormData();
      formData.append('document', file);
      
      set({
        documentName: file.name,
        processingState: {
          ...get().processingState,
          progress: 20,
          stage: 'Sending to server...'
        }
      });
      
      // Send to server for processing
      const response = await fetch(`${SERVER_URL}/api/upload-docx`, {
        method: 'POST',
        body: formData,
        // Don't set Content-Type header - let browser set it with boundary
      });
      
      set({
        processingState: {
          ...get().processingState,
          progress: 60,
          stage: 'Processing document...'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Server error: ${response.status}`);
      }
      
      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error || 'Server processing failed');
      }
      
      set({
        processingState: {
          ...get().processingState,
          progress: 80,
          stage: 'Extracting document data...'
        }
      });
      
      const { document: documentData } = result;
      
      // Validate that we got the expected data structure
      if (!documentData.html || !documentData.text) {
        console.warn('Incomplete document data from server:', documentData);
        throw new Error('Server returned incomplete document data');
      }
      
      // Calculate stats
      const words = documentData.processingInfo?.wordCount || 
                    documentData.text.trim().split(/\s+/).filter(Boolean).length;
      const chars = documentData.text.length;
      const paragraphs = documentData.formatting?.paragraphs?.length || 0;
      
      set({
        processingState: {
          ...get().processingState,
          progress: 90,
          stage: 'Finalizing...'
        }
      });
      
      // Store the rich document data including document buffers
      set(state => ({
        documentHtml: documentData.html,
        documentText: documentData.text,
        documentFormatting: documentData.formatting,
        documentStructure: documentData.structure,
        documentStyles: documentData.styles,
        originalDocumentBuffer: uint8Array, // Store original buffer
        currentDocumentBuffer: uint8Array,  // Initialize current buffer same as original
        documentStats: {
          wordCount: words,
          charCount: chars,
          paragraphCount: paragraphs,
          processingTime: documentData.processingInfo?.processingTime || 0
        },
        complianceDetails: documentData.formatting?.compliance || null,
        issues: [], // Clear previous issues
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          progress: 100,
          isUploading: false,
          stage: 'Upload complete'
        }
      }));
      
      // No automatic analysis - user must click "Run Check" button
      
      return true;
      
    } catch (error) {
      console.error('Error uploading document:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isUploading: false,
          lastError: error.message || 'Failed to process document',
          progress: 0,
          stage: null
        }
      }));
      
      return false;
    }
  },
  
  // Enhanced analysis using rich document data
  analyzeDocument: async () => {
    const { 
      documentText, 
      documentHtml, 
      documentFormatting, 
      documentStructure,
      documentStyles 
    } = get();
    
    if (!documentText) {
      return { success: false, error: 'No document data available' };
    }
    
    try {
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null,
          stage: 'Analyzing APA compliance...'
        }
      }));
      
      // Create comprehensive document data object
      const documentData = {
        text: documentText,
        html: documentHtml,
        formatting: documentFormatting,
        structure: documentStructure,
        styles: documentStyles
      };
      
      
      // Use enhanced analyzer with rich document data
      const analysisResults = await new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            const analyzer = new EnhancedAPAAnalyzer();
            const results = analyzer.analyzeDocument(documentData);
            resolve(results);
          } catch (error) {
            reject(error);
          }
        }, 100);
      });
      
      // Map results to store format and add IDs
      let issues = analysisResults.map(issue => ({
        id: uuidv4(),
        ...issue,
        // Ensure all required fields are present
        title: issue.title || 'Unknown Issue',
        description: issue.description || '',
        severity: issue.severity || 'Minor',
        category: issue.category || 'general',
        text: issue.text || null,
        location: issue.location || null,
        hasFix: issue.hasFix || false,
        fixAction: issue.fixAction || null,
        explanation: issue.explanation || issue.description || ''
      }));

      
      // Calculate enhanced compliance score
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;
      
      // Use server-provided compliance data if available
      let analysisScore;
      if (documentFormatting?.compliance?.overall !== undefined) {
        // Adjust server compliance score based on content issues
        const contentPenalty = criticalCount * 10 + majorCount * 5 + minorCount * 2;
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(documentFormatting.compliance.overall - contentPenalty)
        ));
      } else {
        // Fallback calculation
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))
        ));
      }
      
      set(state => ({
        issues,
        analysisScore,
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          isSchedulingAnalysis: false,
          stage: null
        }
      }));
      
      
      return { 
        success: true, 
        issueCount: issues.length,
        score: analysisScore,
        breakdown: { criticalCount, majorCount, minorCount }
      };
      
    } catch (error) {
      console.error('❌ Error analyzing document:', error);
      console.error('Error details:', error.message, error.stack);
      
      set(state => ({
        issues,
        analysisScore,
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          isSchedulingAnalysis: false,
          stage: null
        }
      }));
      
      return { success: false, error: error.message };
    }
  },
  
  // Auto-analyze after upload
  analyzeDocumentDebounced: async () => {
    // For server-side processing, we can analyze immediately since processing is faster
    return await get().analyzeDocument();
  },
  
  // Enhanced fix application with document regeneration
  applyFix: async (issueId) => {
    const { issues, documentHtml, documentText, documentFormatting } = get();
    const issue = issues.find(i => i.id === issueId);
    
    if (!issue || !issue.hasFix) {
      return false;
    }
    
    set(state => ({
      processingState: {
        ...state.processingState,
        isApplyingFix: true,
        currentFixId: issueId,
        stage: `Applying fix: ${issue.title}`
      }
    }));
    
    try {
      // Separate formatting fixes (server-side) from content fixes (client-side)
      const serverFormattingFixes = [
        'fixFont', 'fixFontSize', 'fixLineSpacing', 'fixMargins', 'fixIndentation'
      ];
      
      const clientContentFixes = [
        'addCitationComma', 'fixParentheticalConnector', 'fixEtAlFormatting', 
        'fixReferenceConnector', 'fixAllCapsHeading', 'addPageNumber'
      ];
      
      if (clientContentFixes.includes(issue.fixAction)) {
        console.log(`🔧 Applying client-side content fix: ${issue.fixAction}`);
        
        // Apply fix directly to current editor content (no server involved)
        const success = await get().applyClientSideFix(issue, issueId);
        
        return success;
        
      } else if (serverFormattingFixes.includes(issue.fixAction)) {
        console.log(`🔄 Regenerating document with fix: ${issue.fixAction}`);
        
        // Apply the fix to the formatting data and regenerate HTML
        const result = await get().applyFormattingFix(issue, documentFormatting, documentText);
        
        if (result.success) {
          // Remove the fixed issue and update all document data
          const updatedIssues = issues.filter(i => i.id !== issueId);
          
          // Recalculate score
          const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
          const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
          const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
          
          const newScore = updatedIssues.length === 0 ? 100 : 
            Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
          
          // Calculate updated stats
          const words = result.text ? result.text.trim().split(/\s+/).filter(Boolean).length : 0;
          const chars = result.text ? result.text.length : 0;
          const paragraphs = result.formatting?.paragraphs?.length || 0;
          
          set(state => ({
            // Update all document data with the server response
            documentHtml: result.html,
            documentText: result.text,
            documentFormatting: result.formatting,
            documentStructure: result.structure,
            documentStyles: result.styles,
            currentDocumentBuffer: result.updatedBuffer || state.currentDocumentBuffer, // Update buffer for next fix
            documentStats: {
              wordCount: words,
              charCount: chars,
              paragraphCount: paragraphs,
              processingTime: state.documentStats.processingTime // Keep original processing time
            },
            complianceDetails: result.formatting?.compliance || null,
            issues: updatedIssues,
            analysisScore: newScore,
            lastFixAppliedAt: Date.now(),
            activeIssueId: null,
            processingState: {
              ...state.processingState,
              isApplyingFix: false,
              currentFixId: null,
              stage: null
            }
          }));
          
          // Clear the lastFixAppliedAt after a brief delay to allow re-triggering
          setTimeout(() => {
            set(state => ({
              lastFixAppliedAt: null
            }));
          }, 100);
          
          return true;
        }
      } else {
        // Use the original text-based fix approach for content issues
        let updatedHtml = documentHtml;
        let updatedText = documentText;
        let contentChanged = false;
        
        const success = await get().applySpecificFix(issue, updatedHtml, updatedText);
        
        if (success.changed) {
          updatedHtml = success.html;
          updatedText = success.text;
          contentChanged = true;
        }
        
        // Remove the fixed issue
        const updatedIssues = issues.filter(i => i.id !== issueId);
        
        // Recalculate score
        const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
        const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
        const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
        
        const newScore = updatedIssues.length === 0 ? 100 : 
          Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
        
        set(state => ({
          documentText: updatedText,
          documentHtml: updatedHtml,
          issues: updatedIssues,
          analysisScore: newScore,
          lastFixAppliedAt: contentChanged ? Date.now() : state.lastFixAppliedAt,
          activeIssueId: null,
          processingState: {
            ...state.processingState,
            isApplyingFix: false,
            currentFixId: null,
            stage: null
          }
        }));
        
        // Clear the lastFixAppliedAt after a brief delay if content changed
        if (contentChanged) {
          setTimeout(() => {
            set(state => ({
              lastFixAppliedAt: null
            }));
          }, 100);
        }
        
        return true;
      }
      
    } catch (error) {
      console.error('Error applying fix:', error);
      
      // Still remove the issue even if fix failed
      const updatedIssues = issues.filter(i => i.id !== issueId);
      
      set(state => ({
        issues: updatedIssues,
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          isApplyingFix: false,
          currentFixId: null,
          lastError: `Failed to apply fix: ${error.message}`,
          stage: null
        }
      }));
      
      return false;
    }
  },

  // Apply client-side fix directly to editor content (no server involved)
  applyClientSideFix: async (issue, issueId) => {
    const { issues } = get();
    
    try {
      console.log(`🔧 Applying client-side fix: ${issue.fixAction} for issue: ${issue.title}`);
      console.log(`📝 Original text: "${issue.text}"`);
      
      // Calculate the replacement text
      let replacementText = '';
      
      switch (issue.fixAction) {
        case 'addCitationComma':
          replacementText = issue.text.replace(/\(([^,)]+)\s+(\d{4})\)/g, '($1, $2)');
          break;
        case 'fixParentheticalConnector':
          replacementText = issue.text.replace(' and ', ' & ');
          break;
        case 'fixEtAlFormatting':
          replacementText = issue.text.replace(/\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, '($1, et al., $2)');
          break;
        case 'fixReferenceConnector':
          replacementText = issue.text.replace(/, and /g, ', & ');
          break;
        case 'fixAllCapsHeading':
          replacementText = issue.text.toLowerCase()
            .split(' ')
            .map((word, index) => {
              const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
              if (index === 0 || !smallWords.includes(word)) {
                return word.charAt(0).toUpperCase() + word.slice(1);
              }
              return word;
            })
            .join(' ');
          break;
        case 'addPageNumber':
          if (issue.text.includes('(') && issue.text.includes(')')) {
            replacementText = issue.text.replace(/\)$/, ', p. 1)');
          }
          break;
        default:
          console.warn(`Unsupported client-side fix: ${issue.fixAction}`);
          return false;
      }
      
      if (replacementText && replacementText !== issue.text) {
        console.log(`📝 Replacement text: "${replacementText}"`);
        
        // Signal to DocumentEditor to apply the text replacement
        // We'll use a custom event or store method to communicate with the editor
        window.dispatchEvent(new CustomEvent('applyTextReplacement', {
          detail: {
            originalText: issue.text,
            replacementText: replacementText,
            issueId: issueId
          }
        }));
        
        // Remove the issue from the list
        const updatedIssues = issues.filter(i => i.id !== issueId);
        
        // Recalculate score
        const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
        const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
        const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
        
        const newScore = updatedIssues.length === 0 ? 100 : 
          Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
        
        set({
          issues: updatedIssues,
          analysisScore: newScore,
          activeIssueId: null,
          processingState: {
            ...get().processingState,
            isApplyingFix: false,
            currentFixId: null,
            stage: null
          }
        });
        
        return true;
      }
      
      return false;
      
    } catch (error) {
      console.error('Error applying client-side fix:', error);
      
      set({
        activeIssueId: null,
        processingState: {
          ...get().processingState,
          isApplyingFix: false,
          currentFixId: null,
          lastError: `Failed to apply fix: ${error.message}`,
          stage: null
        }
      });
      
      return false;
    }
  },
  
  // Apply specific fix logic (same as before)
  applySpecificFix: async (issue, html, text) => {
    let updatedHtml = html;
    let updatedText = text;
    let changed = false;
    
    try {
      switch (issue.fixAction) {
        case 'addCitationComma':
          if (issue.text) {
            const fixedText = issue.text.replace(
              /\(([^,)]+)\s+(\d{4})\)/g, 
              '($1, $2)'
            );
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixParentheticalConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(' and ', ' & ');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'addPageNumber':
          if (issue.text && issue.text.includes('(') && issue.text.includes(')')) {
            const fixedText = issue.text.replace(/\)$/, ', p. 1)');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixEtAlFormatting':
          if (issue.text) {
            // Fix et al. formatting: (Smith et al., 2021) → (Smith, et al., 2021)
            const fixedText = issue.text.replace(
              /\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, 
              '($1, et al., $2)'
            );
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixReferenceConnector':
          if (issue.text) {
            // Fix reference connector: "Author, A., and Author, B." → "Author, A., & Author, B."
            const fixedText = issue.text.replace(/, and /g, ', & ');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixAllCapsHeading':
          if (issue.text) {
            // Convert ALL CAPS heading to Title Case
            const fixedText = issue.text.toLowerCase()
              .split(' ')
              .map(word => {
                // Capitalize first letter of each word, except small words (unless first word)
                const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
                const isFirstWord = word === issue.text.toLowerCase().split(' ')[0];
                
                if (isFirstWord || !smallWords.includes(word)) {
                  return word.charAt(0).toUpperCase() + word.slice(1);
                }
                return word;
              })
              .join(' ');
            
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        default:
          break;
      }
      
      return { html: updatedHtml, text: updatedText, changed };
      
    } catch (error) {
      console.error('Error in applySpecificFix:', error);
      return { html, text, changed: false };
    }
  },
  
  // Apply formatting fix via server-side DOCX modification (Memory-based)
  applyFormattingFix: async (issue, originalFormatting, documentText) => {
    const SERVER_URL = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3001' 
      : '';
    
    const { currentDocumentBuffer, documentName } = get();
    
    try {
      console.log(`🔧 Applying memory-based formatting fix: ${issue.fixAction}`);
      
      if (!currentDocumentBuffer) {
        throw new Error('No document buffer available for document modification');
      }
      
      // Determine fix value based on action
      let fixValue;
      switch (issue.fixAction) {
        // Formatting fixes
        case 'fixFont':
          fixValue = 'Times New Roman';
          break;
        case 'fixFontSize':
          fixValue = 24; // 24 half-points = 12pt
          break;
        case 'fixLineSpacing':
          fixValue = 480; // 480 = double spacing in Word
          break;
        case 'fixMargins':
          fixValue = { top: 1.0, bottom: 1.0, left: 1.0, right: 1.0 };
          break;
        case 'fixIndentation':
          fixValue = 0.5;
          break;

        // Text-based content fixes
        case 'addCitationComma':
          if (issue.text) {
            const fixedText = issue.text.replace(/\(([^,)]+)\s+(\d{4})\)/g, '($1, $2)');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixParentheticalConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(' and ', ' & ');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixEtAlFormatting':
          if (issue.text) {
            const fixedText = issue.text.replace(/\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, '($1, et al., $2)');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixReferenceConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(/, and /g, ', & ');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixAllCapsHeading':
          if (issue.text) {
            const fixedText = issue.text.toLowerCase()
              .split(' ')
              .map(word => {
                const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
                const isFirstWord = word === issue.text.toLowerCase().split(' ')[0];
                
                if (isFirstWord || !smallWords.includes(word)) {
                  return word.charAt(0).toUpperCase() + word.slice(1);
                }
                return word;
              })
              .join(' ');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'addPageNumber':
          if (issue.text && issue.text.includes('(') && issue.text.includes(')')) {
            const fixedText = issue.text.replace(/\)$/, ', p. 1)');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        default:
          throw new Error(`Unknown fix action: ${issue.fixAction}`);
      }
      
      if (!fixValue) {
        throw new Error(`Could not determine fix value for action: ${issue.fixAction}`);
      }
      
      console.log(`💡 Sending fix request to server: ${issue.fixAction} = ${JSON.stringify(fixValue)}`);
      
      // First, test if server is accessible
      try {
        const healthCheck = await fetch(`${SERVER_URL}/api/health`);
        console.log('🏥 Health check response:', healthCheck.status);
        if (!healthCheck.ok) {
          throw new Error(`Server health check failed: ${healthCheck.status}`);
        }
      } catch (healthError) {
        console.error('❌ Server is not accessible:', healthError);
        throw new Error(`Server is not accessible: ${healthError.message}. Make sure the backend server is running on port 3001.`);
      }
      
      // Convert Uint8Array to base64 for JSON transport
      const base64Buffer = btoa(String.fromCharCode(...currentDocumentBuffer));
      
      // Send fix request to server with document buffer
      console.log('🚀 Sending fix request to server:', {
        fixAction: issue.fixAction,
        fixValue: fixValue,
        fixValueType: typeof fixValue,
        bufferSize: base64Buffer.length,
        filename: documentName
      });
      
      const response = await fetch(`${SERVER_URL}/api/apply-fix`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          documentBuffer: base64Buffer,
          fixAction: issue.fixAction,
          fixValue: fixValue,
          originalFilename: documentName
        })
      });
      
      console.log('📡 Server response status:', response.status);
      console.log('📡 Server response headers:', Object.fromEntries(response.headers.entries()));
      
      if (!response.ok) {
        let errorData;
        const contentType = response.headers.get('content-type');
        console.log('Response content-type:', contentType);
        
        try {
          const responseText = await response.text();
          console.log('Raw response text:', responseText);
          
          if (contentType && contentType.includes('application/json') && responseText) {
            errorData = JSON.parse(responseText);
          } else {
            errorData = { error: responseText || 'Unknown server error' };
          }
        } catch (parseError) {
          console.error('Error parsing server response:', parseError);
          errorData = { error: 'Failed to parse server error response' };
        }
        
        console.error('❌ Server error response:', errorData);
        console.error('❌ Full response details:', {
          status: response.status,
          statusText: response.statusText,
          url: response.url,
          headers: Object.fromEntries(response.headers.entries())
        });
        
        throw new Error(errorData.error || `Server error: ${response.status} ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log('✅ Server fix response:', {
        success: result.success,
        fixApplied: result.fixApplied,
        hasDocument: !!result.document,
        hasBuffer: !!result.modifiedDocumentBuffer
      });
      
      if (!result.success) {
        throw new Error(result.error || 'Server failed to apply fix');
      }
      
      console.log('🎉 Memory-based fix applied successfully');
      
      // Convert the returned buffer back to Uint8Array for next iteration
      let updatedBuffer = null;
      if (result.modifiedDocumentBuffer) {
        const binaryString = atob(result.modifiedDocumentBuffer);
        updatedBuffer = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          updatedBuffer[i] = binaryString.charCodeAt(i);
        }
      }
      
      // Return the updated document data from server
      return {
        success: true,
        html: result.document.html,
        text: result.document.text,
        formatting: result.document.formatting,
        structure: result.document.structure,
        styles: result.document.styles,
        updatedBuffer: updatedBuffer // Include updated buffer for cumulative fixes
      };
      
    } catch (error) {
      console.error('Error applying memory-based formatting fix:', error);
      return {
        success: false,
        error: error.message
      };
    }
  },
  
  // Set active issue and scroll to it
  setActiveIssue: (issueId) => {
    set({ activeIssueId: issueId });
    
    // Scroll to the issue in the document
    if (issueId) {
      setTimeout(() => {
        const issueElement = document.querySelector(`[data-issue-id="${issueId}"]`);
        if (issueElement) {
          issueElement.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center',
            inline: 'nearest'
          });
          console.log(`📍 Scrolled to issue: ${issueId}`);
        } else {
          console.warn(`⚠️ Could not find element for issue: ${issueId}`);
        }
      }, 100); // Small delay to ensure DOM is updated
    }
  },

  // Toggle issue highlighting
  toggleIssueHighlighting: () => {
    set(state => {
      const newState = !state.showIssueHighlighting;
      console.log('🔄 Store: Toggling issue highlighting from', state.showIssueHighlighting, 'to', newState);
      return { showIssueHighlighting: newState };
    });
  },

  
  // Get analysis summary with rich formatting data
  getAnalysisSummary: () => {
    const { 
      issues, 
      analysisScore, 
      documentStats, 
      documentFormatting,
      complianceDetails 
    } = get();
    
    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, {});
    
    const categoryCounts = issues.reduce((acc, issue) => {
      acc[issue.category] = (acc[issue.category] || 0) + 1;
      return acc;
    }, {});
    
    return {
      score: analysisScore,
      totalIssues: issues.length,
      severity: severityCounts,
      categories: categoryCounts,
      documentInfo: {
        ...documentStats,
        hasRichFormatting: !!documentFormatting,
        formattingCompliance: complianceDetails
      },
      compliance: complianceDetails
    };
  },

  // Editor management functions
  setEditorContent: (content) => {
    set({ 
      editorContent: content, 
      editorChanged: true 
    });
  },


  // Convert editor content back to text for analysis
  getTextFromEditorContent: (editorContent) => {
    if (!editorContent || !Array.isArray(editorContent)) return '';
    
    return editorContent.map(node => {
      if (node.children) {
        return node.children.map(child => child.text || '').join('');
      }
      return node.text || '';
    }).join('\n');
  },

  // Real-time analysis for editor changes
  analyzeEditorContent: async (editorContent, preservedFormatting = null) => {
    if (!editorContent) return { success: false, error: 'No editor content' };
    
    const { documentHtml, documentFormatting, documentStructure, documentStyles } = get();
    
    // Use preserved formatting if provided, otherwise fall back to stored formatting
    const formattingToUse = preservedFormatting || documentFormatting;
    
    try {
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null,
          stage: 'Analyzing edited content...'
        }
      }));

      // Convert editor content to text
      const text = get().getTextFromEditorContent(editorContent);
      
      if (!text || text.trim().length < 10) {
        set(state => ({
          issues: [],
          analysisScore: 100,
          processingState: {
            ...state.processingState,
            isAnalyzing: false,
            stage: null
          }
        }));
        return { success: true, issueCount: 0 };
      }

      // Create comprehensive document data object
      const documentData = {
        text: text,
        html: documentHtml,
        formatting: formattingToUse, // Use preserved formatting
        structure: documentStructure,
        styles: documentStyles
      };

      console.log('📊 Analysis using formatting data:', {
        hasFormatting: !!formattingToUse,
        formattingSource: preservedFormatting ? 'preserved' : 'stored',
        paragraphCount: formattingToUse?.paragraphs?.length || 0
      });

      // Use enhanced analyzer with rich document data
      const analysisResults = await new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            const analyzer = new EnhancedAPAAnalyzer();
            const results = analyzer.analyzeDocument(documentData);
            resolve(results);
          } catch (error) {
            reject(error);
          }
        }, 100);
      });

      // Map results to store format and add IDs
      let issues = analysisResults.map(issue => ({
        id: uuidv4(),
        ...issue,
        title: issue.title || 'Unknown Issue',
        description: issue.description || '',
        severity: issue.severity || 'Minor',
        category: issue.category || 'general',
        text: issue.text || null,
        location: issue.location || null,
        hasFix: issue.hasFix || false,
        fixAction: issue.fixAction || null,
        explanation: issue.explanation || issue.description || ''
      }));


      // Calculate enhanced compliance score
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;

      let analysisScore;
      if (formattingToUse?.compliance?.overall !== undefined) {
        const contentPenalty = criticalCount * 10 + majorCount * 5 + minorCount * 2;
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(formattingToUse.compliance.overall - contentPenalty)
        ));
      } else {
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))
        ));
      }

      // Update stats from editor content
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      const chars = text.length;
      const paragraphs = text.split('\n').filter(p => p.trim().length > 0).length;

      set(state => ({
        // Don't update documentText to avoid triggering editor regeneration
        issues,
        analysisScore,
        documentStats: {
          ...state.documentStats,
          wordCount: words,
          charCount: chars,
          paragraphCount: paragraphs
        },
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          stage: null
        },
        editorChanged: false // Reset change flag
      }));

      console.log(`✅ Editor content analysis complete: ${issues.length} issues`);
      
      return { 
        success: true, 
        issueCount: issues.length,
        score: analysisScore,
        breakdown: { criticalCount, majorCount, minorCount }
      };

    } catch (error) {
      console.error('❌ Error analyzing editor content:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          lastError: error.message || 'Editor content analysis failed',
          stage: null
        }
      }));

      return { success: false, error: error.message };
    }
  },

  // Export document
  exportDocument: async (format) => {
    const { documentHtml, documentName, currentDocumentBuffer } = get();
    
    if (!documentHtml) {
      alert('No document to export');
      return false;
    }
    
    try {
      if (format === 'html') {
        // HTML export
        const fullHtml = `
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Document Export</title>
            <style>
              body { 
                font-family: "Times New Roman", Times, serif; 
                font-size: 12pt; 
                line-height: 1.5; 
                margin: 1in; 
              }
            </style>
          </head>
          <body>${documentHtml}</body>
          </html>
        `;
        
        const blob = new Blob([fullHtml], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = documentName ? 
          documentName.replace('.docx', '_APA_formatted.html') : 
          'apa_formatted_document.html';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        return true;
      } else if (format === 'docx' && currentDocumentBuffer) {
        // DOCX export - use the modified buffer
        const blob = new Blob([currentDocumentBuffer], { 
          type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
        });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = documentName ? 
          documentName.replace('.docx', '_APA_fixed.docx') : 
          'apa_fixed_document.docx';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        return true;
      } else {
        throw new Error('Unsupported export format or missing document buffer');
      }
    } catch (error) {
      console.error('Export failed:', error);
      throw error;
    }
  }
}));

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\enhancedApaAnalyzer.js
// src/utils/enhancedApaAnalyzer.js - Fixed version with safe property access
'use client';

// Enhanced APA 7th Edition Analyzer that works with rich document formatting data
export class EnhancedAPAAnalyzer {
  constructor() {
    this.apaStandards = {
      font: {
        family: 'times new roman',
        size: 12 // points
      },
      spacing: {
        line: 2.0, // double spacing
        paragraphAfter: 0, // no extra space after paragraphs
        paragraphBefore: 0
      },
      margins: {
        top: 1.0, // inches
        bottom: 1.0,
        left: 1.0,
        right: 1.0
      },
      indentation: {
        firstLine: 0.5 // inches
      }
    };
  }
  
  /**
   * Main analysis function - works with rich document data from server
   */
  analyzeDocument(documentData) {
    const issues = [];
    
    // Safely extract data with defaults
    const { 
      text = '', 
      html = '', 
      formatting = null, 
      structure = null 
    } = documentData || {};
    
    
    // 1. Analyze formatting with precise data (if available)
    if (formatting) {
      issues.push(...this.analyzeFormatting(formatting));
    } else {
      console.warn('⚠️ No formatting data available - using basic analysis');
      issues.push(...this.analyzeBasicFormatting(html));
    }
    
    // 2. Analyze document structure
    if (structure && text) {
      issues.push(...this.analyzeStructure(structure, text));
    } else if (text) {
      console.warn('⚠️ No structure data available - using text-based analysis');
      issues.push(...this.analyzeBasicStructure(text));
    }
    
    // 3. Analyze citations - use basic analysis for better results
    if (text) {
      console.log('📚 Using basic citation analysis for better coverage...');
      issues.push(...this.analyzeBasicCitations(text));
    }
    
    // 4. Analyze references
    if (text) {
      issues.push(...this.analyzeReferences(text, structure));
    }
    
    // 5. Analyze content compliance
    if (text) {
      issues.push(...this.analyzeContent(text));
    }
    
    
    return this.prioritizeAndDeduplicateIssues(issues);
  }
  
  /**
   * Analyze formatting with precise measurements - FIXED with safe property access
   */
  analyzeFormatting(formatting) {
    const issues = [];
    
    
    // Safely access formatting properties
    const documentFormatting = formatting?.document || {};
    const font = documentFormatting.font || {};
    const spacing = documentFormatting.spacing || {};
    const margins = documentFormatting.margins || {};
    const indentation = documentFormatting.indentation || {};
    const paragraphs = formatting?.paragraphs || [];
    const compliance = formatting?.compliance || {};
    
    // Check font family - SAFE ACCESS
    if (font.family) {
      const fontFamily = font.family.toLowerCase();
      if (!fontFamily.includes('times new roman') && 
          !fontFamily.includes('times') && 
          !fontFamily.includes('liberation serif')) {
        issues.push({
          title: "Incorrect font family",
          description: `Document uses "${font.family}" instead of Times New Roman`,
          text: `Font: ${font.family}`,
          severity: "Major",
          category: "formatting",
          location: { type: "document", section: "font" },
          hasFix: true,
          fixAction: "fixFont",
          explanation: "APA 7th edition requires Times New Roman 12pt font throughout the document."
        });
      }
    } else if (compliance.font && !compliance.font.family) {
      issues.push({
        title: "Font family not specified or non-compliant",
        description: "Document should use Times New Roman font",
        severity: "Major",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    // Check font size with tolerance - SAFE ACCESS
    if (font.size && Math.abs(font.size - 12) > 0.5) {
      issues.push({
        title: "Incorrect font size",
        description: `Font size is ${font.size}pt instead of 12pt`,
        text: `Font size: ${font.size}pt`,
        severity: "Major",
        category: "formatting", 
        location: { type: "document", section: "font" },
        hasFix: true,
        fixAction: "fixFontSize",
        explanation: "APA 7th edition requires 12-point font size."
      });
    }
    
    // Check line spacing - SAFE ACCESS
    if (spacing.line && Math.abs(spacing.line - 2.0) > 0.1) {
      issues.push({
        title: "Incorrect line spacing",
        description: `Line spacing is ${spacing.line} instead of double (2.0)`,
        text: `Line spacing: ${spacing.line}`,
        severity: "Major",
        category: "formatting", 
        location: { type: "document", section: "spacing" },
        hasFix: true,
        fixAction: "fixLineSpacing",
        explanation: "APA 7th edition requires double spacing (2.0) throughout the document."
      });
    }
    
    // Check margins with tolerance - SAFE ACCESS
    const marginIssues = [];
    Object.entries(this.apaStandards.margins).forEach(([side, required]) => {
      const actual = margins[side];
      if (actual !== null && actual !== undefined && Math.abs(actual - required) > 0.1) {
        marginIssues.push(`${side}: ${actual}" (should be ${required}")`);
      }
    });
    
    if (marginIssues.length > 0) {
      issues.push({
        title: "Incorrect margins",
        description: `Margins are not 1 inch: ${marginIssues.join(', ')}`,
        text: marginIssues.join(', '),
        severity: "Major",
        category: "formatting",
        location: { type: "document", section: "margins" },
        hasFix: true,
        fixAction: "fixMargins",
        explanation: "APA 7th edition requires 1-inch margins on all sides."
      });
    }
    
    // Check paragraph indentation - SAFE ACCESS
    if (paragraphs.length > 0) {
      const bodyParagraphs = paragraphs.filter(p => 
        p && p.indentation && (p.indentation.firstLine !== null || p.indentation.left !== null)
      );
      
      const incorrectIndentation = bodyParagraphs.filter(p => {
        const firstLine = (p.indentation && p.indentation.firstLine) || 0;
        return Math.abs(firstLine - 0.5) > 0.05; // 5% tolerance
      });
      
      if (bodyParagraphs.length > 0 && incorrectIndentation.length > 0) {
        issues.push({
          title: "Incorrect paragraph indentation",
          description: `${incorrectIndentation.length} of ${bodyParagraphs.length} paragraphs have incorrect first-line indentation`,
          text: `Expected: 0.5", Found: varies`,
          severity: "Minor",
          category: "formatting",
          location: { 
            type: "paragraph", 
            indices: incorrectIndentation.map(p => p.index).slice(0, 5) 
          },
          hasFix: true,
          fixAction: "fixIndentation",
          explanation: "APA 7th edition requires 0.5-inch first-line indentation for all paragraphs."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback formatting analysis for when rich data isn't available
   */
  analyzeBasicFormatting(html) {
    const issues = [];
    
    
    if (!html) return issues;
    
    // Check font family
    const fontCheck = html.match(/font-family:\s*['"]([^'"]+)['"]/i);
    if (fontCheck && !fontCheck[1].toLowerCase().includes('times new roman')) {
      issues.push({
        title: "Incorrect font detected",
        description: `Document appears to use "${fontCheck[1]}" instead of Times New Roman`,
        text: `Font: ${fontCheck[1]}`,
        severity: "Minor",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze document structure with heading hierarchy
   */
  analyzeStructure(structure, text) {
    const issues = [];
    
    
    if (!structure || !text) return issues;
    
    const headings = structure.headings || [];
    const sections = structure.sections || [];
    const citations = structure.citations || [];
    
    // 1. Check for required sections
    const hasAbstract = sections.some(s => s.type === 'abstract') || text.toLowerCase().includes('abstract');
    const hasReferences = sections.some(s => s.type === 'references') || text.toLowerCase().includes('references');
    const wordCount = text.split(/\s+/).length;
    
    if (wordCount > 1000 && !hasAbstract) {
      issues.push({
        title: "Missing abstract",
        description: "Long papers typically require an abstract",
        severity: "Major",
        category: "structure",
        hasFix: true,
        fixAction: "addAbstract",
        explanation: "Papers longer than 1000 words typically require an abstract (150-250 words) summarizing the main points."
      });
    }
    
    if (!hasReferences && citations.length > 0) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    // 2. Check heading hierarchy
    if (headings.length > 1) {
      for (let i = 1; i < headings.length; i++) {
        const current = headings[i];
        const previous = headings[i - 1];
        
        if (current.level > previous.level + 1) {
          issues.push({
            title: "Improper heading hierarchy",
            description: `Heading level ${current.level} follows level ${previous.level}`,
            text: `"${current.text}" (Level ${current.level}) after "${previous.text}" (Level ${previous.level})`,
            severity: "Major",
            category: "structure",
            location: { 
              type: "heading", 
              paragraphIndex: current.paragraphIndex 
            },
            hasFix: true,
            fixAction: "fixHeadingLevel",
            explanation: "Headings must follow sequential order: Level 1, then Level 2, then Level 3, etc. Don't skip levels."
          });
        }
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback structure analysis
   */
  analyzeBasicStructure(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,\s*\d{4}\)/.test(text);
    
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze citations with extracted citation data
   */
  analyzeCitations(text, extractedCitations) {
    const issues = [];
    
    
    // Use extracted citations for more accurate analysis
    const citations = extractedCitations || [];
    
    citations.forEach((citation, index) => {
      // Check author-year format - SAFE ACCESS
      if (!citation.year || !citation.author) {
        issues.push({
          title: "Incomplete citation",
          description: "Citation missing author or year",
          text: citation.text || 'Unknown citation',
          severity: "Major",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: false,
          explanation: "All in-text citations must include author surname(s) and publication year."
        });
        return;
      }
      
      // Check for proper punctuation
      if (citation.text && !citation.text.includes(`, ${citation.year}`)) {
        issues.push({
          title: "Missing comma in citation",
          description: "Citation missing comma between author and year",
          text: citation.text,
          severity: "Minor",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: true,
          fixAction: "addCitationComma",
          explanation: "In-text citations require a comma between the author name and year: (Smith, 2023)."
        });
      }
    });
    
    return issues;
  }
  
  /**
   * Fallback citation analysis
   */
  analyzeBasicCitations(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Enhanced citation patterns to catch all APA violations
    
    // 1. Check for citations missing commas (Author YEAR) format - but exclude et al. cases
    const missingCommaPattern = /\(([A-Za-z][A-Za-z\s&.]+(?<!et\s+al))\s+(\d{4})\)/g;
    let missingCommaMatch;
    while ((missingCommaMatch = missingCommaPattern.exec(text)) !== null) {
      const fullCitation = missingCommaMatch[0];
      const authorPart = missingCommaMatch[1];
      
      // Skip if this contains et al. - handle separately
      if (authorPart.includes('et al')) continue;
      
      
      issues.push({
        title: "Missing comma in citation",
        description: "Citations must have a comma between author and year",
        text: fullCitation,
        severity: "Minor", 
        category: "citations",
        hasFix: true,
        fixAction: "addCitationComma",
        explanation: "APA format requires a comma between author name(s) and year: (Author, YEAR)."
      });
    }
    
    // 2. Standard citation pattern with comma (Author, YEAR)
    const citationPattern = /\(([^)]+),\s*(\d{4})[^)]*\)/g;
    let match;
    let citationCount = 0;
    
    while ((match = citationPattern.exec(text)) !== null) {
      citationCount++;
      const fullCitation = match[0];
      const authorPart = match[1];
      
      
      // Check for incorrect ampersand usage
      if (authorPart.includes(' and ') && fullCitation.includes('(')) {
        issues.push({
          title: "Incorrect connector in parenthetical citation",
          description: "Use '&' instead of 'and' in parenthetical citations",
          text: fullCitation,
          severity: "Minor",
          category: "citations",
          hasFix: true,
          fixAction: "fixParentheticalConnector",
          explanation: "In parenthetical citations, use & to connect author names."
        });
      }
      
      // Check for incorrect et al. formatting - APA 7th edition REQUIRES comma before et al.
      if (authorPart.includes(' et al.') && !authorPart.includes(', et al.')) {
        issues.push({
          title: "Missing comma before et al.",
          description: "APA 7th edition requires comma before 'et al.' in citations",
          text: fullCitation,
          severity: "Minor",
          category: "citations", 
          hasFix: true,
          fixAction: "fixEtAlFormatting",
          explanation: "APA 7th edition requires a comma before 'et al.': (Smith, et al., 2021)."
        });
      }
    }
    
    
    // 3. Analyze References section for consistency issues
    const referencesSection = text.match(/REFERENCES([\s\S]*?)(?=\n\n[A-Z]|$)/i);
    if (referencesSection) {
      const referencesText = referencesSection[1];
      
      // Check for "and" instead of "&" in references
      const andInReferencesPattern = /^[^.]+,\s+[^,]+,\s+and\s+[^,]+\./gm;
      let andMatch;
      while ((andMatch = andInReferencesPattern.exec(referencesText)) !== null) {
        issues.push({
          title: "Incorrect connector in reference",
          description: "Use '&' instead of 'and' in reference list",
          text: andMatch[0],
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixReferenceConnector",
          explanation: "In reference lists, use & (ampersand) to connect author names, not 'and'."
        });
      }
      
      // Check for missing DOI/URL when available
      const lines = referencesText.split('\n').filter(line => line.trim().length > 0);
      lines.forEach((line, index) => {
        if (line.match(/^\s*[A-Z]/)) { // Reference entry line
          if (!line.includes('doi:') && !line.includes('http') && !line.includes('Retrieved from')) {
            if (line.toLowerCase().includes('journal') || line.toLowerCase().includes('article')) {
              issues.push({
                title: "Missing DOI or URL",
                description: "Journal articles should include DOI or URL when available",
                text: line.substring(0, 100) + '...',
                severity: "Minor",
                category: "references",
                hasFix: false,
                explanation: "Include DOI (preferred) or URL for journal articles and online sources when available."
              });
            }
          }
        }
      });
    }
    
    // 4. Check for title page issues
    const titlePageIssues = this.analyzeTitlePage(text);
    issues.push(...titlePageIssues);
    
    // 5. Check for spacing issues around citations
    const spacingIssuePattern = /[^\s]\(([^)]+,\s*\d{4})\)|(\([^)]+,\s*\d{4}\))[^\s.,;]/g;
    let spacingMatch;
    while ((spacingMatch = spacingIssuePattern.exec(text)) !== null) {
      issues.push({
        title: "Citation spacing error",
        description: "Citations need proper spacing before and after",
        text: spacingMatch[0],
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "There should be a space before opening parenthesis and proper punctuation after citations."
      });
    }
    
    // 6. Check for URLs in text that should be properly formatted
    const urlInTextPattern = /https?:\/\/[^\s)]+/g;
    let urlMatch;
    while ((urlMatch = urlInTextPattern.exec(text)) !== null) {
      if (!text.includes('Retrieved from') || !text.includes('doi:')) {
        issues.push({
          title: "URL formatting in text",
          description: "URLs should be properly formatted in references, not embedded in text",
          text: urlMatch[0],
          severity: "Minor",
          category: "formatting",
          hasFix: false,
          explanation: "URLs should appear in the reference list, not embedded in the main text."
        });
      }
    }
    
    // 7. Check for ALL CAPS headings (more precise detection)
    const allCapsHeadingPattern = /\n\s*([A-Z][A-Z\s]{8,})\s*\n/g;
    let titleMatch;
    while ((titleMatch = allCapsHeadingPattern.exec(text)) !== null) {
      const heading = titleMatch[1].trim();
      // Only flag if it's truly ALL CAPS and looks like a heading
      if (heading.length > 8 && heading === heading.toUpperCase() && 
          !heading.includes('(') && !heading.includes(',') && 
          heading.split(' ').length <= 8) {
        issues.push({
          title: "ALL CAPS heading detected",
          description: "Headings should use title case or sentence case, not ALL CAPS",
          text: heading,
          severity: "Minor",
          category: "formatting", 
          hasFix: true,
          fixAction: "fixAllCapsHeading",
          explanation: "APA 7th edition headings should use title case (Level 1-3) or sentence case (Level 4-5), not ALL CAPS."
        });
      }
    }
    
    // 8. Check for paragraph structure (multiple consecutive line breaks)
    const excessiveBreaksPattern = /\n\s*\n\s*\n\s*\n/g;
    if (excessiveBreaksPattern.test(text)) {
      issues.push({
        title: "Excessive line spacing",
        description: "Too many blank lines between paragraphs",
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "APA format uses double-spacing with no extra blank lines between paragraphs."
      });
    }
    
    // 9. Check for sentences ending without punctuation (more precise)
    const incompleteSentencePattern = /[a-z]\s+[A-Z][a-z]/g;
    let incompleteMatch;
    let sentenceIssueCount = 0;
    while ((incompleteMatch = incompleteSentencePattern.exec(text)) && sentenceIssueCount < 3) {
      const context = text.substring(Math.max(0, incompleteMatch.index - 30), incompleteMatch.index + 50);
      
      // Skip if this looks like an abbreviation or proper formatting
      if (context.includes('Dr.') || context.includes('Mr.') || context.includes('Ms.') ||
          context.includes('etc.') || context.includes('i.e.') || context.includes('e.g.') ||
          context.match(/\d+\s+[A-Z]/) || // Numbers followed by caps (like page numbers)
          context.includes('(') || context.includes(')')) {
        continue;
      }
      
      sentenceIssueCount++;
      issues.push({
        title: "Possible missing punctuation",
        description: "Check if sentence needs proper punctuation",
        text: context.trim().substring(0, 60) + '...',
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "Sentences should end with appropriate punctuation before starting a new sentence."
      });
    }
    
    // Check for direct quotes without page numbers
    const quotePattern = /[""][^""]{10,}[""]\s*(\([^)]+\))/g;
    let quoteMatch;
    while ((quoteMatch = quotePattern.exec(text)) !== null) {
      const citation = quoteMatch[1];
      if (!citation.match(/,\s*p\.?\s*\d+/)) {
        issues.push({
          title: "Direct quote missing page number",
          description: "Direct quotes require page numbers",
          text: quoteMatch[0],
          severity: "Major",
          category: "citations",
          hasFix: true,
          fixAction: "addPageNumber",
          explanation: "All direct quotations must include a page number to help readers locate the original text."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Analyze title page structure
   */
  analyzeTitlePage(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    const firstPage = text.substring(0, 1500); // First ~1500 chars for title page
    
    // Check for required elements in order
    const lines = firstPage.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    if (lines.length < 3) {
      issues.push({
        title: "Incomplete title page",
        description: "Title page appears to be missing required elements",
        severity: "Major",
        category: "structure",
        hasFix: false,
        explanation: "APA title page requires: paper title, author name(s), institutional affiliation, and author note."
      });
      return issues;
    }
    
    // Check if title is centered (simple heuristic - no excessive leading spaces)
    const possibleTitle = lines[0];
    if (possibleTitle.length > 5 && possibleTitle.startsWith('  ')) {
      // This might indicate improper formatting, but it's hard to detect without rich formatting
    }
    
    // Check for common title page issues
    const titlePageText = firstPage.toLowerCase();
    
    // Check for missing running head
    if (!titlePageText.includes('running head') && !titlePageText.includes('page')) {
      issues.push({
        title: "Missing running head",
        description: "Title page should include a running head (for professional papers)",
        severity: "Minor", 
        category: "structure",
        hasFix: false,
        explanation: "Professional papers require a running head on the title page and throughout the document."
      });
    }
    
    // Check for in-text citations on title page (but be more selective)
    const citationPattern = /\([A-Za-z]+,?\s+\d{4}\)/g;
    const citationsOnTitlePage = firstPage.match(citationPattern);
    if (citationsOnTitlePage && citationsOnTitlePage.length > 0) {
      // Only flag if it's clearly in the main title page content, not in author notes
      const titlePageWithoutAuthorNote = firstPage.split('Author Note')[0];
      if (citationPattern.test(titlePageWithoutAuthorNote)) {
        issues.push({
          title: "Citations on title page",
          description: "Title page should not contain in-text citations",
          severity: "Minor",
          category: "structure", 
          hasFix: false,
          explanation: "The title page should contain only title, author, affiliation information - no citations."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Analyze references section
   */
  analyzeReferences(text, structure) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Simple check - if we have citations but no references section
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,?\s*\d{4}\)/.test(text);
    
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing References section",
        description: "Document has citations but no References section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesHeader",
        explanation: "All APA papers must include a References section."
      });
    }
    
    const referencesMatch = text.match(/References[\s\n]+([\s\S]+?)(?:\n\n[A-Z]|$)/i);
    if (!referencesMatch) return issues;
    
    const referencesText = referencesMatch[1].trim();
    const referenceEntries = referencesText
      .split(/\n\s*\n/)
      .filter(entry => entry.trim().length > 10);
    
    if (referenceEntries.length === 0) {
      issues.push({
        title: "Empty references section",
        description: "References section contains no entries",
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "The References section must contain entries for all sources cited in your paper."
      });
      return issues;
    }
    
    // Check alphabetical order
    const firstWords = referenceEntries.map(entry => {
      const match = entry.match(/^([^,\s]+)/);
      return match ? match[1].toLowerCase() : '';
    });
    
    const sortedFirstWords = [...firstWords].sort();
    const isAlphabetical = JSON.stringify(firstWords) === JSON.stringify(sortedFirstWords);
    
    if (!isAlphabetical) {
      issues.push({
        title: "References not in alphabetical order",
        description: "Reference entries must be alphabetized by first author's surname",
        text: `First entries: ${firstWords.slice(0, 3).join(', ')}...`,
        severity: "Major",
        category: "references",
        hasFix: true,
        fixAction: "sortReferences",
        explanation: "References must be arranged in alphabetical order by the surname of the first author."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze content for APA compliance
   */
  analyzeContent(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Check for excessive first person usage
    const firstPersonPattern = /\b(I|me|my|mine|we|us|our|ours)\b/gi;
    const firstPersonMatches = text.match(firstPersonPattern) || [];
    const wordCount = text.split(/\s+/).length;
    
    if (firstPersonMatches.length > wordCount * 0.02) { // More than 2%
      issues.push({
        title: "Excessive first-person usage",
        description: "Consider reducing first-person pronouns in formal academic writing",
        text: `Found ${firstPersonMatches.length} instances`,
        severity: "Minor",
        category: "content",
        hasFix: false,
        explanation: "While not prohibited, excessive first-person usage should be avoided in formal academic writing."
      });
    }
    
    return issues;
  }
  
  /**
   * Helper methods
   */
  prioritizeAndDeduplicateIssues(issues) {
    // Remove duplicates based on title and text
    const unique = issues.filter((issue, index, self) => 
      index === self.findIndex(i => 
        i.title === issue.title && i.text === issue.text
      )
    );
    
    // Sort by severity and category
    const severityOrder = { 'Critical': 0, 'Major': 1, 'Minor': 2 };
    const categoryOrder = { 
      'formatting': 0, 
      'structure': 1, 
      'citations': 2, 
      'references': 3, 
      'content': 4 
    };
    
    return unique.sort((a, b) => {
      // First by severity
      const severityCompare = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityCompare !== 0) return severityCompare;
      
      // Then by category
      return categoryOrder[a.category] - categoryOrder[b.category];
    });
  }
}

// Usage function that matches what your store expects
export function analyzeAPADocument(documentData) {
  const analyzer = new EnhancedAPAAnalyzer();
  return analyzer.analyzeDocument(documentData);
}

