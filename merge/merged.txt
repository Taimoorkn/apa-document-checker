// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --primary: #3b82f6;
  --secondary: #10b981;
  --accent: #8b5cf6;
  --error: #ef4444;
  --warning: #f59e0b;
  --background: #ffffff;
  --text: #1f2937;
}

/* Base styling */
body {
  color: var(--text);
  background-color: var(--background);
}

/* Typography */
h1, h2, h3, h4, h5 {
  font-family: 'Inter', sans-serif;
}

body {
  font-family: 'Roboto', sans-serif;
}

/* APA styling for document viewer */
.prose {
  font-family: 'Times New Roman', Times, serif;
  font-size: 12pt;
  line-height: 2;
  max-width: none;
}

/* Issue highlighting styles */
mark[data-issue-id] {
  border-radius: 2px;
  cursor: pointer;
  padding: 0 1px;
  transition: all 0.2s ease;
  position: relative;
}

mark[data-issue-id]:hover {
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

mark[data-issue-id]::after {
  content: '';
  position: absolute;
  bottom: -2px;
  left: 0;
  width: 100%;
  height: 2px;
  transform: scaleX(0);
  transform-origin: bottom right;
  transition: transform 0.3s ease;
}

mark[data-issue-id]:hover::after {
  transform: scaleX(1);
  transform-origin: bottom left;
}

.bg-red-200 {
  background-color: rgba(254, 202, 202, 0.7);
  border-bottom: 2px solid var(--error);
}

.bg-red-200:hover {
  background-color: rgba(254, 202, 202, 0.9);
}

.bg-red-200::after {
  background-color: var(--error);
}

.bg-orange-200 {
  background-color: rgba(254, 215, 170, 0.7);
  border-bottom: 2px solid var(--warning);
}

.bg-orange-200:hover {
  background-color: rgba(254, 215, 170, 0.9);
}

.bg-orange-200::after {
  background-color: var(--warning);
}

.bg-blue-200 {
  background-color: rgba(191, 219, 254, 0.7);
  border-bottom: 2px solid var(--primary);
}

.bg-blue-200:hover {
  background-color: rgba(191, 219, 254, 0.9);
}

.bg-blue-200::after {
  background-color: var(--primary);
}

/* Active issue highlighting */
.active-issue {
  box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
  animation: pulse 2s infinite;
}

/* Custom animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes scaleIn {
  from { transform: scale(0.95); opacity: 0; }
  to { transform: scale(1); opacity: 1; }
}

@keyframes pulse {
  0% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.4); }
  70% { box-shadow: 0 0 0 10px rgba(59, 130, 246, 0); }
  100% { box-shadow: 0 0 0 0 rgba(59, 130, 246, 0); }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Animation utilities (fallback for older Tailwind versions) */
.animate-fade-in {
  animation: fadeIn 0.3s ease-out forwards;
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out forwards;
}

.animate-scale-in {
  animation: scaleIn 0.3s ease-out forwards;
}

.animate-pulse-blue {
  animation: pulse 2s infinite;
}

/* Apply animations to components */
.issue-category {
  animation: fadeIn 0.4s ease-out;
}

.issue-item {
  animation: slideIn 0.3s ease-out;
}

/* Staggered animations for issue items */
.issue-item:nth-child(1) { animation-delay: 0.05s; }
.issue-item:nth-child(2) { animation-delay: 0.1s; }
.issue-item:nth-child(3) { animation-delay: 0.15s; }
.issue-item:nth-child(4) { animation-delay: 0.2s; }
.issue-item:nth-child(5) { animation-delay: 0.25s; }

/* Custom utility classes */
.hover-shadow:hover {
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
}

.hover-grow:hover {
  transform: scale(1.02);
}

/* Loading spinner */
.loading-spinner {
  border: 3px solid rgba(59, 130, 246, 0.1);
  border-radius: 50%;
  border-top: 3px solid var(--primary);
  width: 24px;
  height: 24px;
  animation: spin 1s linear infinite;
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\layout.js
import './globals.css'
import ErrorBoundary from '@/components/ErrorBoundary'

export const metadata = {
  title: 'APA 7th Edition Document Checker',
  description: 'Validate academic documents against APA 7th edition guidelines',
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <head>
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
      </head>
      <body className="font-sans antialiased text-gray-800 bg-gray-50">
        <ErrorBoundary showDetails={process.env.NODE_ENV === 'development'}>
          {children}
        </ErrorBoundary>
      </body>
    </html>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\app\page.js
'use client';
import './globals.css';
import { useState } from 'react';
import DocumentViewer from '@/components/DocumentViewer';
import IssuesPanel from '@/components/IssuesPanel';
import Header from '@/components/Header';
import { useDocumentStore } from '@/store/documentStore';
import { BookOpen } from 'lucide-react';

export default function Home() {
  const [splitRatio, setSplitRatio] = useState(60);
  const { documentText, issues } = useDocumentStore();

  return (
    <main className="flex flex-col h-screen bg-gradient-to-br from-slate-50 to-blue-50">
      <Header />
      
      <div className="flex-1 overflow-hidden flex flex-col max-w-7xl mx-auto w-full px-4 py-3">
        <div className="flex justify-between items-center pb-3 bg-white rounded-t-lg shadow-sm p-3 border-x border-t border-gray-200">
          <div className="flex items-center">
            <BookOpen className="h-5 w-5 text-blue-600 mr-2" />
            <h2 className="text-lg font-semibold text-blue-700">APA Document Checker</h2>
          </div>
          <div className="text-sm bg-blue-50 px-3 py-1 rounded-full text-blue-700 font-medium">
            {documentText ? 'Document loaded and analyzed' : 'No document loaded'}
          </div>
        </div>
        
        <div className="flex flex-1 overflow-hidden rounded-b-lg shadow-lg border border-gray-200 bg-white">
          {/* Document Viewer (left panel) */}
          <div 
            className="relative overflow-auto border-r border-gray-200"
            style={{ width: `${splitRatio}%` }}
          >
            <DocumentViewer />
          </div>
          
          {/* Resize handle */}
          <div 
            className="w-2 bg-gradient-to-r from-gray-100 to-gray-200 hover:from-blue-400 hover:to-blue-500 cursor-col-resize transition-colors relative flex items-center justify-center"
            onMouseDown={(e) => {
              const startX = e.clientX;
              const startWidth = splitRatio;
              
              const handleMouseMove = (moveEvent) => {
                const containerWidth = document.body.clientWidth;
                const newWidth = startWidth + ((moveEvent.clientX - startX) / containerWidth * 100);
                
                // Constrain between 30% and 80%
                const constrainedWidth = Math.max(30, Math.min(80, newWidth));
                setSplitRatio(constrainedWidth);
              };
              
              const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
              };
              
              document.addEventListener('mousemove', handleMouseMove);
              document.addEventListener('mouseup', handleMouseUp);
            }}
          >
            <div className="absolute flex flex-col space-y-1.5">
              <div className="w-1 h-2 bg-gray-400 rounded-full"></div>
              <div className="w-1 h-2 bg-gray-400 rounded-full"></div>
              <div className="w-1 h-2 bg-gray-400 rounded-full"></div>
            </div>
          </div>
          
          {/* Issues Panel (right panel) */}
          <div 
            className="overflow-auto bg-gray-50"
            style={{ width: `${100 - splitRatio}%` }}
          >
            <IssuesPanel />
          </div>
        </div>
        
        <div className="py-3 text-xs text-center text-blue-600 font-medium bg-white mt-2 rounded-lg shadow-sm border border-gray-200 p-2">
          APA 7th Edition Document Checker | Validate academic papers against APA guidelines
        </div>
      </div>
    </main>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\AnalysisSettings.js
'use client';

import { useState } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import { Settings, Clock, Zap } from 'lucide-react';

export default function AnalysisSettings() {
  const { analysisSettings, updateAnalysisSettings, cancelDebouncedAnalysis, processingState } = useDocumentStore();
  const [showSettings, setShowSettings] = useState(false);

  const handleDelayChange = (newDelay) => {
    updateAnalysisSettings({ debounceDelay: newDelay });
    
    // If there's a pending analysis, cancel and restart with new delay
    if (processingState.isSchedulingAnalysis) {
      cancelDebouncedAnalysis();
    }
  };

  const handleAutoAnalyzeChange = (autoAnalyze) => {
    updateAnalysisSettings({ autoAnalyze });
  };

  const presetDelays = [
    { label: 'Instant', value: 0, icon: <Zap className="h-4 w-4" /> },
    { label: 'Fast (0.5s)', value: 500, icon: <Clock className="h-4 w-4" /> },
    { label: 'Normal (1.5s)', value: 1500, icon: <Clock className="h-4 w-4" /> },
    { label: 'Slow (3s)', value: 3000, icon: <Clock className="h-4 w-4" /> }
  ];

  return (
    <div className="relative">
      <button
        onClick={() => setShowSettings(!showSettings)}
        className="p-2 text-gray-600 hover:text-gray-800 hover:bg-gray-100 rounded-md transition-colors"
        title="Analysis Settings"
      >
        <Settings className="h-5 w-5" />
      </button>

      {showSettings && (
        <div className="absolute right-0 top-full mt-2 w-80 bg-white border border-gray-200 rounded-lg shadow-lg z-50">
          <div className="p-4">
            <h3 className="font-semibold text-gray-800 mb-3 flex items-center">
              <Settings className="h-4 w-4 mr-2" />
              Analysis Settings
            </h3>

            {/* Auto-analyze toggle */}
            <div className="mb-4">
              <label className="flex items-center">
                <input
                  type="checkbox"
                  checked={analysisSettings.autoAnalyze}
                  onChange={(e) => handleAutoAnalyzeChange(e.target.checked)}
                  className="mr-2 h-4 w-4 text-blue-600 rounded border-gray-300 focus:ring-blue-500"
                />
                <span className="text-sm text-gray-700">Auto-analyze documents</span>
              </label>
              <p className="text-xs text-gray-500 mt-1">
                Automatically analyze documents when uploaded
              </p>
            </div>

            {/* Debounce delay settings */}
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">
                Analysis Delay
              </label>
              <p className="text-xs text-gray-500 mb-3">
                Delay before starting analysis to improve performance with large documents
              </p>
              
              <div className="grid grid-cols-2 gap-2">
                {presetDelays.map((preset) => (
                  <button
                    key={preset.value}
                    onClick={() => handleDelayChange(preset.value)}
                    className={`flex items-center justify-center p-2 text-xs rounded-md border transition-colors ${
                      analysisSettings.debounceDelay === preset.value
                        ? 'bg-blue-100 border-blue-500 text-blue-700'
                        : 'bg-gray-50 border-gray-200 text-gray-700 hover:bg-gray-100'
                    }`}
                  >
                    {preset.icon}
                    <span className="ml-1">{preset.label}</span>
                  </button>
                ))}
              </div>

              {/* Custom delay input */}
              <div className="mt-3">
                <label className="block text-xs text-gray-600 mb-1">
                  Custom delay (milliseconds)
                </label>
                <input
                  type="number"
                  min="0"
                  max="10000"
                  step="100"
                  value={analysisSettings.debounceDelay}
                  onChange={(e) => handleDelayChange(parseInt(e.target.value) || 0)}
                  className="w-full px-2 py-1 text-xs border border-gray-300 rounded-md focus:ring-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
            </div>

            {/* Current status */}
            {processingState.isSchedulingAnalysis && (
              <div className="p-2 bg-blue-50 border border-blue-200 rounded-md">
                <div className="flex items-center text-xs text-blue-700">
                  <Clock className="h-3 w-3 mr-1 animate-pulse" />
                  Analysis scheduled ({Math.ceil((Date.now() - processingState.analysisScheduledAt) / 1000)}s ago)
                </div>
                <button
                  onClick={cancelDebouncedAnalysis}
                  className="text-xs text-blue-600 hover:text-blue-800 underline mt-1"
                >
                  Cancel pending analysis
                </button>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\DocumentViewer.js
'use client';

import { useRef, useEffect, useState, useCallback } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import { FileText, InfoIcon } from 'lucide-react';
import { useTooltip } from '@/components/Tooltip';

export default function DocumentViewer() {
  const { documentText, documentHtml, activeIssueId, issues, setActiveIssue } = useDocumentStore();
  const viewerRef = useRef(null);
  const [isLoading, setIsLoading] = useState(false);
  
  // Add a state for showing/hiding issues
  const [showIssues, setShowIssues] = useState(true);
  
  // Initialize tooltip functionality
  const { showTooltip, hideTooltip, TooltipComponent } = useTooltip();
  
  // Function to apply highlighting to the document
  const applyHighlighting = () => {
    if (!viewerRef.current || !documentHtml || !issues || !showIssues) {
      console.log('Cannot apply highlighting, missing prerequisites');
      return;
    }
    
    console.log('Applying highlighting to document with', issues.length, 'issues');
    
    // First, reset any existing highlighting and remove event listeners to prevent memory leaks
    const existingMarks = viewerRef.current.querySelectorAll('mark[data-issue-id]');
    existingMarks.forEach(mark => {
      // Clone the mark without event listeners to prevent memory leaks
      if (mark.parentNode) {
        const textContent = mark.textContent;
        const textNode = document.createTextNode(textContent);
        mark.parentNode.replaceChild(textNode, mark);
      }
    });
    
    // Track created marks so we can efficiently handle cleanups later
    const createdMarks = [];
    
    // Now apply new highlighting
    for (const issue of issues) {
      if (!issue.text) continue;
      
      // Find all text nodes in the document
      const allTextNodes = [];
      const walker = document.createTreeWalker(
        viewerRef.current,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );
      
      let node;
      while ((node = walker.nextNode())) {
        allTextNodes.push(node);
      }
      
      // Look for the issue text in these nodes
      for (const textNode of allTextNodes) {
        const content = textNode.textContent;
        const index = content.indexOf(issue.text);
        
        if (index === -1) continue;
        
        try {
          // Found a match, split the node and highlight
          const range = document.createRange();
          range.setStart(textNode, index);
          range.setEnd(textNode, index + issue.text.length);
          
          // Create a mark element
          const mark = document.createElement('mark');
          mark.setAttribute('data-issue-id', issue.id);
          mark.setAttribute('data-issue-title', issue.title);
          mark.setAttribute('data-issue-explanation', issue.explanation || issue.description || 'APA formatting issue detected');
          mark.className = getIssueClass(issue.severity);
          
          // Wrap the text in the mark
          range.surroundContents(mark);
          
          // Use a data attribute instead of direct event listener
          // This makes the DOM element serializable and prevents memory leaks
          mark.setAttribute('data-clickable', 'true');
          
          // Track created marks
          createdMarks.push(mark);
          
          // Only highlight the first occurrence
          break;
        } catch (error) {
          console.error('Error highlighting text:', error);
          // Continue with next node if there's an error
          continue;
        }
      }
    }
    
    // Add delegated event listeners at the container level for better performance
    // and to avoid memory leaks from multiple individual listeners
    if (viewerRef.current) {
      // Remove existing event handlers
      viewerRef.current.removeEventListener('click', handleMarkClick);
      viewerRef.current.removeEventListener('mouseenter', handleMarkHover, true);
      viewerRef.current.removeEventListener('mouseleave', handleMarkLeave, true);
      
      // Add new event handlers
      viewerRef.current.addEventListener('click', handleMarkClick);
      viewerRef.current.addEventListener('mouseenter', handleMarkHover, true);
      viewerRef.current.addEventListener('mouseleave', handleMarkLeave, true);
    }
    
    // Highlight the active issue with a special class
    if (activeIssueId) {
      const activeMark = viewerRef.current.querySelector(`mark[data-issue-id="${activeIssueId}"]`);
      if (activeMark) {
        activeMark.classList.add('active-issue');
      }
    }
    
    return () => {
      // Clean up event listeners when component unmounts or before re-applying
      if (viewerRef.current) {
        viewerRef.current.removeEventListener('click', handleMarkClick);
        viewerRef.current.removeEventListener('mouseenter', handleMarkHover, true);
        viewerRef.current.removeEventListener('mouseleave', handleMarkLeave, true);
      }
    };
  };
  
  // Event handler for mark clicks using event delegation
  const handleMarkClick = (event) => {
    // Find the closest mark element from the click target
    const mark = event.target.closest('mark[data-issue-id][data-clickable="true"]');
    if (mark) {
      const issueId = mark.getAttribute('data-issue-id');
      if (issueId) {
        setActiveIssue(issueId);
      }
    }
  };
  
  // Event handler for mark hover using event delegation
  const handleMarkHover = (event) => {
    const mark = event.target.closest('mark[data-issue-id][data-clickable="true"]');
    if (mark) {
      const title = mark.getAttribute('data-issue-title');
      const explanation = mark.getAttribute('data-issue-explanation');
      
      if (explanation) {
        const rect = mark.getBoundingClientRect();
        const content = (
          <div className="text-left">
            <div className="font-semibold mb-1 text-white">{title}</div>
            <div className="text-gray-200 text-xs leading-relaxed">{explanation}</div>
          </div>
        );
        showTooltip(content, rect.left + rect.width / 2, rect.bottom);
      }
    }
  };
  
  // Event handler for mark leave using event delegation
  const handleMarkLeave = (event) => {
    const mark = event.target.closest('mark[data-issue-id][data-clickable="true"]');
    if (mark) {
      hideTooltip();
    }
  };
  
  useEffect(() => {
    // Declare variables at the function scope level, so they're accessible in the cleanup function
    let mainTimeoutId;
    let highlightTimeoutId;
    
    console.log('DocumentViewer effect running with documentHtml:', !!documentHtml);
    
    if (documentHtml) {
      setIsLoading(true);
      
      // Use a ref to track the current render cycle
      const renderCycleId = Date.now();
      if (viewerRef.current) {
        viewerRef.current.setAttribute('data-render-cycle', renderCycleId.toString());
      
        mainTimeoutId = setTimeout(() => {
          // Check if this is still the current render cycle
          if (viewerRef.current && viewerRef.current.getAttribute('data-render-cycle') === renderCycleId.toString()) {
            // Set the HTML content
            viewerRef.current.innerHTML = documentHtml;
            console.log('Document HTML set successfully');
            
            // Apply highlighting after a short delay to ensure DOM is ready
            highlightTimeoutId = setTimeout(() => {
              // Double-check that we're still on the same render cycle before highlighting
              if (viewerRef.current && viewerRef.current.getAttribute('data-render-cycle') === renderCycleId.toString()) {
                applyHighlighting();
              }
            }, 100);
          }
          
          // Finish loading regardless of success
          setIsLoading(false);
        }, 500);
      }
    }
    
    // Cleanup function
    return () => {
      if (mainTimeoutId) clearTimeout(mainTimeoutId);
      if (highlightTimeoutId) clearTimeout(highlightTimeoutId);
    };
  }, [documentHtml]);
  
  // Function to apply highlighting (memoized to prevent unnecessary recreations)
  const highlightIssues = useCallback(() => {
    if (documentHtml && !isLoading && viewerRef.current) {
      return applyHighlighting();
    }
  }, [documentHtml, isLoading, issues, showIssues]);

  // Apply highlighting when issues change or active issue changes
  useEffect(() => {
    // Only apply if document is loaded and not in loading state
    const cleanup = highlightIssues();
    
    // Return cleanup function to remove event listeners when component unmounts
    return () => {
      if (typeof cleanup === 'function') {
        cleanup();
      }
    };
  }, [issues, activeIssueId, showIssues, highlightIssues]);
  
  // Helper function to get issue class based on severity
  const getIssueClass = (severity) => {
    switch (severity) {
      case 'Critical':
        return 'bg-red-200 border-b-2 border-red-500 cursor-pointer';
      case 'Major':
        return 'bg-orange-200 border-b-2 border-orange-500 cursor-pointer';
      case 'Minor':
        return 'bg-blue-200 border-b-2 border-blue-500 cursor-pointer';
      default:
        return '';
    }
  };
  
  // Add debug output for component state
  console.log('DocumentViewer render - documentText exists:', !!documentText, 'documentHtml:', !!documentHtml, 'isLoading:', isLoading);

  return (
    <div className="p-8 h-full">
      <TooltipComponent />
      {documentText ? (
        <>
          {isLoading ? (
            <div className="flex flex-col items-center justify-center h-full bg-white shadow-md p-8 rounded-lg">
              <div className="loading-spinner mb-4"></div>
              <p className="text-gray-600 font-medium">Analyzing document...</p>
              <p className="text-sm text-gray-500 mt-1">Checking for APA 7th edition compliance</p>
            </div>
          ) : (
            <div className="bg-white shadow-lg rounded-lg p-6 border border-gray-200">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg font-semibold text-blue-700">Document Content</h3>
                <button 
                  onClick={() => setShowIssues(!showIssues)}
                  className={`px-3 py-1 rounded-md text-sm font-medium flex items-center ${
                    showIssues 
                      ? 'bg-blue-100 text-blue-700 hover:bg-blue-200' 
                      : 'bg-gray-100 text-gray-600 hover:bg-gray-200'
                  }`}
                >
                  {showIssues ? (
                    <>
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M10 12a2 2 0 100-4 2 2 0 000 4z" />
                        <path fillRule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clipRule="evenodd" />
                      </svg>
                      Hide Issues
                    </>
                  ) : (
                    <>
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z" clipRule="evenodd" />
                        <path d="M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z" />
                      </svg>
                      Show Issues
                    </>
                  )}
                </button>
              </div>
              <div 
                ref={viewerRef}
                className="prose max-w-none bg-white p-4 rounded border border-gray-100"
                style={{
                  fontFamily: '"Times New Roman", Times, serif',
                  fontSize: '12pt',
                  lineHeight: '1.6',
                  color: '#1f2937'
                }}
              >
                {/* THIS IS THE CRITICAL CHANGE: Use dangerouslySetInnerHTML as a backup rendering method */}
                {documentHtml ? (
                  <div dangerouslySetInnerHTML={{ __html: documentHtml }} />
                ) : (
                  <div>
                    <p>Document loaded but HTML content could not be displayed.</p>
                    <p className="text-gray-500 mt-2">Raw text content:</p>
                    <div className="mt-2 p-4 bg-gray-50 rounded-lg">
                      {documentText ? documentText.substring(0, 500) + (documentText.length > 500 ? '...' : '') : 'No text content available'}
                    </div>
                  </div>
                )}
              </div>
            </div>
          )}
        </>
      ) : (
        <div className="flex flex-col items-center justify-center h-full py-20 bg-gradient-to-b from-white to-blue-50 rounded-lg shadow-sm border border-gray-100 animate-scale-in">
          <div className="bg-blue-50 p-5 rounded-full mb-6 shadow-inner flex items-center justify-center">
            <FileText className="h-20 w-20 text-blue-500" />
          </div>
          <h2 className="text-2xl font-semibold text-gray-800 mb-3">Upload a document to begin</h2>
          <p className="text-gray-500 mb-8">Validate your academic paper against APA 7th edition guidelines</p>
          <div className="border-t border-gray-200 pt-6 w-full max-w-md">
            <div className="bg-blue-50 rounded-md p-4 flex items-start hover:bg-blue-100 transition-colors hover-shadow">
              <InfoIcon className="h-5 w-5 text-blue-500 mt-0.5 mr-2 flex-shrink-0" />
              <span className="text-sm text-blue-800">Only .docx files are supported. For best results, ensure your document is properly formatted.</span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\ErrorBoundary.js
'use client';

import { Component } from 'react';
import { AlertTriangle } from 'lucide-react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { 
      hasError: false,
      error: null,
      errorInfo: null
    };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render shows the fallback UI
    return { hasError: true, error };
  }

  componentDidCatch(error, errorInfo) {
    // You can log the error to an error reporting service
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
    this.setState({
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // Render fallback UI
      return (
        <div className="flex flex-col items-center justify-center p-6 bg-red-50 border border-red-200 rounded-lg shadow-sm text-center">
          <div className="bg-red-100 p-3 rounded-full mb-4">
            <AlertTriangle className="h-8 w-8 text-red-500" />
          </div>
          <h2 className="text-lg font-semibold text-red-700 mb-2">Something went wrong</h2>
          <p className="text-sm text-red-600 mb-4">
            {this.state.error ? this.state.error.toString() : 'An unexpected error occurred'}
          </p>
          <button
            onClick={() => window.location.reload()}
            className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
          >
            Reload Page
          </button>
          {this.props.showDetails && this.state.errorInfo && (
            <div className="mt-6 w-full">
              <details className="text-left">
                <summary className="text-sm font-medium text-red-800 cursor-pointer">Error Details</summary>
                <pre className="mt-2 p-3 text-xs text-red-800 bg-red-100 overflow-auto rounded-md">
                  {this.state.errorInfo.componentStack}
                </pre>
              </details>
            </div>
          )}
        </div>
      );
    }

    return this.props.children; 
  }
}

export default ErrorBoundary;


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\Header.js
'use client';

import { useState, useEffect, useRef } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import { BookOpen, Upload, Download, File, AlertTriangle, ChevronDown } from 'lucide-react';
import AnalysisSettings from '@/components/AnalysisSettings';

export default function Header() {
  const { 
    uploadDocument, 
    documentName, 
    analyzeDocument, 
    analyzeDocumentDebounced, 
    analysisScore, 
    exportDocument, 
    processingState,
    analysisSettings 
  } = useDocumentStore();
  
  // Local state for UI-only errors (now using store for processing state)
  const [uploadError, setUploadError] = useState(null);
  const [showExportDropdown, setShowExportDropdown] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const exportDropdownRef = useRef(null);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (exportDropdownRef.current && !exportDropdownRef.current.contains(event.target)) {
        setShowExportDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);
  
  const handleFileUpload = async (e) => {
    // Reset error state
    setUploadError(null);
    
    const file = e.target.files[0];
    if (!file) return;
    
    // Validate file type
    if (!file.name.endsWith('.docx')) {
      setUploadError('Please upload a .docx file only');
      return;
    }
    
    // Validate file size (max 10MB)
    const maxSize = 10 * 1024 * 1024; // 10MB in bytes
    if (file.size > maxSize) {
      setUploadError(`File size exceeds limit (max ${maxSize / (1024 * 1024)}MB)`);
      return;
    }
    
    try {
      // Upload document (processing state is managed inside the store now)
      const success = await uploadDocument(file);
      
      if (success) {
        // Only analyze if upload was successful
        // Use debounced analysis for better performance with large documents
        const analysisResult = await analyzeDocumentDebounced();
        
        // If analysis failed, display error
        if (!analysisResult?.success && analysisResult?.error) {
          setUploadError(`Analysis error: ${analysisResult.error}`);
        }
      } else {
        // If upload failed and store didn't set an error, set a generic one
        if (!processingState.lastError) {
          setUploadError('Failed to process document. Please try a different file.');
        }
      }
    } catch (error) {
      console.error('Error in file upload handler:', error);
      setUploadError(`Error: ${error.message || 'Failed to upload document'}`);
    } finally {
      // Reset file input to allow re-uploading the same file
      e.target.value = '';
    }
  };

  const handleExport = async (format) => {
    setIsExporting(true);
    setShowExportDropdown(false);
    
    try {
      await exportDocument(format);
    } catch (error) {
      console.error('Export failed:', error);
      alert(`Failed to export ${format.toUpperCase()} document. Please try again.`);
    } finally {
      setIsExporting(false);
    }
  };
  
  return (
    <header className="bg-gradient-to-r from-blue-600 via-blue-700 to-indigo-700 shadow-md">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div className="py-4 flex justify-between items-center">
          <div className="flex items-center">
            <h1 className="text-2xl font-bold text-white mr-8 flex items-center">
              <div className="bg-white/10 p-2 rounded-lg mr-3">
                <BookOpen className="h-8 w-8 text-white" />
              </div>
              APA 7 Checker
            </h1>
            <div className="flex space-x-4">
              <div className="flex flex-col">
                <label className={`${processingState.isUploading ? 'opacity-75 cursor-wait' : 'hover:bg-gray-50'} bg-white text-blue-700 border border-transparent hover:border-blue-100 px-4 py-2 rounded-md cursor-pointer transition-all shadow-md hover:shadow-lg flex items-center group`}>
                  <Upload className={`h-5 w-5 mr-2 ${processingState.isUploading ? 'animate-pulse' : ''} text-blue-500 group-hover:text-blue-600`} />
                  {
                    processingState.isUploading ? 'Uploading...' : 
                    processingState.isSchedulingAnalysis ? 'Scheduling Analysis...' :
                    processingState.isAnalyzing ? 'Analyzing...' : 
                    'Upload Document'
                  }
                  <input
                    type="file"
                    accept=".docx"
                    className="hidden"
                    onChange={handleFileUpload}
                    disabled={processingState.isUploading || processingState.isAnalyzing || processingState.isSchedulingAnalysis}
                  />
                </label>
                
                {uploadError && (
                  <div className="mt-1 text-xs text-red-600 flex items-center bg-red-50 px-2 py-1 rounded border border-red-100">
                    <AlertTriangle className="h-3 w-3 mr-1 flex-shrink-0" />
                    {uploadError}
                  </div>
                )}
              </div>
              
              {documentName && (
                <div className="relative" ref={exportDropdownRef}>
                  <button 
                    className="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-md transition-colors shadow-md hover:shadow-lg flex items-center"
                    onClick={() => setShowExportDropdown(!showExportDropdown)}
                    disabled={isExporting}
                  >
                    <Download className="h-5 w-5 mr-2" />
                    {isExporting ? 'Exporting...' : 'Export Document'}
                    <ChevronDown className="h-4 w-4 ml-1" />
                  </button>

                  {showExportDropdown && (
                    <div className="absolute right-0 top-full mt-2 w-48 bg-white border border-gray-200 rounded-md shadow-lg z-50">
                      <div className="py-1">
                        <button
                          onClick={() => handleExport('html')}
                          className="flex items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 transition-colors"
                          disabled={isExporting}
                        >
                          <File className="h-4 w-4 mr-2 text-orange-500" />
                          Export as HTML
                          <span className="ml-auto text-xs text-gray-500">Viewable in browser</span>
                        </button>
                        <button
                          onClick={() => handleExport('docx')}
                          className="flex items-center w-full px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 transition-colors"
                          disabled={isExporting}
                        >
                          <File className="h-4 w-4 mr-2 text-blue-500" />
                          Export as DOCX
                          <span className="ml-auto text-xs text-gray-500">Editable in Word</span>
                        </button>
                      </div>
                    </div>
                  )}
                </div>
              )}
              
              <AnalysisSettings />
            </div>
          </div>
          
          <div className="flex items-center space-x-6">
            {analysisScore !== null && (
              <div className="flex flex-col items-end bg-white/20 backdrop-blur-sm rounded-lg px-4 py-2 shadow-inner border border-white/30">
                <div className="flex items-center mb-1">
                  <span className="text-white mr-2 text-sm">APA Compliance:</span>
                  <span className="text-white font-bold">{analysisScore}%</span>
                </div>
                <div className="bg-gray-200/30 rounded-full h-3 w-40 shadow-inner">
                  <div 
                    className={`h-3 rounded-full shadow-sm ${
                      analysisScore > 80 ? 'bg-gradient-to-r from-green-400 to-green-500' : 
                      analysisScore > 50 ? 'bg-gradient-to-r from-yellow-400 to-yellow-500' : 
                      'bg-gradient-to-r from-red-400 to-red-500'
                    }`}
                    style={{ width: `${analysisScore}%` }}
                  ></div>
                </div>
              </div>
            )}
            
            {documentName && (
              <div className="text-white/90 bg-white/10 backdrop-blur-sm px-4 py-2 rounded-lg flex items-center shadow-inner border border-white/30">
                <File className="h-5 w-5 mr-2 text-white/80" />
                <span className="font-medium truncate max-w-[200px]">{documentName}</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </header>
  );
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\IssuesPanel.js
'use client';

import { useState, useMemo, useCallback } from 'react';
import { useDocumentStore } from '@/store/documentStore';
import React from 'react';
import { 
  ClipboardList, 
  AlertTriangle, 
  AlertCircle, 
  AlertOctagon, 
  PieChart, 
  Check,
  ChevronDown,
  FileText
} from 'lucide-react';

export default function IssuesPanel() {
  const { issues, activeIssueId, setActiveIssue, applyFix, processingState } = useDocumentStore();
  const [expandedCategories, setExpandedCategories] = useState({
    Critical: true,
    Major: true,
    Minor: false
  });
  
  // Group issues by severity (memoized to prevent recalculation on re-renders)
  const groupedIssues = useMemo(() => {
    return (issues || []).reduce((acc, issue) => {
      if (!acc[issue.severity]) {
        acc[issue.severity] = [];
      }
      acc[issue.severity].push(issue);
      return acc;
    }, {});
  }, [issues]);
  
  // Count issues by severity (memoized)
  const issueCounts = useMemo(() => ({
    Critical: groupedIssues.Critical?.length || 0,
    Major: groupedIssues.Major?.length || 0,
    Minor: groupedIssues.Minor?.length || 0
  }), [groupedIssues]);
  
  // Toggle category expansion (use useCallback to prevent unnecessary function recreation)
  const toggleCategory = useCallback((category) => {
    setExpandedCategories(prev => ({
      ...prev,
      [category]: !prev[category]
    }));
  }, []);
  
  // Calculate compliance score (memoized)
  const { totalIssues, weightedScore } = useMemo(() => {
    const total = issueCounts.Critical + issueCounts.Major + issueCounts.Minor;
    const score = total > 0 
      ? Math.max(0, 100 - (issueCounts.Critical * 5 + issueCounts.Major * 3 + issueCounts.Minor)) 
      : null;
    return { totalIssues: total, weightedScore: score };
  }, [issueCounts]);
  
  return (
    <div className="h-full bg-gray-50 p-4">
      <div className="flex justify-between items-center mb-5">
        <h2 className="text-xl font-bold text-gray-800 flex items-center">
          <ClipboardList className="h-6 w-6 mr-2 text-blue-600" />
          Document Issues
        </h2>
        {totalIssues > 0 && (
          <span className="bg-blue-100 text-blue-800 text-xs font-medium px-2.5 py-0.5 rounded-full flex items-center">
            <span className="w-2 h-2 bg-blue-500 rounded-full mr-1"></span>
            {totalIssues} {totalIssues === 1 ? 'Issue' : 'Issues'}
          </span>
        )}
      </div>
      
      {totalIssues > 0 ? (
        <div className="space-y-5">
          {/* Critical Issues */}
          {issueCounts.Critical > 0 && (
            <IssueCategory 
              title="Critical Issues" 
              count={issueCounts.Critical} 
              severity="Critical"
              expanded={expandedCategories.Critical}
              toggleExpanded={() => toggleCategory('Critical')}
            >
              {expandedCategories.Critical && groupedIssues.Critical.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
          
          {/* Major Issues */}
          {issueCounts.Major > 0 && (
            <IssueCategory 
              title="Major Issues" 
              count={issueCounts.Major} 
              severity="Major"
              expanded={expandedCategories.Major}
              toggleExpanded={() => toggleCategory('Major')}
            >
              {expandedCategories.Major && groupedIssues.Major.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
          
          {/* Minor Issues */}
          {issueCounts.Minor > 0 && (
            <IssueCategory 
              title="Minor Issues" 
              count={issueCounts.Minor} 
              severity="Minor"
              expanded={expandedCategories.Minor}
              toggleExpanded={() => toggleCategory('Minor')}
            >
              {expandedCategories.Minor && groupedIssues.Minor.map(issue => (
                <IssueItem 
                  key={issue.id}
                  issue={issue}
                  isActive={activeIssueId === issue.id}
                  onSelect={() => setActiveIssue(issue.id)}
                  onApplyFix={() => applyFix(issue.id)}
                  isApplyingFix={processingState.isApplyingFix && processingState.currentFixId === issue.id}
                />
              ))}
            </IssueCategory>
          )}
        </div>
      ) : issues.length === 0 ? (
        <div className="flex flex-col items-center justify-center py-16 text-gray-500">
          <div className="bg-gray-100 p-4 rounded-full mb-4 flex items-center justify-center">
            <FileText className="h-12 w-12 text-gray-400" />
          </div>
          <p className="text-xl font-medium text-gray-600">No document loaded</p>
          <p className="mt-2 text-gray-500 max-w-xs text-center">Upload a document using the button above to check it against APA 7th Edition guidelines</p>
        </div>
      ) : (
        <div className="bg-gradient-to-r from-green-50 to-emerald-50 p-6 rounded-lg border border-green-100 shadow-sm">
          <div className="flex items-center">
            <div className="bg-green-100 p-2 rounded-full flex items-center justify-center">
              <Check className="h-8 w-8 text-green-600" />
            </div>
            <div className="ml-4">
              <p className="text-lg font-semibold text-green-800">Perfect! No APA issues found.</p>
              <p className="text-sm mt-1 text-green-700">Your document follows APA 7th Edition guidelines.</p>
            </div>
          </div>
        </div>
      )}
      
      {/* Document Statistics */}
      {issues.length > 0 && (
        <div className="mt-6 bg-white p-5 rounded-lg border border-gray-200 shadow-sm">
          <h3 className="text-sm font-semibold text-gray-700 mb-4 flex items-center">
            <PieChart className="h-4 w-4 mr-1 text-blue-500" />
            Document Statistics
          </h3>
          <div className="grid grid-cols-2 gap-4">
            <div className="bg-gray-50 p-3 rounded-md border border-gray-100">
              <p className="text-xs text-gray-500 mb-1">Compliance Score</p>
              <div className="flex items-center">
                <div className={`w-2 h-8 rounded-full mr-2 ${
                  weightedScore > 80 ? 'bg-green-500' : weightedScore > 50 ? 'bg-yellow-500' : 'bg-red-500'
                }`}></div>
                <p className="text-2xl font-bold text-gray-800">{weightedScore}%</p>
              </div>
            </div>
            <div className="bg-gray-50 p-3 rounded-md border border-gray-100">
              <p className="text-xs text-gray-500 mb-1">Issue Breakdown</p>
              <div className="flex space-x-3 items-end">
                {issueCounts.Critical > 0 && (
                  <div className="flex flex-col items-center">
                    <span className="text-xs text-red-600">{issueCounts.Critical}</span>
                    <div className="bg-red-500 w-4 rounded-t-sm" style={{height: `${issueCounts.Critical * 6}px`}}></div>
                    <span className="text-xs text-gray-500 mt-1">Critical</span>
                  </div>
                )}
                {issueCounts.Major > 0 && (
                  <div className="flex flex-col items-center">
                    <span className="text-xs text-orange-600">{issueCounts.Major}</span>
                    <div className="bg-orange-500 w-4 rounded-t-sm" style={{height: `${issueCounts.Major * 6}px`}}></div>
                    <span className="text-xs text-gray-500 mt-1">Major</span>
                  </div>
                )}
                {issueCounts.Minor > 0 && (
                  <div className="flex flex-col items-center">
                    <span className="text-xs text-blue-600">{issueCounts.Minor}</span>
                    <div className="bg-blue-500 w-4 rounded-t-sm" style={{height: `${issueCounts.Minor * 6}px`}}></div>
                    <span className="text-xs text-gray-500 mt-1">Minor</span>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

// Memoize the IssueCategory component to prevent unnecessary renders
const IssueCategory = React.memo(function IssueCategory({ title, count, severity, expanded, toggleExpanded, children }) {
  // Set colors based on severity
  const getStyles = () => {
    switch (severity) {
      case 'Critical': 
        return {
          bg: 'bg-gradient-to-r from-red-50 to-red-100',
          text: 'text-red-800',
          border: 'border-red-200',
          icon: 'text-red-500',
          badge: 'bg-red-500',
          shadow: 'shadow-red-100'
        };
      case 'Major': 
        return {
          bg: 'bg-gradient-to-r from-orange-50 to-amber-100',
          text: 'text-orange-800',
          border: 'border-orange-200',
          icon: 'text-orange-500',
          badge: 'bg-orange-500',
          shadow: 'shadow-orange-100'
        };
      case 'Minor': 
        return {
          bg: 'bg-gradient-to-r from-blue-50 to-blue-100',
          text: 'text-blue-800',
          border: 'border-blue-200',
          icon: 'text-blue-500',
          badge: 'bg-blue-500',
          shadow: 'shadow-blue-100'
        };
      default: 
        return {
          bg: 'bg-gray-100',
          text: 'text-gray-800',
          border: 'border-gray-200',
          icon: 'text-gray-500',
          badge: 'bg-gray-500',
          shadow: 'shadow-gray-100'
        };
    }
  };
  
  const styles = getStyles();
  
  // Get icon based on severity
  const getIcon = () => {
    switch (severity) {
      case 'Critical':
        return <AlertOctagon className="h-5 w-5 mr-2" />;
      case 'Major':
        return <AlertTriangle className="h-5 w-5 mr-2" />;
      case 'Minor':
        return <AlertCircle className="h-5 w-5 mr-2" />;
      default:
        return null;
    }
  };
  
  return (
    <div className={`rounded-lg overflow-hidden border ${styles.border} shadow-sm ${styles.shadow} issue-category hover-shadow`}>
      <button 
        onClick={toggleExpanded}
        className={`w-full flex justify-between items-center px-5 py-3.5 ${styles.bg} ${styles.text} transition-all duration-200 hover:shadow-inner`}
      >
        <span className="font-medium flex items-center text-base">
          <span className={`${styles.icon}`}>{getIcon()}</span>
          {title}
        </span>
        <div className="flex items-center">
          <span className={`${styles.badge} text-white text-xs font-bold rounded-full w-6 h-6 flex items-center justify-center ${count > 0 ? 'animate-pulse-blue' : ''}`}>{count}</span>
          <ChevronDown 
            className={`h-5 w-5 ml-3 transition-transform duration-300 ease-in-out ${expanded ? 'transform rotate-180' : ''} ${styles.icon}`}
          />
        </div>
      </button>
      
      {expanded && (
        <div className="bg-white divide-y divide-gray-100 transition-all duration-300 ease-in-out animate-fade-in">
          {children}
        </div>
      )}
    </div>
  );
});

// Memoize IssueItem to prevent unnecessary re-renders
const IssueItem = React.memo(function IssueItem({ issue, isActive, onSelect, onApplyFix, isApplyingFix = false }) {
  // Get highlight color based on severity
  const getHighlightColor = () => {
    switch (issue.severity) {
      case 'Critical': return 'border-red-500 bg-red-50';
      case 'Major': return 'border-orange-500 bg-orange-50';
      case 'Minor': return 'border-blue-500 bg-blue-50';
      default: return 'border-gray-300 bg-gray-50';
    }
  };
  
  // Get icon based on severity
  const getIcon = () => {
    switch (issue.severity) {
      case 'Critical':
        return <AlertOctagon className="h-4 w-4 text-red-500" />;
      case 'Major':
        return <AlertTriangle className="h-4 w-4 text-orange-500" />;
      case 'Minor':
        return <AlertCircle className="h-4 w-4 text-blue-500" />;
      default:
        return null;
    }
  };
  
  return (
    <div 
      className={`px-4 py-4 hover:bg-gray-50 cursor-pointer transition-colors duration-150 ease-in-out issue-item ${
        isActive ? `border-l-4 ${getHighlightColor()}` : 'border-l-4 border-transparent'
      }`}
      onClick={onSelect}
    >
      <div className="flex justify-between">
        <div className="flex-1 pr-4">
          <div className="flex items-center mb-1.5">
            {getIcon()}
            <p className="text-sm font-semibold text-gray-800 ml-1">{issue.title}</p>
          </div>
          <p className="text-xs text-gray-600 mb-2 leading-relaxed">{issue.description}</p>
          {issue.text && (
            <div className="mt-2 p-3 bg-gray-50 border border-gray-200 rounded-md text-xs font-mono text-gray-700 relative animate-scale-in">
              <div className="absolute -left-1 -top-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -right-1 -top-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -left-1 -bottom-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              <div className="absolute -right-1 -bottom-1 h-2 w-2 bg-gray-300 rounded-full"></div>
              "{issue.text}"
            </div>
          )}
        </div>
        
        {issue.hasFix && (
          <div className="flex flex-col justify-center">
            <button 
              onClick={(e) => {
                e.stopPropagation();
                if (!isApplyingFix) onApplyFix();
              }}
              disabled={isApplyingFix}
              className={`flex items-center justify-center text-white text-xs px-4 py-1.5 rounded-md shadow-sm transition-all h-fit whitespace-nowrap font-medium ${
                isApplyingFix 
                  ? 'bg-blue-400 cursor-not-allowed' 
                  : 'bg-gradient-to-r from-blue-500 to-blue-600 hover:from-blue-600 hover:to-blue-700 hover:shadow hover:translate-y-[-1px]'
              }`}
            >
              {isApplyingFix ? (
                <>
                  <svg className="animate-spin h-3.5 w-3.5 mr-1" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                  </svg>
                  Fixing...
                </>
              ) : (
                <>
                  <Check className="h-3.5 w-3.5 mr-1" />
                  Apply Fix
                </>
              )}
            </button>
          </div>
        )}
      </div>
    </div>
  );
});


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\components\Tooltip.js
'use client';

import { useState, useRef, useEffect } from 'react';

export default function Tooltip({ children, content, delay = 300 }) {
  const [isVisible, setIsVisible] = useState(false);
  const [position, setPosition] = useState({ top: 0, left: 0 });
  const tooltipRef = useRef(null);
  const containerRef = useRef(null);
  let timeoutId = useRef(null);

  const showTooltip = (e) => {
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
    }
    
    timeoutId.current = setTimeout(() => {
      const rect = e.currentTarget.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      
      // Calculate position
      let top = rect.bottom + scrollTop + 8;
      let left = rect.left + scrollLeft + (rect.width / 2);
      
      // Adjust if tooltip would go off screen
      if (tooltipRef.current) {
        const tooltipRect = tooltipRef.current.getBoundingClientRect();
        
        // Adjust horizontal position if tooltip would overflow
        if (left + tooltipRect.width / 2 > window.innerWidth) {
          left = window.innerWidth - tooltipRect.width - 16;
        } else if (left - tooltipRect.width / 2 < 0) {
          left = tooltipRect.width / 2 + 16;
        }
        
        // Adjust vertical position if tooltip would overflow
        if (top + tooltipRect.height > window.innerHeight + scrollTop) {
          top = rect.top + scrollTop - tooltipRect.height - 8;
        }
      }
      
      setPosition({ top, left });
      setIsVisible(true);
    }, delay);
  };

  const hideTooltip = () => {
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
    }
    setIsVisible(false);
  };

  useEffect(() => {
    return () => {
      if (timeoutId.current) {
        clearTimeout(timeoutId.current);
      }
    };
  }, []);

  if (!content) {
    return children;
  }

  return (
    <>
      <span
        ref={containerRef}
        onMouseEnter={showTooltip}
        onMouseLeave={hideTooltip}
        onFocus={showTooltip}
        onBlur={hideTooltip}
        className="relative inline-block"
      >
        {children}
      </span>
      
      {isVisible && (
        <div
          ref={tooltipRef}
          className="fixed z-50 px-3 py-2 text-sm text-white bg-gray-900 rounded-lg shadow-lg max-w-xs pointer-events-none"
          style={{
            top: position.top,
            left: position.left,
            transform: 'translateX(-50%)',
          }}
        >
          <div className="relative">
            {content}
            {/* Tooltip arrow */}
            <div
              className="absolute bottom-full left-1/2 transform -translate-x-1/2 w-0 h-0"
              style={{
                borderLeft: '6px solid transparent',
                borderRight: '6px solid transparent',
                borderBottom: '6px solid #1f2937',
                marginBottom: '-1px'
              }}
            />
          </div>
        </div>
      )}
    </>
  );
}

// Hook for creating dynamic tooltips
export function useTooltip() {
  const [tooltipContent, setTooltipContent] = useState(null);
  const [tooltipPosition, setTooltipPosition] = useState({ x: 0, y: 0 });
  const [isTooltipVisible, setIsTooltipVisible] = useState(false);

  const showTooltip = (content, x, y) => {
    setTooltipContent(content);
    setTooltipPosition({ x, y });
    setIsTooltipVisible(true);
  };

  const hideTooltip = () => {
    setIsTooltipVisible(false);
    setTooltipContent(null);
  };

  const TooltipComponent = () => {
    if (!isTooltipVisible || !tooltipContent) return null;

    return (
      <div
        className="fixed z-50 px-3 py-2 text-sm text-white bg-gray-900 rounded-lg shadow-lg max-w-xs pointer-events-none"
        style={{
          top: tooltipPosition.y + 10,
          left: tooltipPosition.x,
          transform: 'translateX(-50%)',
        }}
      >
        <div className="relative">
          {tooltipContent}
          {/* Tooltip arrow */}
          <div
            className="absolute bottom-full left-1/2 transform -translate-x-1/2 w-0 h-0"
            style={{
              borderLeft: '6px solid transparent',
              borderRight: '6px solid transparent',
              borderBottom: '6px solid #1f2937',
              marginBottom: '-1px'
            }}
          />
        </div>
      </div>
    );
  };

  return { showTooltip, hideTooltip, TooltipComponent };
}


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\store\documentStore.js
'use client';

import { create } from 'zustand';
import mammoth from 'mammoth';
import { v4 as uuidv4 } from 'uuid';

// Import our APA analysis rules
import { analyzeAPAGuidelines } from '@/utils/apaAnalyzer';

// Helper function to escape special regex characters
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Debounce utility function
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Create a debounced analysis function outside the store to maintain the timeout reference
let debouncedAnalysisTimeout;
const createDebouncedAnalysis = (analyzeFunction, delay = 1000) => {
  return () => {
    return new Promise((resolve, reject) => {
      if (debouncedAnalysisTimeout) {
        clearTimeout(debouncedAnalysisTimeout);
      }
      
      debouncedAnalysisTimeout = setTimeout(async () => {
        try {
          const result = await analyzeFunction();
          resolve(result);
        } catch (error) {
          reject(error);
        }
      }, delay);
    });
  };
};

export const useDocumentStore = create((set, get) => ({
  // Document state
  documentText: null,
  documentHtml: null,
  documentName: null,
  documentStats: {
    wordCount: 0,
    charCount: 0
  },
  
  // Issues and analysis state
  issues: [],
  activeIssueId: null,
  analysisScore: null,
  
  // Analysis settings
  analysisSettings: {
    debounceDelay: 1500, // milliseconds
    autoAnalyze: true,   // whether to auto-analyze on document changes
  },
  
  // Export functionality
  exportDocument: async (format = 'html') => {
    const { documentHtml, documentName } = get();
    
    if (!documentHtml) {
      alert('No document to export');
      return false;
    }
    
    try {
      if (format === 'docx') {
        return await get().exportDocx();
      } else {
        return await get().exportHtml();
      }
    } catch (error) {
      console.error('Error exporting document:', error);
      alert('Failed to export document. Please try again.');
      return false;
    }
  },

  // Export as HTML
  exportHtml: () => {
    const { documentHtml, documentName } = get();
    
    try {
      // Create a full HTML document with proper styling
      const fullHtml = `
        <!DOCTYPE html>
        <html lang="en">
        <head>
          <meta charset="UTF-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>APA Formatted Document</title>
          <style>
            body {
              font-family: "Times New Roman", Times, serif;
              font-size: 12pt;
              line-height: 2;
              margin: 1in;
            }
            p {
              text-indent: 0.5in;
              margin-top: 0;
              margin-bottom: 0;
            }
            h1, h2, h3, h4, h5 {
              font-weight: bold;
              margin-top: 1em;
              margin-bottom: 1em;
            }
            .title-page {
              text-align: center;
              margin-bottom: 2em;
            }
            .abstract {
              margin-bottom: 2em;
            }
            .abstract h2 {
              text-align: center;
            }
            .references h2 {
              text-align: center;
            }
            .references p {
              text-indent: 0;
              padding-left: 0.5in;
              text-indent: -0.5in;
              margin-bottom: 1em;
            }
          </style>
        </head>
        <body>
          ${documentHtml}
        </body>
        </html>
      `;
      
      // Create a blob from the HTML
      const blob = new Blob([fullHtml], { type: 'text/html' });
      
      // Create a URL for the blob
      const url = URL.createObjectURL(blob);
      
      // Create a download link
      const a = document.createElement('a');
      a.href = url;
      a.download = documentName ? 
        documentName.replace('.docx', '_APA_formatted.html') : 
        'apa_formatted_document.html';
      
      // Append to the body, click and remove
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Release the URL
      URL.revokeObjectURL(url);
      
      return true;
    } catch (error) {
      console.error('Error exporting HTML document:', error);
      throw error;
    }
  },

  // Export as DOCX
  exportDocx: async () => {
    const { documentHtml, documentName } = get();
    
    try {
      // Dynamically import html-to-docx
      const { default: HTMLtoDOCX } = await import('html-to-docx');
      
      // Clean up the HTML and prepare for DOCX conversion
      const cleanHtml = documentHtml
        // Remove any existing mark elements (issue highlights)
        .replace(/<mark[^>]*>(.*?)<\/mark>/gi, '$1')
        // Clean up any data attributes
        .replace(/\s*data-[a-z-]+="[^"]*"/gi, '')
        // Remove any onclick or other event handlers
        .replace(/\s*on[a-z]+="[^"]*"/gi, '');
      
      // Create the full document with APA styling
      const styledHtml = `
        <html>
        <head>
          <style>
            body {
              font-family: 'Times New Roman', Times, serif;
              font-size: 12pt;
              line-height: 2.0;
              margin: 1in;
            }
            p {
              text-indent: 0.5in;
              margin-top: 0;
              margin-bottom: 0;
            }
            h1, h2, h3, h4, h5, h6 {
              font-weight: bold;
              margin-top: 12pt;
              margin-bottom: 12pt;
              text-align: left;
            }
            h1 {
              text-align: center;
              font-size: 12pt;
            }
            h2 {
              text-align: center;
              font-size: 12pt;
            }
            .title-page {
              text-align: center;
              margin-bottom: 24pt;
            }
            .abstract {
              margin-bottom: 24pt;
            }
            .abstract h2 {
              text-align: center;
            }
            .references h2 {
              text-align: center;
            }
            .references p {
              text-indent: -0.5in;
              padding-left: 0.5in;
              margin-bottom: 12pt;
            }
            table {
              border-collapse: collapse;
              width: 100%;
              margin: 12pt 0;
            }
            td, th {
              border: 1pt solid black;
              padding: 6pt;
              text-align: left;
            }
            th {
              font-weight: bold;
              background-color: #f0f0f0;
            }
            .page-break {
              page-break-before: always;
            }
          </style>
        </head>
        <body>
          ${cleanHtml}
        </body>
        </html>
      `;
      
      // Configure conversion options
      const options = {
        orientation: 'portrait',
        margins: {
          top: 1440, // 1 inch in twips (1440 twips = 1 inch)
          right: 1440,
          bottom: 1440,
          left: 1440
        },
        title: documentName ? documentName.replace('.docx', '') : 'APA Formatted Document',
        creator: 'APA 7th Edition Document Checker',
        description: 'Document formatted according to APA 7th edition guidelines'
      };
      
      // Convert HTML to DOCX
      const docxBuffer = await HTMLtoDOCX(styledHtml, null, options);
      
      // Create a blob from the buffer
      const blob = new Blob([docxBuffer], { 
        type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
      });
      
      // Create a URL for the blob
      const url = URL.createObjectURL(blob);
      
      // Create a download link
      const a = document.createElement('a');
      a.href = url;
      a.download = documentName ? 
        documentName.replace('.docx', '_APA_formatted.docx') : 
        'apa_formatted_document.docx';
      
      // Append to the body, click and remove
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      // Release the URL
      URL.revokeObjectURL(url);
      
      return true;
    } catch (error) {
      console.error('Error exporting DOCX document:', error);
      throw error;
    }
  },
  
  // Document processing status
  processingState: {
    isUploading: false,
    isAnalyzing: false,
    isApplyingFix: false,
    lastError: null,
    progress: 0,
    currentFixId: null,
    isSchedulingAnalysis: false, // for debounced analysis feedback
    analysisScheduledAt: null    // timestamp when analysis was scheduled
  },
  
  // Upload a document and convert it to HTML
  uploadDocument: async (file) => {
    try {
      // Set processing state
      set({
        processingState: {
          ...get().processingState,
          isUploading: true,
          lastError: null,
          progress: 10
        }
      });
      
      console.log('Upload document started for file:', file.name);
      // Update document name first for better UX feedback
      set({ documentName: file.name });
      
      // Read the file
      const arrayBuffer = await file.arrayBuffer();
      console.log('File read as array buffer');
      
      // Update progress
      set({
        processingState: {
          ...get().processingState,
          progress: 30
        }
      });
      
      // Convert docx to HTML
      const result = await mammoth.convertToHtml({ arrayBuffer });
      const html = result.value;
      console.log('HTML conversion complete, length:', html?.length);
      
      // Update progress
      set({
        processingState: {
          ...get().processingState,
          progress: 60
        }
      });
      
      // Extract text (for analysis)
      const textResult = await mammoth.extractRawText({ arrayBuffer });
      const text = textResult.value;
      console.log('Text extraction complete, length:', text?.length);
      
      // Check that we have valid content before proceeding
      if (!html || !text) {
        throw new Error('Failed to extract content from document');
      }
      
      // Calculate stats
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      const chars = text.length;
      
      // Update progress
      set({
        processingState: {
          ...get().processingState,
          progress: 90
        }
      });
      
      // Update state in a single batch for consistency
      console.log('Updating document store state with HTML and text');
      set(state => ({
        documentHtml: html,
        documentText: text,
        documentStats: {
          wordCount: words,
          charCount: chars
        },
        issues: [], // Clear previous issues
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          isUploading: false,
          progress: 100
        }
      }));
      
      console.log('Document store state updated successfully');
      return true;
    } catch (error) {
      console.error('Error uploading document:', error);
      
      // Set error state but don't clear existing document if there is one
      set(state => ({
        processingState: {
          ...state.processingState,
          isUploading: false,
          lastError: error.message || 'Failed to process document',
          progress: 0
        }
      }));
      
      return false;
    }
  },
  
  // Analyze the document for APA issues
  analyzeDocument: async () => {
    const { documentText, documentHtml } = get();
    
    if (!documentText) {
      console.warn('Cannot analyze document: No document text available');
      return;
    }
    
    try {
      // Update state to indicate analysis has started
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null
        }
      }));
      
      // Run our APA analysis (wrapped in Promise for better error handling)
      const analysisResults = await new Promise((resolve, reject) => {
        try {
          // Use setTimeout to prevent UI freeze during analysis
          setTimeout(() => {
            try {
              const results = analyzeAPAGuidelines(documentText || '', documentHtml || '');
              resolve(results);
            } catch (error) {
              reject(error);
            }
          }, 0);
        } catch (error) {
          reject(error);
        }
      });
      
      // Map results to our issues format
      const issues = analysisResults.map(issue => ({
        id: uuidv4(),
        title: issue.title,
        description: issue.description,
        text: issue.text,
        severity: issue.severity,
        location: issue.location,
        hasFix: issue.hasFix,
        fixAction: issue.fixAction,
        explanation: issue.explanation || issue.description // Include explanation for tooltips
      }));
      
      // Calculate compliance score (weighted by severity)
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;
      
      const totalIssues = criticalCount + majorCount + minorCount;
      const analysisScore = totalIssues === 0 
        ? 100 
        : Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 5 + majorCount * 3 + minorCount))));
      
      // Update state in a single batch
      set(state => ({
        issues,
        analysisScore,
        processingState: {
          ...state.processingState,
          isAnalyzing: false
        }
      }));
      
      return { success: true, issueCount: issues.length };
    } catch (error) {
      console.error('Error analyzing document:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          lastError: error.message || 'An error occurred during document analysis'
        }
      }));
      
      return { success: false, error: error.message };
    }
  },
  
  // Debounced version of analyzeDocument for better performance
  analyzeDocumentDebounced: () => {
    const { analysisSettings } = get();
    
    // Clear any existing scheduled analysis
    if (debouncedAnalysisTimeout) {
      clearTimeout(debouncedAnalysisTimeout);
    }
    
    // Update state to show that analysis is scheduled
    set(state => ({
      processingState: {
        ...state.processingState,
        isSchedulingAnalysis: true,
        analysisScheduledAt: Date.now()
      }
    }));
    
    return new Promise((resolve, reject) => {
      debouncedAnalysisTimeout = setTimeout(async () => {
        try {
          // Clear scheduling state
          set(state => ({
            processingState: {
              ...state.processingState,
              isSchedulingAnalysis: false,
              analysisScheduledAt: null
            }
          }));
          
          // Run the actual analysis
          const result = await get().analyzeDocument();
          resolve(result);
        } catch (error) {
          // Clear scheduling state on error
          set(state => ({
            processingState: {
              ...state.processingState,
              isSchedulingAnalysis: false,
              analysisScheduledAt: null
            }
          }));
          reject(error);
        }
      }, analysisSettings.debounceDelay);
    });
  },
  
  // Cancel any pending debounced analysis
  cancelDebouncedAnalysis: () => {
    if (debouncedAnalysisTimeout) {
      clearTimeout(debouncedAnalysisTimeout);
      debouncedAnalysisTimeout = null;
    }
    
    set(state => ({
      processingState: {
        ...state.processingState,
        isSchedulingAnalysis: false,
        analysisScheduledAt: null
      }
    }));
  },
  
  // Update analysis settings
  updateAnalysisSettings: (newSettings) => {
    set(state => ({
      analysisSettings: {
        ...state.analysisSettings,
        ...newSettings
      }
    }));
  },
  
  // Set active issue (for navigation and highlighting)
  setActiveIssue: (issueId) => {
    set({ activeIssueId: issueId });
    
    // Safely handle DOM operations in browser environment
    if (typeof document !== 'undefined') {
      // Scroll to the issue in the document
      const { issues } = get();
      const issue = issues?.find(i => i.id === issueId);
      
      if (issue && issue.location) {
        // Find the element with the issue
        const mark = document.querySelector(`mark[data-issue-id="${issueId}"]`);
        if (mark) {
          mark.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    }
  },
  
  // Apply a fix for an issue
  applyFix: async (issueId) => {
    const { issues, documentHtml, documentText } = get();
    const issue = issues.find(i => i.id === issueId);
    
    if (!issue || !issue.hasFix || !issue.fixAction) return;
    
    // Set applying fix state
    set(state => ({
      processingState: {
        ...state.processingState,
        isApplyingFix: true,
        currentFixId: issueId
      }
    }));
    
    // Create a small artificial delay for better UX feedback
    await new Promise(resolve => setTimeout(resolve, 300));
    
    let updatedHtml = documentHtml;
    let updatedText = documentText;
    
    // Apply the fix based on the issue type
    switch (issue.fixAction) {
      case 'addPageNumber':
        // Add page number to direct quote citation
        if (issue.text) {
          const citationMatch = issue.text.match(/\(([^)]+?),\s*(\d{4})\)/);
          if (citationMatch) {
            // Add page number to citation
            const authors = citationMatch[1];
            const year = citationMatch[2];
            const fixedText = issue.text.replace(
              `(${authors}, ${year})`, 
              `(${authors}, ${year}, p. 1)` // Default to p. 1, would be customizable in a real app
            );
            
            // Use safer replacements with exact matches only
            try {
              // Create a RegExp that matches the exact text (without global flag)
              const exactMatchRegex = new RegExp(escapeRegExp(issue.text));
              updatedText = documentText.replace(exactMatchRegex, fixedText);
              updatedHtml = documentHtml.replace(exactMatchRegex, fixedText);
            } catch (error) {
              console.error('Error replacing text:', error);
              // Fallback to simple replace if regex fails
              updatedText = documentText.replace(issue.text, fixedText);
              updatedHtml = documentHtml.replace(issue.text, fixedText);
            }
          }
        }
        break;
        
      case 'fixCitationFormat':
        // Fix citation format issues
        if (issue.text) {
          const citationMatch = issue.text.match(/\(([^)]+?) (\d{4})\)/);
          if (citationMatch) {
            // Add comma between author and year
            const authors = citationMatch[1];
            const year = citationMatch[2];
            const fixedText = issue.text.replace(
              `(${authors} ${year})`, 
              `(${authors}, ${year})`
            );
            
            // Use safer replacements with exact matches only
            try {
              // Create a RegExp that matches the exact text (without global flag)
              const exactMatchRegex = new RegExp(escapeRegExp(issue.text));
              updatedText = documentText.replace(exactMatchRegex, fixedText);
              updatedHtml = documentHtml.replace(exactMatchRegex, fixedText);
            } catch (error) {
              console.error('Error replacing text:', error);
              // Fallback to simple replace if regex fails
              updatedText = documentText.replace(issue.text, fixedText);
              updatedHtml = documentHtml.replace(issue.text, fixedText);
            }
          }
        }
        break;
        
      case 'fixAmpersand':
        // Fix ampersand vs. 'and' in citations
        if (issue.text) {
          // For narrative citations, 'and' is correct
          if (issue.text.includes(' and ')) {
            // This is already correct, but if we need to fix parenthetical citation:
            const fixedText = issue.text.replace(' and ', ' & ');
            // Use safer replacements with exact matches only
            try {
              // Create a RegExp that matches the exact text (without global flag)
              const exactMatchRegex = new RegExp(escapeRegExp(issue.text));
              updatedText = documentText.replace(exactMatchRegex, fixedText);
              updatedHtml = documentHtml.replace(exactMatchRegex, fixedText);
            } catch (error) {
              console.error('Error replacing text:', error);
              // Fallback to simple replace if regex fails
              updatedText = documentText.replace(issue.text, fixedText);
              updatedHtml = documentHtml.replace(issue.text, fixedText);
            }
          }
        }
        break;
        
      case 'addReferencesHeader':
        // Add References header
        updatedText = documentText + '\n\nReferences\n';
        updatedHtml = documentHtml + '<h2>References</h2>';
        break;
        
      case 'reorderReferences':
        // For demo purposes, just mark as fixed
        // In real implementation, this would reorder the references alphabetically
        break;
        
      case 'addTitlePage':
        // Add title page template
        const titlePage = 'Title: APA Formatted Document\nAuthor: Student Name\nInstitution: University Name\nCourse: Course Name\nInstructor: Instructor Name\nDate: ' + new Date().toLocaleDateString();
        updatedText = titlePage + '\n\n' + documentText;
        updatedHtml = '<div style="text-align: center; margin-bottom: 2em;">' +
          '<h1>APA Formatted Document</h1>' +
          '<p>Student Name</p>' +
          '<p>University Name</p>' +
          '<p>Course Name</p>' +
          '<p>Instructor Name</p>' +
          '<p>' + new Date().toLocaleDateString() + '</p>' +
          '</div>' + documentHtml;
        break;
        
      case 'addAbstract':
        // Add abstract template after title page (if exists) or at beginning
        const abstractText = '\n\nAbstract\n\nThis is an abstract placeholder. An abstract should be a brief, comprehensive summary of the contents of the paper, typically 150-250 words.\n\n';
        const abstractHtml = '<h2>Abstract</h2><p>This is an abstract placeholder. An abstract should be a brief, comprehensive summary of the contents of the paper, typically 150-250 words.</p>';
        
        if (documentText.includes('Title:') && documentText.includes('Author:')) {
          // If there's a title page, add after it
          const titlePageEnd = documentText.indexOf('Date:');
          if (titlePageEnd !== -1) {
            const endIndex = documentText.indexOf('\n', titlePageEnd);
            updatedText = documentText.substring(0, endIndex + 1) + abstractText + documentText.substring(endIndex + 1);
            
            // For HTML, add after the first div (assuming first div is title page)
            const firstDivEnd = documentHtml.indexOf('</div>');
            if (firstDivEnd !== -1) {
              updatedHtml = documentHtml.substring(0, firstDivEnd + 6) + abstractHtml + documentHtml.substring(firstDivEnd + 6);
            }
          }
        } else {
          // Add at beginning
          updatedText = abstractText + documentText;
          updatedHtml = abstractHtml + documentHtml;
        }
        break;
        
      case 'fixHeadingLevel':
        // For demo purposes, just mark as fixed
        // In a real implementation, this would fix heading hierarchy
        break;
        
      case 'fixFont':
        // Update the document to use Times New Roman
        updatedHtml = documentHtml.replace(/font-family:[^;]+;/g, 'font-family: "Times New Roman", Times, serif;');
        if (!documentHtml.includes('font-family:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="font-family: \'Times New Roman\', Times, serif;"');
        }
        break;
        
      case 'fixFontSize':
        // Update font size to 12pt
        updatedHtml = documentHtml.replace(/font-size:[^;]+;/g, 'font-size: 12pt;');
        if (!documentHtml.includes('font-size:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="font-size: 12pt;"');
        }
        break;
        
      case 'fixLineSpacing':
        // Update line spacing to double
        updatedHtml = documentHtml.replace(/line-height:[^;]+;/g, 'line-height: 2;');
        if (!documentHtml.includes('line-height:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="line-height: 2;"');
        }
        break;
        
      case 'fixMargins':
        // Set 1-inch margins
        updatedHtml = documentHtml.replace(/margin:[^;]+;/g, 'margin: 1in;');
        if (!documentHtml.includes('margin:')) {
          updatedHtml = updatedHtml.replace(/<body/, '<body style="margin: 1in;"');
        }
        break;
        
      case 'fixIndentation':
        // Set 0.5-inch paragraph indentation
        updatedHtml = documentHtml.replace(/text-indent:[^;]+;/g, 'text-indent: 0.5in;');
        if (!documentHtml.includes('text-indent:')) {
          // Add text-indent to all paragraphs
          updatedHtml = updatedHtml.replace(/<p/g, '<p style="text-indent: 0.5in;"');
        }
        break;
        
      case 'addPageNumbers':
        // Add page numbers - for HTML export, we'll add it in the header
        updatedHtml = documentHtml.replace(/<body/, '<body style="position: relative;"');
        updatedHtml = updatedHtml.replace(/<body([^>]*)>/, 
          '<body$1><div style="position: absolute; top: 0.5in; right: 0.5in; font-family: \'Times New Roman\', Times, serif; font-size: 12pt;">1</div>');
        break;
        
      default:
        // For any other fix actions, just mark as fixed without changing content
        break;
    }
    
    // Remove the fixed issue from issues list
    const updatedIssues = issues.filter(i => i.id !== issueId);
    
    // Update state with modified document and recalculated score
    set(state => ({ 
      documentText: updatedText,
      documentHtml: updatedHtml,
      issues: updatedIssues,
      // Recalculate compliance score
      analysisScore: updatedIssues.length === 0 
        ? 100 
        : Math.max(0, Math.min(100, Math.round(100 - (
            updatedIssues.filter(i => i.severity === 'Critical').length * 5 + 
            updatedIssues.filter(i => i.severity === 'Major').length * 3 + 
            updatedIssues.filter(i => i.severity === 'Minor').length
          )))),
      // Reset the applying fix state
      processingState: {
        ...state.processingState,
        isApplyingFix: false,
        currentFixId: null
      }
    }));
  }
}));


// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\apaAnalyzer.js
'use client';

// APA 7th Edition Guidelines Analyzer
// This module analyzes documents for compliance with APA 7th Edition guidelines

// Source type patterns for reference validation
const SOURCE_TYPES = {
  journal: {
    pattern: /\b(?:journal|j\.|quarterly|review|proceedings|bulletin)\b/i,
    required: ['author', 'year', 'title', 'journal', 'volume'],
    optional: ['issue', 'pages', 'doi'],
    titleShouldBeItalic: false,
    journalShouldBeItalic: true
  },
  book: {
    pattern: /\b(?:publisher|press|books|publication)\b/i,
    required: ['author', 'year', 'title', 'publisher'],
    optional: ['edition', 'location'],
    titleShouldBeItalic: true,
    journalShouldBeItalic: false
  },
  website: {
    pattern: /\b(?:http|www\.|\.com|\.org|\.edu|retrieved)\b/i,
    required: ['author', 'year', 'title', 'url'],
    optional: ['retrieved', 'organization'],
    titleShouldBeItalic: false,
    journalShouldBeItalic: false
  },
  chapter: {
    pattern: /\b(?:in\s+[A-Z]|\(eds?\.\)|\(ed\.\))\b/i,
    required: ['author', 'year', 'title', 'editor', 'book', 'pages', 'publisher'],
    optional: ['location'],
    titleShouldBeItalic: false,
    journalShouldBeItalic: true
  }
};

// Main analysis function
export function analyzeAPAGuidelines(text, html) {
  const issues = [];
  
  // Ensure we have valid inputs
  if (!text || typeof text !== 'string') {
    console.warn('Invalid text provided to APA analyzer');
    return issues;
  }
  
  // Analyze different aspects of the document
  issues.push(...analyzeCitations(text));
  issues.push(...analyzeReferenceList(text));
  issues.push(...analyzeDocumentStructure(text, html || ''));
  issues.push(...analyzeFormatting(html || ''));
  issues.push(...analyzeQuotations(text));
  issues.push(...analyzeNumbers(text));
  
  return issues;
}

// Analyze in-text citations
function analyzeCitations(text) {
  const issues = [];
  
  // Enhanced citation patterns
  const patterns = {
    // Basic citation patterns
    parenthetical: /\(([^)]+),\s*(\d{4})[^)]*\)/g,
    narrative: /([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)\s+\((\d{4})[^)]*\)/g,
    
    // Author count patterns
    singleAuthor: /\(([A-Z][a-zA-Z]+),\s*(\d{4})\)/g,
    twoAuthors: /\(([A-Z][a-zA-Z]+)\s*&\s*([A-Z][a-zA-Z]+),\s*(\d{4})\)/g,
    multipleAuthors: /\(([A-Z][a-zA-Z]+(?:\s+[A-Z][a-zA-Z]+)*)\s*et\s*al\.,\s*(\d{4})\)/g,
    
    // Quote patterns
    directQuote: /[""][^""]+?[""]\s*\([^)]+,\s*\d{4}(?:,\s*p\.?\s*\d+)?\)/g,
    longQuote: /\n\s*[^""][^\n]{40,}[^""]\n\s*\([^)]+,\s*\d{4}(?:,\s*pp?\.?\s*\d+(?:-\d+)?)?\)/g,
    
    // Multiple citations
    multipleCitations: /\(([^)]+;\s*[^)]+)\)/g,
    
    // Secondary sources
    secondarySource: /\(([^)]+)\s+as\s+cited\s+in\s+([^)]+),\s*(\d{4})\)/g
  };

  // 1. Check parenthetical vs narrative citation format
  let match;
  while ((match = patterns.parenthetical.exec(text)) !== null) {
    const fullCitation = match[0];
    const authorPart = match[1];
    const year = match[2];
    
    // Check for proper author format in parenthetical citations
    if (authorPart.includes(' and ')) {
      issues.push({
        title: "Incorrect connector in parenthetical citation",
        description: "Use '&' instead of 'and' in parenthetical citations",
        text: fullCitation,
        severity: "Minor",
        location: { text: fullCitation },
        hasFix: true,
        fixAction: "fixParentheticalConnector",
        explanation: "In parenthetical citations, use ampersand (&) to connect author names. Use 'and' only in narrative citations."
      });
    }
    
    // Check for missing comma between author and year
    if (!fullCitation.includes(', ' + year)) {
      issues.push({
        title: "Missing comma in citation",
        description: "Citations must have a comma between author and year",
        text: fullCitation,
        severity: "Minor",
        location: { text: fullCitation },
        hasFix: true,
        fixAction: "addCitationComma",
        explanation: "APA format requires a comma between the author name(s) and publication year."
      });
    }
  }

  // 2. Check narrative citations
  while ((match = patterns.narrative.exec(text)) !== null) {
    const fullCitation = match[0];
    const authorPart = match[1];
    const year = match[2];
    
    // Check for incorrect use of ampersand in narrative citations
    if (authorPart.includes('&')) {
      issues.push({
        title: "Incorrect connector in narrative citation",
        description: "Use 'and' instead of '&' in narrative citations",
        text: fullCitation,
        severity: "Minor",
        location: { text: fullCitation },
        hasFix: true,
        fixAction: "fixNarrativeConnector",
        explanation: "In narrative citations where authors are part of the sentence, use 'and' to connect names, not '&'."
      });
    }
  }

  // 3. Check author count rules
  // Two authors - should always include both
  while ((match = patterns.twoAuthors.exec(text)) !== null) {
    // This is correct format - both authors with &
  }

  // Multiple authors - check et al. usage
  const allCitations = text.match(/\([^)]+,\s*\d{4}[^)]*\)/g) || [];
  allCitations.forEach(citation => {
    const authorPart = citation.match(/\(([^,]+)/)?.[1] || '';
    const authorCount = (authorPart.match(/&/g) || []).length + 1;
    
    // Check if et al. is used correctly
    if (authorCount >= 3 && !citation.includes('et al.')) {
      // For 3+ authors, et al. should be used from first citation
      issues.push({
        title: "Missing 'et al.' for multiple authors",
        description: "Use 'et al.' for sources with 3 or more authors",
        text: citation,
        severity: "Minor",
        location: { text: citation },
        hasFix: true,
        fixAction: "addEtAl",
        explanation: "For sources with 3 or more authors, use the first author's name followed by 'et al.' in all citations."
      });
    }
  });

  // 4. Check direct quotes for page numbers
  while ((match = patterns.directQuote.exec(text)) !== null) {
    const quote = match[0];
    if (!quote.match(/,\s*p\.?\s*\d+/i)) {
      issues.push({
        title: "Missing page number in direct quote",
        description: "Direct quotes must include page numbers",
        text: quote,
        severity: "Major",
        location: { text: quote },
        hasFix: true,
        fixAction: "addPageNumber",
        explanation: "All direct quotes require a page number (or paragraph number for web sources) to help readers locate the original text."
      });
    }
  }

  // 5. Check long quotes (40+ words)
  while ((match = patterns.longQuote.exec(text)) !== null) {
    const quote = match[0];
    // Long quotes should be in block format without quotation marks
    if (quote.includes('""') || quote.includes('"')) {
      issues.push({
        title: "Long quote format error",
        description: "Quotes of 40+ words should be in block format without quotation marks",
        text: quote,
        severity: "Major",
        location: { text: quote },
        hasFix: true,
        fixAction: "formatLongQuote",
        explanation: "Long quotations (40+ words) should be formatted as indented blocks without quotation marks."
      });
    }
  }

  // 6. Check multiple citations format
  while ((match = patterns.multipleCitations.exec(text)) !== null) {
    const citations = match[1];
    const parts = citations.split(';');
    
    // Check alphabetical order
    const authors = parts.map(part => part.trim().split(',')[0].trim());
    const sortedAuthors = [...authors].sort();
    
    if (JSON.stringify(authors) !== JSON.stringify(sortedAuthors)) {
      issues.push({
        title: "Multiple citations not in alphabetical order",
        description: "Multiple citations should be listed alphabetically by first author",
        text: match[0],
        severity: "Minor",
        location: { text: match[0] },
        hasFix: true,
        fixAction: "sortMultipleCitations",
        explanation: "When citing multiple sources in one parenthesis, arrange them alphabetically by first author's surname."
      });
    }
    
    // Check semicolon usage
    if (!citations.includes(';')) {
      issues.push({
        title: "Missing semicolon in multiple citations",
        description: "Use semicolons to separate multiple citations",
        text: match[0],
        severity: "Minor",
        location: { text: match[0] },
        hasFix: true,
        fixAction: "addSemicolons",
        explanation: "Multiple citations within one parenthesis should be separated by semicolons."
      });
    }
  }

  // 7. Check secondary sources
  while ((match = patterns.secondarySource.exec(text)) !== null) {
    const originalAuthor = match[1];
    const citingAuthor = match[2];
    const year = match[3];
    
    // This is correct format, but check if it's overused
    const secondaryCount = (text.match(/as cited in/g) || []).length;
    if (secondaryCount > 3) {
      issues.push({
        title: "Excessive use of secondary sources",
        description: "Try to locate and cite primary sources when possible",
        text: match[0],
        severity: "Minor",
        location: { text: match[0] },
        hasFix: false,
        explanation: "While secondary citations are acceptable, APA encourages citing primary sources whenever possible."
      });
    }
  }

  return issues;
}

// Analyze reference list
function analyzeReferenceList(text) {
  const issues = [];
  
  // Check if References header exists
  if (!text.match(/References/i)) {
    issues.push({
      title: "Missing References section",
      description: "Document should include a References section with proper heading",
      text: null,
      severity: "Critical",
      location: null,
      hasFix: true,
      fixAction: "addReferencesHeader",
      explanation: "All APA papers must include a References section listing all sources cited in the text."
    });
    
    // If no references section, return early
    return issues;
  }
  
  // Extract references section
  const referencesMatch = text.match(/References([\s\S]+?)(?:\n\n[A-Z]|$)/i);
  if (!referencesMatch || !referencesMatch[1]) return issues;
  
  const referencesText = referencesMatch[1].trim();
  const referenceEntries = referencesText.split(/\n\s*\n/).filter(entry => entry.trim().length > 0);
  
  if (referenceEntries.length === 0) {
    issues.push({
      title: "Empty References section",
      description: "References section exists but contains no entries",
      text: null,
      severity: "Critical",
      location: null,
      hasFix: false,
      explanation: "The References section must contain entries for all sources cited in your paper."
    });
    return issues;
  }

  // Check for alphabetical ordering
  const authorLastNames = referenceEntries.map(entry => {
    const match = entry.match(/^([^,(\d]+)/);
    return match ? match[1].trim().toLowerCase() : '';
  });
  
  const sortedLastNames = [...authorLastNames].sort((a, b) => 
    a.localeCompare(b, undefined, { sensitivity: 'base' })
  );
  
  for (let i = 0; i < authorLastNames.length; i++) {
    if (authorLastNames[i] !== sortedLastNames[i]) {
      issues.push({
        title: "References not in alphabetical order",
        description: "Reference list must be in alphabetical order by first author's last name",
        text: referenceEntries[i],
        severity: "Major",
        location: { text: referenceEntries[i] },
        hasFix: true,
        fixAction: "reorderReferences",
        explanation: "References must be arranged alphabetically by the surname of the first author."
      });
      break;
    }
  }
  
  // Analyze each reference entry
  referenceEntries.forEach((entry, index) => {
    const trimmedEntry = entry.trim();
    
    // 1. Detect source type and validate format
    const sourceType = detectSourceType(trimmedEntry);
    const validationIssues = validateReferenceFormat(trimmedEntry, sourceType);
    issues.push(...validationIssues);
    
    // 2. Check author name format
    const authorIssues = validateAuthorFormat(trimmedEntry);
    issues.push(...authorIssues);
    
    // 3. Check title capitalization
    const titleIssues = validateTitleCapitalization(trimmedEntry, sourceType);
    issues.push(...titleIssues);
    
    // 4. Check date format
    const dateIssues = validateDateFormat(trimmedEntry);
    issues.push(...dateIssues);
    
    // 5. Check DOI/URL format
    const linkIssues = validateLinks(trimmedEntry, sourceType);
    issues.push(...linkIssues);
    
    // 6. Check for period placement
    const punctuationIssues = validatePunctuation(trimmedEntry);
    issues.push(...punctuationIssues);
  });
  
  return issues;
}

// Helper function to detect source type
function detectSourceType(entry) {
  for (const [type, config] of Object.entries(SOURCE_TYPES)) {
    if (config.pattern.test(entry)) {
      return type;
    }
  }
  return 'unknown';
}

// Validate reference format based on source type
function validateReferenceFormat(entry, sourceType) {
  const issues = [];
  const config = SOURCE_TYPES[sourceType];
  
  if (!config) return issues;
  
  // Check for required elements
  config.required.forEach(element => {
    switch (element) {
      case 'author':
        if (!entry.match(/^[A-Z][a-zA-Z]+,\s*[A-Z]/)) {
          issues.push({
            title: "Missing or incorrect author format",
            description: "Author name should be formatted as 'Last, F. M.'",
            text: entry,
            severity: "Major",
            location: { text: entry },
            hasFix: true,
            fixAction: "fixAuthorFormat",
            explanation: "Author names should be formatted with surname first, followed by initials."
          });
        }
        break;
      case 'year':
        if (!entry.match(/\(\d{4}\)/)) {
          issues.push({
            title: "Missing or incorrect year format",
            description: "Publication year should be in parentheses",
            text: entry,
            severity: "Major",
            location: { text: entry },
            hasFix: true,
            fixAction: "fixYearFormat",
            explanation: "Publication year must be enclosed in parentheses and placed after the author(s)."
          });
        }
        break;
      case 'doi':
        if (sourceType === 'journal' && !entry.match(/doi:|DOI:|doi\.org/i)) {
          issues.push({
            title: "Missing DOI in journal reference",
            description: "Journal articles should include DOI when available",
            text: entry,
            severity: "Minor",
            location: { text: entry },
            hasFix: false,
            explanation: "Include the DOI for journal articles when available to help readers locate the source."
          });
        }
        break;
      case 'volume':
        if (sourceType === 'journal' && !entry.match(/,\s*\d+[\(,]/)) {
          issues.push({
            title: "Missing volume number",
            description: "Journal references must include volume number",
            text: entry,
            severity: "Major",
            location: { text: entry },
            hasFix: false,
            explanation: "Journal references require the volume number, typically italicized."
          });
        }
        break;
    }
  });
  
  return issues;
}

// Validate author name format
function validateAuthorFormat(entry) {
  const issues = [];
  const authorMatch = entry.match(/^([^(]+)\s*\(/);
  
  if (authorMatch) {
    const authorPart = authorMatch[1].trim();
    
    // Check for proper initials format
    if (authorPart.includes(',')) {
      const afterComma = authorPart.split(',')[1]?.trim();
      if (afterComma && !afterComma.match(/^[A-Z]\.(\s*[A-Z]\.)*$/)) {
        issues.push({
          title: "Incorrect author initial format",
          description: "Author initials should be formatted as 'F. M.' with periods and spaces",
          text: entry,
          severity: "Minor",
          location: { text: entry },
          hasFix: true,
          fixAction: "fixAuthorInitials",
          explanation: "Use initials with periods and spaces (e.g., 'Smith, J. A.') for author names."
        });
      }
    }
    
    // Check for multiple authors format
    if (authorPart.includes('&')) {
      const parts = authorPart.split('&');
      if (parts.length > 2) {
        issues.push({
          title: "Incorrect multiple author format",
          description: "Use commas to separate multiple authors, with '&' before the last author",
          text: entry,
          severity: "Minor",
          location: { text: entry },
          hasFix: true,
          fixAction: "fixMultipleAuthors",
          explanation: "Format multiple authors as: 'Author1, A., Author2, B., & Author3, C.'"
        });
      }
    }
  }
  
  return issues;
}

// Validate title capitalization
function validateTitleCapitalization(entry, sourceType) {
  const issues = [];
  const config = SOURCE_TYPES[sourceType];
  
  if (!config) return issues;
  
  // Extract title (usually after year, before journal/publisher)
  const titleMatch = entry.match(/\(\d{4}\)\.\s*([^.]+)\./);
  if (titleMatch) {
    const title = titleMatch[1];
    
    // Check sentence case for article/chapter titles
    if (!config.titleShouldBeItalic) {
      const words = title.split(' ');
      const capitalizedWords = words.filter(word => 
        word.length > 0 && word[0] === word[0].toUpperCase() && 
        !['And', 'Or', 'But', 'For', 'Nor', 'So', 'Yet', 'A', 'An', 'The', 'In', 'On', 'At', 'By', 'Of'].includes(word)
      );
      
      if (capitalizedWords.length > 2) {
        issues.push({
          title: "Incorrect title capitalization",
          description: "Article and chapter titles should use sentence case",
          text: entry,
          severity: "Minor",
          location: { text: entry },
          hasFix: true,
          fixAction: "fixTitleCase",
          explanation: "Use sentence case for article and chapter titles (capitalize only first word, proper nouns, and first word after colon)."
        });
      }
    }
  }
  
  return issues;
}

// Validate date format
function validateDateFormat(entry) {
  const issues = [];
  
  // Check for proper year format
  const yearMatch = entry.match(/\((\d{4})\)/);
  if (yearMatch) {
    const year = parseInt(yearMatch[1]);
    const currentYear = new Date().getFullYear();
    
    if (year < 1800 || year > currentYear + 1) {
      issues.push({
        title: "Suspicious publication year",
        description: "Check if the publication year is correct",
        text: entry,
        severity: "Minor",
        location: { text: entry },
        hasFix: false,
        explanation: "Verify that the publication year is accurate and falls within a reasonable range."
      });
    }
  }
  
  return issues;
}

// Validate DOI and URL formats
function validateLinks(entry, sourceType) {
  const issues = [];
  
  // Check DOI format
  const doiMatch = entry.match(/doi[:\s]*([^\s]+)/i);
  if (doiMatch) {
    const doi = doiMatch[1];
    if (!doi.match(/^10\.\d+/)) {
      issues.push({
        title: "Invalid DOI format",
        description: "DOI should start with '10.' followed by numbers",
        text: entry,
        severity: "Minor",
        location: { text: entry },
        hasFix: true,
        fixAction: "fixDOIFormat",
        explanation: "DOIs should follow the format: https://doi.org/10.xxxx/xxxx"
      });
    }
  }
  
  // Check URL format
  const urlMatch = entry.match(/(https?:\/\/[^\s]+)/);
  if (urlMatch) {
    const url = urlMatch[1];
    if (url.endsWith('.') || url.endsWith(',')) {
      issues.push({
        title: "URL ends with punctuation",
        description: "Remove trailing punctuation from URLs",
        text: entry,
        severity: "Minor",
        location: { text: entry },
        hasFix: true,
        fixAction: "cleanURL",
        explanation: "URLs should not end with periods or other punctuation marks."
      });
    }
  }
  
  return issues;
}

// Validate punctuation
function validatePunctuation(entry) {
  const issues = [];
  
  // Check for proper ending punctuation
  if (!entry.trim().endsWith('.')) {
    issues.push({
      title: "Missing ending period",
      description: "Reference entries should end with a period",
      text: entry,
      severity: "Minor",
      location: { text: entry },
      hasFix: true,
      fixAction: "addEndingPeriod",
      explanation: "Each reference entry must end with a period."
    });
  }
  
  // Check for double periods
  if (entry.includes('..')) {
    issues.push({
      title: "Double periods in reference",
      description: "Remove extra periods from reference",
      text: entry,
      severity: "Minor",
      location: { text: entry },
      hasFix: true,
      fixAction: "removeDoublePeriods",
      explanation: "Avoid double periods in reference entries."
    });
  }
  
  return issues;
}

// Analyze document structure
function analyzeDocumentStructure(text, html) {
  const issues = [];
  
  // 1. Check for title page elements
  const titlePageElements = [
    { element: 'title', pattern: /^[\s\S]{0,1000}(?:title:|paper title:|running head:)/im, name: 'Title' },
    { element: 'author', pattern: /^[\s\S]{0,1000}(?:author:|by:|\n[A-Z][a-z]+ [A-Z][a-z]+)/im, name: 'Author' },
    { element: 'institution', pattern: /^[\s\S]{0,1000}(?:institution:|university|college)/im, name: 'Institution' },
    { element: 'course', pattern: /^[\s\S]{0,1000}(?:course:|class:)/im, name: 'Course' }
  ];
  
  const missingElements = titlePageElements.filter(elem => !elem.pattern.test(text));
  
  if (missingElements.length > 0) {
    issues.push({
      title: "Incomplete title page",
      description: `Missing title page elements: ${missingElements.map(e => e.name).join(', ')}`,
      text: null,
      severity: "Critical",
      location: { position: 0 },
      hasFix: true,
      fixAction: "addTitlePageElements",
      explanation: "Title page must include paper title, author name(s), institutional affiliation, course information, instructor name, and due date."
    });
  }
  
  // 2. Check for running head
  if (!text.match(/running head:/i)) {
    issues.push({
      title: "Missing running head",
      description: "Professional papers require a running head on every page",
      text: null,
      severity: "Major",
      location: null,
      hasFix: true,
      fixAction: "addRunningHead",
      explanation: "The running head is a shortened version of your paper title (max 50 characters) that appears at the top of every page."
    });
  }
  
  // 3. Check for abstract
  const abstractMatch = text.match(/Abstract[\s\n]/i);
  if (!abstractMatch) {
    // Check if it's a research paper that should have an abstract
    const isResearchPaper = text.match(/method|results|discussion|participants|procedure/i);
    if (isResearchPaper) {
      issues.push({
        title: "Missing abstract",
        description: "Research papers should include an abstract",
        text: null,
        severity: "Major",
        location: null,
        hasFix: true,
        fixAction: "addAbstract",
        explanation: "Research papers typically require an abstract summarizing the study's purpose, method, results, and conclusions."
      });
    }
  } else {
    // Check abstract content if it exists
    const abstractContent = text.match(/Abstract\s*([\s\S]*?)(?:\n\n|\nKeywords|\nIntroduction|\n[A-Z])/i);
    if (abstractContent && abstractContent[1]) {
      const wordCount = abstractContent[1].trim().split(/\s+/).length;
      if (wordCount < 50) {
        issues.push({
          title: "Abstract too short",
          description: "Abstract appears to be unusually short",
          text: abstractContent[0],
          severity: "Minor",
          location: { text: abstractContent[0] },
          hasFix: false,
          explanation: "Abstracts typically range from 150-250 words for most academic papers."
        });
      } else if (wordCount > 300) {
        issues.push({
          title: "Abstract too long",
          description: "Abstract may be too long (over 300 words)",
          text: abstractContent[0],
          severity: "Minor",
          location: { text: abstractContent[0] },
          hasFix: false,
          explanation: "Abstracts should typically be 150-250 words. Consider condensing key points."
        });
      }
    }
  }
  
  // 4. Check for keywords
  if (abstractMatch && !text.match(/keywords:/i)) {
    issues.push({
      title: "Missing keywords",
      description: "Papers with abstracts should include keywords",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "addKeywords",
      explanation: "Include 3-5 keywords after the abstract to help with indexing and searchability."
    });
  }
  
  // 5. Check for heading levels and formatting
  const headingPatterns = {
    level1: /^([A-Z][^.\n]*?)(?:\n|$)/gm,  // Centered, Bold, Title Case
    level2: /^([A-Z][a-z][^.\n]*?)(?:\n|$)/gm,  // Flush Left, Bold, Title Case
    level3: /^\s*([A-Z][a-z][^.\n]*?)\.(?:\n|$)/gm,  // Flush Left, Bold, Italic, Title Case, ending with period
    markdown: /^(#{1,6})\s+(.+)$/gm  // Markdown style headings
  };
  
  const headings = [];
  let match;
  
  // Check markdown headings
  while ((match = headingPatterns.markdown.exec(text)) !== null) {
    headings.push({
      level: match[1].length,
      text: match[2],
      type: 'markdown'
    });
  }
  
  // Check for proper heading hierarchy
  for (let i = 1; i < headings.length; i++) {
    if (headings[i].level > headings[i-1].level + 1) {
      issues.push({
        title: "Improper heading hierarchy",
        description: "Headings should not skip levels",
        text: `${headings[i-1].text}  ${headings[i].text}`,
        severity: "Major",
        location: { text: headings[i].text },
        hasFix: true,
        fixAction: "fixHeadingLevel",
        explanation: "Use heading levels in order: Level 1, then Level 2, then Level 3, etc. Don't skip levels."
      });
    }
  }
  
  // 6. Check for research paper structure
  const researchSections = {
    method: /\b(method|methodology)\b/i,
    results: /\bresults?\b/i,
    discussion: /\bdiscussion\b/i,
    conclusion: /\bconclusion\b/i
  };
  
  const hasMethodSection = researchSections.method.test(text);
  const hasResultsSection = researchSections.results.test(text);
  const hasDiscussionSection = researchSections.discussion.test(text);
  
  // If it looks like a research paper, check for required sections
  if (hasMethodSection || hasResultsSection) {
    if (!hasMethodSection) {
      issues.push({
        title: "Missing Method section",
        description: "Research papers should include a Method section",
        text: null,
        severity: "Major",
        location: null,
        hasFix: true,
        fixAction: "addMethodSection",
        explanation: "Research papers need a Method section describing participants, materials, and procedures."
      });
    }
    
    if (!hasResultsSection) {
      issues.push({
        title: "Missing Results section",
        description: "Research papers should include a Results section",
        text: null,
        severity: "Major",
        location: null,
        hasFix: true,
        fixAction: "addResultsSection",
        explanation: "Research papers need a Results section presenting the findings of your study."
      });
    }
    
    if (!hasDiscussionSection) {
      issues.push({
        title: "Missing Discussion section",
        description: "Research papers should include a Discussion section",
        text: null,
        severity: "Major",
        location: null,
        hasFix: true,
        fixAction: "addDiscussionSection",
        explanation: "Research papers need a Discussion section interpreting results and their implications."
      });
    }
  }
  
  // 7. Check for tables and figures formatting
  const tableMatches = text.match(/table \d+/gi);
  const figureMatches = text.match(/figure \d+/gi);
  
  if (tableMatches) {
    tableMatches.forEach(table => {
      // Check if table has proper caption format
      const tablePattern = new RegExp(`${table}[\\s\\S]*?\\n`, 'i');
      const tableSection = text.match(tablePattern);
      if (tableSection && !tableSection[0].includes('Note.')) {
        // Tables should have notes when appropriate
      }
    });
  }
  
  return issues;
}

// Analyze quotations
function analyzeQuotations(text) {
  const issues = [];
  
  // 1. Check short quotations (less than 40 words)
  const shortQuotePattern = /[""]([^""]{1,200}?)[""]/g;
  let match;
  
  while ((match = shortQuotePattern.exec(text)) !== null) {
    const quote = match[1];
    const wordCount = quote.trim().split(/\s+/).length;
    
    if (wordCount >= 40) {
      issues.push({
        title: "Long quote in inline format",
        description: "Quotes of 40+ words should be formatted as block quotes",
        text: match[0],
        severity: "Major",
        location: { text: match[0] },
        hasFix: true,
        fixAction: "convertToBlockQuote",
        explanation: "Quotations of 40 or more words must be formatted as block quotations without quotation marks."
      });
    }
  }
  
  // 2. Check block quotations
  const blockQuotePattern = /\n\s{4,}([^\n]{40,})\n/g;
  while ((match = blockQuotePattern.exec(text)) !== null) {
    const quote = match[1];
    
    // Block quotes should not have quotation marks
    if (quote.includes('"') || quote.includes('"') || quote.includes('"')) {
      issues.push({
        title: "Block quote has quotation marks",
        description: "Block quotations should not include quotation marks",
        text: match[0],
        severity: "Minor",
        location: { text: match[0] },
        hasFix: true,
        fixAction: "removeQuotationMarks",
        explanation: "Block quotations are formatted without quotation marks and indented from the left margin."
      });
    }
  }
  
  // 3. Check for quotes without citations
  const quotesWithoutCitation = [];
  const allQuotes = text.match(/[""][^""]+?[""]/g) || [];
  
  allQuotes.forEach(quote => {
    // Look for citation within 50 characters after the quote
    const quoteIndex = text.indexOf(quote);
    const afterQuote = text.substr(quoteIndex + quote.length, 50);
    
    if (!afterQuote.match(/\([^)]+,\s*\d{4}/)) {
      quotesWithoutCitation.push(quote);
    }
  });
  
  quotesWithoutCitation.forEach(quote => {
    issues.push({
      title: "Quote without citation",
      description: "All quotations must be followed by a citation",
      text: quote,
      severity: "Critical",
      location: { text: quote },
      hasFix: true,
      fixAction: "addCitationToQuote",
      explanation: "Every direct quotation must include a citation with author, year, and page number."
    });
  });
  
  return issues;
}

// Analyze numbers and statistics
function analyzeNumbers(text) {
  const issues = [];
  
  // 1. Check number formatting (spell out numbers below 10)
  const numberPattern = /\b([1-9])\b(?!\d)/g;
  let match;
  
  while ((match = numberPattern.exec(text)) !== null) {
    const number = parseInt(match[1]);
    const fullMatch = match[0];
    
    // Skip if it's part of a citation year or page number
    const context = text.substr(Math.max(0, match.index - 10), 20);
    if (context.match(/\(\d{4}\)|p\.\s*\d|pp\.\s*\d/)) {
      continue;
    }
    
    if (number < 10) {
      const numberWords = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
      issues.push({
        title: "Number should be spelled out",
        description: `Numbers below 10 should be spelled out as words`,
        text: fullMatch,
        severity: "Minor",
        location: { text: fullMatch },
        hasFix: true,
        fixAction: "spellOutNumber",
        explanation: "In APA style, spell out numbers below 10 unless they represent precise measurements or are part of a series with numbers 10 and above."
      });
    }
  }
  
  // 2. Check percentage formatting
  const percentPattern = /(\d+)\s*%/g;
  while ((match = percentPattern.exec(text)) !== null) {
    if (match[0].includes(' %')) {
      issues.push({
        title: "Space before percent symbol",
        description: "Remove space between number and percent symbol",
        text: match[0],
        severity: "Minor",
        location: { text: match[0] },
        hasFix: true,
        fixAction: "removePercentSpace",
        explanation: "Write percentages with no space between the number and % symbol (e.g., '25%' not '25 %')."
      });
    }
  }
  
  // 3. Check statistical reporting
  const statisticalTests = [
    { pattern: /\bt\s*=\s*([+-]?\d+\.?\d*)/gi, name: 't-test' },
    { pattern: /\bF\s*=\s*([+-]?\d+\.?\d*)/gi, name: 'F-test' },
    { pattern: /\br\s*=\s*([+-]?\d+\.?\d*)/gi, name: 'correlation' },
    { pattern: /\bp\s*=\s*([+-]?\d+\.?\d*)/gi, name: 'p-value' }
  ];
  
  statisticalTests.forEach(test => {
    while ((match = test.pattern.exec(text)) !== null) {
      const value = parseFloat(match[1]);
      
      if (test.name === 'p-value') {
        if (value === 0) {
          issues.push({
            title: "P-value reported as exactly zero",
            description: "Report very small p-values as 'p < .001' rather than 'p = 0'",
            text: match[0],
            severity: "Minor",
            location: { text: match[0] },
            hasFix: true,
            fixAction: "fixZeroPValue",
            explanation: "Very small p-values should be reported as '< .001' rather than '= 0' to maintain precision."
          });
        }
        
        if (value > 1) {
          issues.push({
            title: "Invalid p-value",
            description: "P-values cannot be greater than 1.0",
            text: match[0],
            severity: "Major",
            location: { text: match[0] },
            hasFix: false,
            explanation: "P-values represent probabilities and must be between 0 and 1. Check your statistical analysis."
          });
        }
      }
      
      if (test.name === 'correlation' && Math.abs(value) > 1) {
        issues.push({
          title: "Invalid correlation coefficient",
          description: "Correlation coefficients must be between -1 and 1",
          text: match[0],
          severity: "Major",
          location: { text: match[0] },
          hasFix: false,
          explanation: "Correlation coefficients (r) must be between -1.0 and +1.0. Check your calculation."
        });
      }
    }
  });
  
  return issues;
}

// Analyze formatting
function analyzeFormatting(html) {
  const issues = [];
  
  // Ensure html is a string
  if (!html || typeof html !== 'string') {
    return issues;
  }
  
  // Check font family
  const fontCheck = html.match(/font-family:\s*['"]([^'"]+)['"]/i);
  if (fontCheck && !fontCheck[1].toLowerCase().includes('times new roman')) {
    issues.push({
      title: "Incorrect font",
      description: "APA 7th edition requires 12-point Times New Roman font",
      text: `Font found: ${fontCheck[1]}`,
      severity: "Minor",
      location: { position: html.indexOf(fontCheck[0]) },
      hasFix: true,
      fixAction: "fixFont"
    });
  } else if (!fontCheck) {
    issues.push({
      title: "Font not specified",
      description: "APA 7th edition requires 12-point Times New Roman font",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "fixFont"
    });
  }
  
  // Check font size
  const fontSizeCheck = html.match(/font-size:\s*(\d+(?:\.\d+)?)(pt|px|em|rem)/i);
  if (fontSizeCheck) {
    const size = parseFloat(fontSizeCheck[1]);
    const unit = fontSizeCheck[2].toLowerCase();
    
    // Convert to pt for comparison
    let ptSize;
    switch (unit) {
      case 'px': ptSize = size * 0.75; break; // Approximate px to pt conversion
      case 'em': ptSize = size * 12; break;   // Assuming 1em = 12pt
      case 'rem': ptSize = size * 12; break;  // Assuming 1rem = 12pt
      case 'pt': ptSize = size; break;
      default: ptSize = 0;
    }
    
    if (Math.abs(ptSize - 12) > 0.5) { // Allow some tolerance
      issues.push({
        title: "Incorrect font size",
        description: "APA 7th edition requires 12-point Times New Roman font",
        text: `Font size found: ${fontSizeCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(fontSizeCheck[0]) },
        hasFix: true,
        fixAction: "fixFontSize"
      });
    }
  }
  
  // Check line spacing
  const lineSpacingCheck = html.match(/line-height:\s*([^\s;]+)/i);
  if (lineSpacingCheck) {
    const lineHeight = lineSpacingCheck[1];
    // Check if line spacing is approximately double
    // Double spacing typically ranges from 1.9 to 2.1, or 200%
    if (lineHeight !== '2' && lineHeight !== '2.0' && 
        lineHeight !== 'double' && lineHeight !== '200%') {
      issues.push({
        title: "Incorrect line spacing",
        description: "APA 7th edition requires double-spaced text",
        text: `Line spacing found: ${lineSpacingCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(lineSpacingCheck[0]) },
        hasFix: true,
        fixAction: "fixLineSpacing"
      });
    }
  } else {
    issues.push({
      title: "Line spacing not specified",
      description: "APA 7th edition requires double-spaced text",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "fixLineSpacing"
    });
  }
  
  // Check margins
  const marginCheck = html.match(/margin:\s*([^;]+)/i);
  if (marginCheck) {
    // Check if any margin is less than 1 inch (approximately 72px or 6em)
    const margins = marginCheck[1].split(/\s+/);
    const hasSmallMargin = margins.some(margin => {
      const value = parseFloat(margin);
      const unit = margin.match(/[a-z%]+$/i)?.[0] || '';
      
      if (unit === 'in' && value < 1) return true;
      if (unit === 'cm' && value < 2.54) return true;
      if (unit === 'mm' && value < 25.4) return true;
      if (unit === 'pt' && value < 72) return true;
      if (unit === 'px' && value < 96) return true;
      if ((unit === 'em' || unit === 'rem') && value < 6) return true;
      
      return false;
    });
    
    if (hasSmallMargin) {
      issues.push({
        title: "Insufficient margins",
        description: "APA 7th edition requires 1-inch margins on all sides",
        text: `Margins found: ${marginCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(marginCheck[0]) },
        hasFix: true,
        fixAction: "fixMargins"
      });
    }
  }
  
  // Check paragraph indentation
  const textIndentCheck = html.match(/text-indent:\s*([^;]+)/i);
  if (textIndentCheck) {
    const indent = textIndentCheck[1];
    const value = parseFloat(indent);
    const unit = indent.match(/[a-z%]+$/i)?.[0] || '';
    
    let isCorrect = false;
    
    // Check if indent is approximately 0.5 inch
    if (unit === 'in' && Math.abs(value - 0.5) < 0.1) isCorrect = true;
    if (unit === 'cm' && Math.abs(value - 1.27) < 0.2) isCorrect = true;
    if (unit === 'mm' && Math.abs(value - 12.7) < 2) isCorrect = true;
    if (unit === 'pt' && Math.abs(value - 36) < 5) isCorrect = true;
    if (unit === 'px' && Math.abs(value - 48) < 5) isCorrect = true;
    if ((unit === 'em' || unit === 'rem') && Math.abs(value - 3) < 0.5) isCorrect = true;
    
    if (!isCorrect) {
      issues.push({
        title: "Incorrect paragraph indentation",
        description: "APA 7th edition requires 0.5-inch indentation for the first line of each paragraph",
        text: `Text indent found: ${textIndentCheck[0]}`,
        severity: "Minor",
        location: { position: html.indexOf(textIndentCheck[0]) },
        hasFix: true,
        fixAction: "fixIndentation"
      });
    }
  } else {
    // Check if paragraphs exist without indentation
    if (html.includes('<p') && !html.includes('text-indent')) {
      issues.push({
        title: "Missing paragraph indentation",
        description: "APA 7th edition requires 0.5-inch indentation for the first line of each paragraph",
        text: null,
        severity: "Minor",
        location: null,
        hasFix: true,
        fixAction: "fixIndentation"
      });
    }
  }
  
  // Check for page numbers
  if (!html.includes('page-number') && !html.includes('page number')) {
    issues.push({
      title: "Missing page numbers",
      description: "APA 7th edition requires page numbers in the top-right corner of each page",
      text: null,
      severity: "Minor",
      location: null,
      hasFix: true,
      fixAction: "addPageNumbers"
    });
  }
  
  return issues;
}


