// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\advancedCitationValidator.js
// src/utils/advancedCitationValidator.js - Advanced citation validation
'use client';

export class AdvancedCitationValidator {
  constructor() {
    this.narrativeCitationPattern = /([A-Z][a-z]+(?:\s+(?:and|&)\s+[A-Z][a-z]+)*)\s+\((\d{4}[a-z]?)\)/g;
    this.parentheticalCitationPattern = /\(([^)]+,\s*\d{4}[a-z]?)\)/g;
  }

  /**
   * Validate advanced citation rules
   */
  validateAdvancedCitations(text, structure) {
    const issues = [];
    
    // Multiple authors formatting
    issues.push(...this.validateMultipleAuthors(text));
    
    // Secondary source citations
    issues.push(...this.validateSecondarySources(text));
    
    // Personal communication citations
    issues.push(...this.validatePersonalCommunications(text));
    
    // Group/corporate authors
    issues.push(...this.validateCorporateAuthors(text));
    
    // No date citations
    issues.push(...this.validateNoDateCitations(text));
    
    // Multiple works same author/year
    issues.push(...this.validateMultipleWorksSameYear(text));
    
    // Narrative vs parenthetical consistency
    issues.push(...this.validateCitationConsistency(text));
    
    return issues;
  }

  /**
   * Validate multiple authors formatting (up to 20 authors rules)
   */
  validateMultipleAuthors(text) {
    const issues = [];
    
    // Check for 3+ authors without et al.
    const threeAuthorsPattern = /\(([A-Z][a-z]+),\s+([A-Z][a-z]+),\s+(?:and|&)\s+([A-Z][a-z]+),\s+\d{4}\)/g;
    let match;
    
    while ((match = threeAuthorsPattern.exec(text)) !== null) {
      const citation = match[0];
      
      // For 3+ authors, first citation should list all, subsequent use et al.
      const firstAuthor = match[1];
      const etAlPattern = new RegExp(`\\(${firstAuthor},?\\s+et\\s+al\\.`, 'g');
      const hasEtAl = etAlPattern.test(text);
      
      if (!hasEtAl) {
        issues.push({
          title: "Multiple authors citation may need et al.",
          description: "Citations with 3+ authors should use 'et al.' after first mention",
          text: citation,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "After first citation, use: (FirstAuthor, et al., year)"
        });
      }
    }
    
    // Check for incorrect number of authors before et al.
    const etAlCitations = text.match(/\([^)]*et\s+al\.[^)]*\)/g) || [];
    etAlCitations.forEach(citation => {
      // Count commas before et al.
      const beforeEtAl = citation.split('et al.')[0];
      const authorCount = (beforeEtAl.match(/[A-Z][a-z]+/g) || []).length;
      
      if (authorCount > 2) {
        issues.push({
          title: "Too many authors before et al.",
          description: "List only first author before 'et al.' for 3+ authors",
          text: citation,
          severity: "Minor",
          category: "citations",
          hasFix: true,
          fixAction: "simplifyEtAlCitation",
          explanation: "Format: (FirstAuthor, et al., year) not (Author1, Author2, et al., year)"
        });
      }
    });
    
    // Check for 21+ authors rule
    const veryLongCitations = text.match(/\([^)]{200,}\)/g) || [];
    veryLongCitations.forEach(citation => {
      const authorCount = (citation.match(/[A-Z][a-z]+/g) || []).length;
      if (authorCount > 20) {
        issues.push({
          title: "Too many authors in citation",
          description: "For 21+ authors, cite first 19, then '...', then last author",
          text: citation.substring(0, 50) + '...',
          severity: "Major",
          category: "citations",
          hasFix: false,
          explanation: "Format: (Author1, Author2, ... Author19, ... LastAuthor, year)"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate secondary source citations (as cited in)
   */
  validateSecondarySources(text) {
    const issues = [];
    
    // Check for secondary source format
    const secondaryPattern = /\((?:as\s+)?cited\s+in\s+[^)]+\)/gi;
    const secondaryMatches = text.match(secondaryPattern) || [];
    
    secondaryMatches.forEach(citation => {
      // Check format: (Original, year, as cited in Secondary, year)
      if (!citation.match(/\([^,]+,\s*\d{4},?\s*as\s+cited\s+in\s+[^,]+,\s*\d{4}\)/i)) {
        issues.push({
          title: "Incorrect secondary source citation format",
          description: "Secondary citations need both original and secondary source years",
          text: citation,
          severity: "Major",
          category: "citations",
          hasFix: false,
          explanation: "Format: (OriginalAuthor, OriginalYear, as cited in SecondaryAuthor, SecondaryYear)"
        });
      }
    });
    
    // Check if primary source is in references
    const primarySources = text.match(/\(([^,]+),\s*\d{4},?\s*as\s+cited\s+in/gi) || [];
    if (primarySources.length > 0) {
      issues.push({
        title: "Secondary source used",
        description: "Consider finding and citing the primary source directly",
        text: primarySources[0],
        severity: "Minor",
        category: "citations",
        hasFix: false,
        explanation: "Only the secondary source should appear in references, not the original"
      });
    }
    
    return issues;
  }

  /**
   * Validate personal communication citations
   */
  validatePersonalCommunications(text) {
    const issues = [];
    
    // Check for personal communication format
    const personalCommPattern = /\(([^,)]+),\s*personal\s+communication,?\s*([^)]+)\)/gi;
    const personalComms = text.match(personalCommPattern) || [];
    
    personalComms.forEach(citation => {
      // Check for date format
      if (!citation.match(/,\s*(?:January|February|March|April|May|June|July|August|September|October|November|December)\s+\d{1,2},\s*\d{4}/)) {
        issues.push({
          title: "Personal communication missing full date",
          description: "Personal communications need full date (Month Day, Year)",
          text: citation,
          severity: "Major",
          category: "citations",
          hasFix: false,
          explanation: "Format: (J. Smith, personal communication, January 15, 2024)"
        });
      }
      
      // Check if in references (shouldn't be)
      const author = citation.match(/\(([^,]+),/)?.[1];
      if (author && text.includes('References') && text.indexOf('References') < text.length - 1000) {
        const referencesSection = text.substring(text.indexOf('References'));
        if (referencesSection.includes(author) && referencesSection.includes('personal communication')) {
          issues.push({
            title: "Personal communication in references",
            description: "Personal communications should not appear in reference list",
            text: citation,
            severity: "Major",
            category: "citations",
            hasFix: false,
            explanation: "Personal communications are cited in text only, not in references"
          });
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate corporate/group author citations
   */
  validateCorporateAuthors(text) {
    const issues = [];
    
    // Common corporate authors
    const corporatePattern = /\((?:American\s+Psychological\s+Association|World\s+Health\s+Organization|National\s+Institute|Centers\s+for\s+Disease|Department\s+of|Ministry\s+of|University\s+of)[^,)]*[,)]/gi;
    const corporateMatches = text.match(corporatePattern) || [];
    
    corporateMatches.forEach(citation => {
      // Check for abbreviation on first use
      const fullName = citation.match(/\(([^,)]+)/)?.[1];
      if (fullName && fullName.length > 20) {
        // Check if abbreviation is defined
        const abbrevPattern = new RegExp(`${fullName}\\s*\\[([A-Z]+)\\]`, 'i');
        const hasAbbrev = abbrevPattern.test(text.substring(0, text.indexOf(citation)));
        
        if (!hasAbbrev) {
          issues.push({
            title: "Long corporate author without abbreviation",
            description: "Define abbreviation for long organizational names on first use",
            text: citation.substring(0, 50) + '...',
            severity: "Minor",
            category: "citations",
            hasFix: false,
            explanation: "First use: (American Psychological Association [APA], 2020), then: (APA, 2020)"
          });
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate no date citations
   */
  validateNoDateCitations(text) {
    const issues = [];
    
    // Check for n.d. citations
    const ndPattern = /\(([^,)]+),\s*n\.d\.\)/g;
    const ndMatches = text.match(ndPattern) || [];
    
    if (ndMatches.length > 0) {
      // Check if used consistently
      ndMatches.forEach(citation => {
        const author = citation.match(/\(([^,]+),/)?.[1];
        if (author) {
          // Check if same author has dated citations too
          const datedPattern = new RegExp(`\\(${author},\\s*\\d{4}\\)`, 'g');
          if (datedPattern.test(text)) {
            issues.push({
              title: "Inconsistent dating for same author",
              description: `${author} has both dated and undated (n.d.) citations`,
              text: citation,
              severity: "Major",
              category: "citations",
              hasFix: false,
              explanation: "Verify if all works by this author have publication dates"
            });
          }
        }
      });
      
      // General warning about n.d. usage
      if (ndMatches.length > 3) {
        issues.push({
          title: "Multiple undated sources",
          description: "Document has many n.d. citations - verify if dates can be found",
          text: `${ndMatches.length} instances of n.d.`,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "Use (n.d.) only when publication date truly cannot be determined"
        });
      }
    }
    
    return issues;
  }

  /**
   * Validate multiple works by same author in same year
   */
  validateMultipleWorksSameYear(text) {
    const issues = [];
    
    // Find citations with letter suffixes (2021a, 2021b)
    const suffixPattern = /\(([^,)]+),\s*(\d{4})([a-z])\)/g;
    const suffixMatches = [...text.matchAll(suffixPattern)];
    
    const authorYearMap = new Map();
    
    suffixMatches.forEach(match => {
      const author = match[1];
      const year = match[2];
      const suffix = match[3];
      const key = `${author}_${year}`;
      
      if (!authorYearMap.has(key)) {
        authorYearMap.set(key, new Set());
      }
      authorYearMap.get(key).add(suffix);
    });
    
    // Check for missing or inconsistent suffixes
    authorYearMap.forEach((suffixes, key) => {
      const suffixArray = Array.from(suffixes).sort();
      
      // Check if sequence starts with 'a'
      if (!suffixArray.includes('a')) {
        const [author, year] = key.split('_');
        issues.push({
          title: "Letter suffix doesn't start with 'a'",
          description: `${author} (${year}) citations should start with 'a'`,
          text: `${author}, ${year}${suffixArray[0]}`,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "Multiple works same year should be labeled: 2024a, 2024b, 2024c..."
        });
      }
      
      // Check for gaps in sequence
      for (let i = 1; i < suffixArray.length; i++) {
        const expected = String.fromCharCode(suffixArray[0].charCodeAt(0) + i);
        if (suffixArray[i] !== expected) {
          const [author, year] = key.split('_');
          issues.push({
            title: "Gap in letter suffix sequence",
            description: `${author} (${year}) has non-consecutive letter suffixes`,
            text: `${suffixArray.join(', ')}`,
            severity: "Minor",
            category: "citations",
            hasFix: false,
            explanation: "Use consecutive letters: a, b, c, not a, c, d"
          });
          break;
        }
      }
    });
    
    return issues;
  }

  /**
   * Check narrative vs parenthetical citation consistency
   */
  validateCitationConsistency(text) {
    const issues = [];
    
    // Extract all citations
    const narrativeMatches = [...text.matchAll(this.narrativeCitationPattern)];
    const parentheticalMatches = [...text.matchAll(this.parentheticalCitationPattern)];
    
    // Track which style is used for each source
    const citationStyles = new Map();
    
    narrativeMatches.forEach(match => {
      const author = match[1];
      const year = match[2];
      const key = `${author}_${year}`;
      
      if (!citationStyles.has(key)) {
        citationStyles.set(key, { narrative: 0, parenthetical: 0 });
      }
      citationStyles.get(key).narrative++;
    });
    
    parentheticalMatches.forEach(match => {
      const citation = match[1];
      const authorMatch = citation.match(/([^,]+),\s*(\d{4})/);
      if (authorMatch) {
        const author = authorMatch[1].replace(/\s*&\s*/g, ' and ');
        const year = authorMatch[2];
        const key = `${author}_${year}`;
        
        if (!citationStyles.has(key)) {
          citationStyles.set(key, { narrative: 0, parenthetical: 0 });
        }
        citationStyles.get(key).parenthetical++;
      }
    });
    
    // Check for overuse of one style
    let totalNarrative = 0;
    let totalParenthetical = 0;
    
    citationStyles.forEach(style => {
      totalNarrative += style.narrative;
      totalParenthetical += style.parenthetical;
    });
    
    if (totalNarrative > 0 && totalParenthetical > 0) {
      const ratio = totalNarrative / totalParenthetical;
      
      if (ratio > 5 || ratio < 0.2) {
        issues.push({
          title: "Imbalanced citation style usage",
          description: ratio > 5 ? "Overuse of narrative citations" : "Overuse of parenthetical citations",
          text: `Narrative: ${totalNarrative}, Parenthetical: ${totalParenthetical}`,
          severity: "Minor",
          category: "citations",
          hasFix: false,
          explanation: "Vary citation style for better readability. Use narrative when author is subject, parenthetical for support."
        });
      }
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\biasFreeLanguageValidator.js
// src/utils/biasFreeLanguageValidator.js - Bias-free and inclusive language validation
'use client';

export class BiasFreeLanguageValidator {
  constructor() {
    // Gendered terms to avoid
    this.genderedTerms = {
      'mankind': 'humanity, humankind, people',
      'man-made': 'artificial, synthetic, manufactured',
      'chairman': 'chair, chairperson, coordinator',
      'policeman': 'police officer',
      'fireman': 'firefighter',
      'mailman': 'mail carrier, postal worker',
      'businessman': 'business person, executive',
      'manpower': 'workforce, personnel, staff',
      'man hours': 'work hours, person hours',
      'freshman': 'first-year student',
      'upperclassman': 'upper-level student',
      'forefathers': 'ancestors, founders',
      'mothering': 'parenting, nurturing',
      'fathering': 'parenting'
    };
    
    // Outdated disability terms
    this.disabilityTerms = {
      'handicapped': 'person with a disability',
      'crippled': 'person with a physical disability',
      'retarded': 'person with an intellectual disability',
      'mentally ill': 'person with a mental health condition',
      'suffers from': 'has, experiences',
      'victim of': 'person with, person who has',
      'wheelchair-bound': 'wheelchair user',
      'confined to a wheelchair': 'uses a wheelchair',
      'normal people': 'people without disabilities',
      'able-bodied': 'people without disabilities',
      'invalid': 'person with a disability',
      'afflicted with': 'has, experiences'
    };
    
    // Age-related biased terms
    this.ageTerms = {
      'elderly': 'older adults, older people',
      'senile': 'person with dementia',
      'old people': 'older adults',
      'the aged': 'older adults',
      'geriatric': 'older adult (unless medical context)'
    };
    
    // Racial/ethnic considerations
    this.racialConsiderations = {
      'minorities': 'specific group names or "people of color"',
      'non-white': 'people of color or specific groups',
      'oriental': 'Asian or specific nationality',
      'hispanic': 'Latino/Latina/Latinx or specific nationality',
      'indian': 'Native American, Indigenous, or specific tribe'
    };
  }

  /**
   * Main validation for bias-free language
   */
  validateBiasFreeLanguage(text, structure) {
    const issues = [];
    
    // Check gendered language
    issues.push(...this.checkGenderedLanguage(text));
    
    // Check person-first language for disabilities
    issues.push(...this.checkPersonFirstLanguage(text));
    
    // Check age-appropriate terminology
    issues.push(...this.checkAgeTerminology(text));
    
    // Check racial/ethnic terminology
    issues.push(...this.checkRacialEthnicTerminology(text));
    
    // Check sexual orientation/gender identity terms
    issues.push(...this.checkSOGITerminology(text));
    
    // Check generic pronoun usage
    issues.push(...this.checkGenericPronouns(text));
    
    return issues;
  }

  /**
   * Check for gendered language
   */
  checkGenderedLanguage(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    Object.entries(this.genderedTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        issues.push({
          title: "Gendered language detected",
          description: `"${firstMatch}" is gendered language`,
          text: context,
          severity: "Minor",
          category: "bias-free",
          hasFix: true,
          fixAction: "replaceGenderedTerm",
          fixValue: { original: firstMatch, replacement: alternative.split(',')[0].trim() },
          explanation: `Use gender-neutral terms: ${alternative}`
        });
        
        reportedTerms.add(term.toLowerCase());
      }
    });
    
    // Check for generic "he" or "his"
    const genericHePattern = /\b(he|his|him)\b[^.]*(student|participant|person|individual|researcher|subject|child|adult|employee|worker)/gi;
    const heMatches = [...text.matchAll(genericHePattern)];
    
    if (heMatches.length > 2) {
      issues.push({
        title: "Generic masculine pronouns",
        description: "Avoid using 'he/his/him' as generic pronouns",
        text: heMatches[0][0],
        severity: "Minor",
        category: "bias-free",
        hasFix: false,
        explanation: "Use 'they/their', alternate pronouns, or rephrase to avoid pronouns"
      });
    }
    
    return issues;
  }

  /**
   * Check person-first language for disabilities
   */
  checkPersonFirstLanguage(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    // Check outdated disability terms
    Object.entries(this.disabilityTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        issues.push({
          title: "Non-person-first disability language",
          description: `"${firstMatch}" should use person-first language`,
          text: context,
          severity: "Major",
          category: "bias-free",
          hasFix: true,
          fixAction: "usePersonFirst",
          fixValue: { original: firstMatch, replacement: alternative },
          explanation: `Use person-first: "${alternative}"`
        });
        
        reportedTerms.add(term.toLowerCase());
      }
    });
    
    // Check for disability-first language patterns
    const disabilityFirstPatterns = [
      /\b(autistic|blind|deaf|disabled|epileptic|schizophrenic)\s+(person|people|individual|child|adult|student)/gi,
      /\bthe\s+(blind|deaf|disabled|mentally ill|handicapped)\b/gi
    ];
    
    disabilityFirstPatterns.forEach(pattern => {
      const matches = text.match(pattern) || [];
      if (matches.length > 0 && !reportedTerms.has('disability-first')) {
        issues.push({
          title: "Disability-first language",
          description: "Use person-first language for disabilities",
          text: matches[0],
          severity: "Major",
          category: "bias-free",
          hasFix: false,
          explanation: "Say 'person with autism' not 'autistic person' (unless individual preference known)"
        });
        reportedTerms.add('disability-first');
      }
    });
    
    return issues;
  }

  /**
   * Check age-appropriate terminology
   */
  checkAgeTerminology(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    Object.entries(this.ageTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        // Check if in appropriate medical context
        const isMedicalContext = context.includes('geriatric medicine') || 
                                context.includes('geriatric care');
        
        if (!isMedicalContext || term !== 'geriatric') {
          issues.push({
            title: "Age-biased terminology",
            description: `"${firstMatch}" may be considered age-biased`,
            text: context,
            severity: "Minor",
            category: "bias-free",
            hasFix: true,
            fixAction: "replaceAgeTerm",
            fixValue: { original: firstMatch, replacement: alternative.split(',')[0].trim() },
            explanation: `Use: ${alternative}`
          });
          
          reportedTerms.add(term.toLowerCase());
        }
      }
    });
    
    // Check for specific age ranges
    const ageRangePattern = /\b(\d{2,3})[- ]years?[- ]old\b/gi;
    const ageMatches = text.match(ageRangePattern) || [];
    
    if (ageMatches.length > 0) {
      const ages = ageMatches.map(m => parseInt(m.match(/\d+/)[0]));
      const hasOlderAdults = ages.some(age => age >= 65);
      
      if (hasOlderAdults) {
        issues.push({
          title: "Consider age designations",
          description: "Be specific with age ranges for older adults",
          text: ageMatches[0],
          severity: "Minor",
          category: "bias-free",
          hasFix: false,
          explanation: "Use specific ages (65-80) rather than broad terms like 'elderly'"
        });
      }
    }
    
    return issues;
  }

  /**
   * Check racial and ethnic terminology
   */
  checkRacialEthnicTerminology(text) {
    const issues = [];
    const reportedTerms = new Set();
    
    Object.entries(this.racialConsiderations).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0 && !reportedTerms.has(term.toLowerCase())) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        // Special handling for "Indian" - check if it's about India
        if (term === 'indian' && (context.includes('India') || context.includes('Indian Ocean'))) {
          return; // Skip if referring to country
        }
        
        issues.push({
          title: "Consider racial/ethnic terminology",
          description: `"${firstMatch}" may need more specific terminology`,
          text: context,
          severity: "Minor",
          category: "bias-free",
          hasFix: false,
          explanation: `Consider using: ${alternative}`
        });
        
        reportedTerms.add(term.toLowerCase());
      }
    });
    
    // Check for proper capitalization of racial/ethnic terms
    const lowercaseGroups = /\b(black|white|indigenous|asian|latino|latina)\s+(person|people|man|woman|participant)/g;
    const lowercaseMatches = text.match(lowercaseGroups) || [];
    
    lowercaseMatches.forEach(match => {
      const racial = match.split(/\s+/)[0];
      if (racial === racial.toLowerCase()) {
        issues.push({
          title: "Capitalize racial/ethnic designations",
          description: `Capitalize '${racial}' when referring to racial/ethnic groups`,
          text: match,
          severity: "Minor",
          category: "bias-free",
          hasFix: true,
          fixAction: "capitalizeRacialTerm",
          explanation: "Use 'Black person' not 'black person', 'White participants' not 'white participants'"
        });
      }
    });
    
    return issues;
  }

  /**
   * Check sexual orientation and gender identity terminology
   */
  checkSOGITerminology(text) {
    const issues = [];
    
    // Outdated or inappropriate terms
    const outdatedTerms = {
      'homosexual': 'gay, lesbian, or specific identity',
      'sexual preference': 'sexual orientation',
      'lifestyle choice': 'sexual orientation or gender identity',
      'transgenders': 'transgender people',
      'transgendered': 'transgender',
      'sex change': 'gender affirmation surgery',
      'opposite sex': 'different sex/gender',
      'both genders': 'all genders',
      'preferred pronouns': 'pronouns'
    };
    
    Object.entries(outdatedTerms).forEach(([term, alternative]) => {
      const pattern = new RegExp(`\\b${term}\\b`, 'gi');
      const matches = text.match(pattern) || [];
      
      if (matches.length > 0) {
        const firstMatch = matches[0];
        const position = text.toLowerCase().indexOf(term.toLowerCase());
        const context = text.substring(Math.max(0, position - 30), position + term.length + 30);
        
        issues.push({
          title: "Outdated SOGI terminology",
          description: `"${firstMatch}" is outdated or inappropriate`,
          text: context,
          severity: "Major",
          category: "bias-free",
          hasFix: true,
          fixAction: "updateSOGITerm",
          fixValue: { original: firstMatch, replacement: alternative.split(',')[0].trim() },
          explanation: `Use: ${alternative}`
        });
      }
    });
    
    // Check for binary assumptions
    const binaryPatterns = [
      /\b(he|she)\s+or\s+(she|he)\b/gi,
      /\bmale\s+or\s+female\b/gi,
      /\bmen\s+and\s+women\b/gi,
      /\bboys\s+and\s+girls\b/gi
    ];
    
    let hasBinaryAssumption = false;
    binaryPatterns.forEach(pattern => {
      if (!hasBinaryAssumption && pattern.test(text)) {
        const match = text.match(pattern)[0];
        issues.push({
          title: "Binary gender assumption",
          description: "Consider inclusive language for all genders",
          text: match,
          severity: "Minor",
          category: "bias-free",
          hasFix: false,
          explanation: "Consider: 'all genders', 'they', or specific inclusive language"
        });
        hasBinaryAssumption = true;
      }
    });
    
    return issues;
  }

  /**
   * Check generic pronoun usage
   */
  checkGenericPronouns(text) {
    const issues = [];
    
    // Check for singular they usage (which is now acceptable)
    const singularTheyPattern = /\b(everyone|someone|anyone|each person|the student|the participant)\s+[^.]*\bthey\b/gi;
    const singularTheyMatches = text.match(singularTheyPattern) || [];
    
    // This is actually good - no issue needed, but we can provide positive feedback
    if (singularTheyMatches.length > 3) {
      // Good use of singular they - no issue
    }
    
    // Check for alternating pronouns (he/she throughout)
    const heCount = (text.match(/\bhe\b/gi) || []).length;
    const sheCount = (text.match(/\bshe\b/gi) || []).length;
    const theyCount = (text.match(/\bthey\b/gi) || []).length;
    
    if (heCount > 10 && sheCount < 2) {
      issues.push({
        title: "Overuse of masculine pronouns",
        description: "Document predominantly uses 'he' pronouns",
        text: `he: ${heCount} times, she: ${sheCount} times`,
        severity: "Minor",
        category: "bias-free",
        hasFix: false,
        explanation: "Balance pronoun use or use 'they' for generic references"
      });
    }
    
    if (sheCount > 10 && heCount < 2) {
      issues.push({
        title: "Overuse of feminine pronouns",
        description: "Document predominantly uses 'she' pronouns",
        text: `she: ${sheCount} times, he: ${heCount} times`,
        severity: "Minor",
        category: "bias-free",
        hasFix: false,
        explanation: "Balance pronoun use or use 'they' for generic references"
      });
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\comprehensiveValidator.js
// src/utils/comprehensiveValidator.js - Lists, abbreviations, and appendix validation
'use client';

export class ComprehensiveValidator {
  constructor() {
    this.commonAbbreviations = {
      'e.g.': 'for example',
      'i.e.': 'that is',
      'etc.': 'and so forth',
      'vs.': 'versus',
      'cf.': 'compare',
      'viz.': 'namely'
    };
  }

  /**
   * Validate lists and seriation
   */
  validateListsAndSeriation(text) {
    const issues = [];
    
    // Check bulleted lists
    const bulletPatterns = [/^[‚Ä¢¬∑‚ñ™‚ñ´‚ó¶‚Ä£‚ÅÉ]\s+/gm, /^\*\s+/gm, /^-\s+/gm];
    let hasBullets = false;
    
    bulletPatterns.forEach(pattern => {
      if (pattern.test(text)) {
        hasBullets = true;
      }
    });
    
    if (hasBullets) {
      // Check for parallel structure in lists
      const bulletLines = text.split('\n').filter(line => 
        bulletPatterns.some(p => p.test(line))
      );
      
      if (bulletLines.length > 2) {
        const startsWithVerb = bulletLines.filter(line => 
          /^[‚Ä¢¬∑‚ñ™‚ñ´‚ó¶‚Ä£‚ÅÉ*-]\s+[A-Z][a-z]+ing\b/.test(line)
        ).length;
        
        const startsWithNoun = bulletLines.filter(line => 
          /^[‚Ä¢¬∑‚ñ™‚ñ´‚ó¶‚Ä£‚ÅÉ*-]\s+[A-Z][a-z]+\s/.test(line) && 
          !/ing\b/.test(line.split(/\s+/)[1])
        ).length;
        
        if (startsWithVerb > 0 && startsWithNoun > 0) {
          issues.push({
            title: "Inconsistent list structure",
            description: "List items should have parallel grammatical structure",
            text: bulletLines[0].substring(0, 50),
            severity: "Minor",
            category: "lists",
            hasFix: false,
            explanation: "Start all items with same part of speech (all verbs or all nouns)"
          });
        }
      }
      
      // Check for punctuation consistency
      const withPeriods = bulletLines.filter(line => line.trim().endsWith('.')).length;
      const withoutPeriods = bulletLines.filter(line => 
        !line.trim().endsWith('.') && line.trim().length > 0
      ).length;
      
      if (withPeriods > 0 && withoutPeriods > 0) {
        issues.push({
          title: "Inconsistent list punctuation",
          description: "List items have mixed punctuation",
          severity: "Minor",
          category: "lists",
          hasFix: false,
          explanation: "Use periods for all items (complete sentences) or none (fragments)"
        });
      }
    }
    
    // Check numbered lists
    const numberedPattern = /^\d+[.)]\s+/gm;
    const numberedLines = text.split('\n').filter(line => numberedPattern.test(line));
    
    if (numberedLines.length > 1) {
      // Check sequence
      const numbers = numberedLines.map(line => 
        parseInt(line.match(/^(\d+)/)[1])
      );
      
      for (let i = 1; i < numbers.length; i++) {
        if (numbers[i] !== numbers[i-1] + 1) {
          issues.push({
            title: "Numbered list sequence error",
            description: "Numbered list has non-consecutive numbers",
            text: `${numbers[i-1]} followed by ${numbers[i]}`,
            severity: "Minor",
            category: "lists",
            hasFix: true,
            fixAction: "fixListNumbering",
            explanation: "Number lists consecutively: 1, 2, 3..."
          });
          break;
        }
      }
    }
    
    // Check in-sentence series (serial comma)
    const seriesPattern = /\b\w+,\s+\w+(?:,\s+\w+)*,?\s+and\s+\w+/g;
    const seriesMatches = text.match(seriesPattern) || [];
    
    seriesMatches.forEach(series => {
      const items = series.split(/,|\s+and\s+/).map(s => s.trim());
      if (items.length >= 3) {
        // Check for Oxford/serial comma
        if (!series.includes(', and')) {
          issues.push({
            title: "Missing serial comma",
            description: "APA requires serial comma before 'and' in lists",
            text: series,
            severity: "Minor",
            category: "lists",
            hasFix: true,
            fixAction: "addSerialComma",
            explanation: "Use: A, B, and C (not A, B and C)"
          });
        }
      }
    });
    
    // Check for complex series with semicolons
    const complexSeries = text.match(/[^.;]+;\s*[^.;]+;\s*and\s+[^.;]+/g) || [];
    complexSeries.forEach(series => {
      if (!series.includes('; and')) {
        issues.push({
          title: "Complex series punctuation",
          description: "Use semicolon before 'and' in complex series",
          text: series.substring(0, 50) + '...',
          severity: "Minor",
          category: "lists",
          hasFix: true,
          fixAction: "fixComplexSeries",
          explanation: "Complex items need: item A; item B; and item C"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate abbreviation management
   */
  validateAbbreviations(text) {
    const issues = [];
    const definedAbbreviations = new Set();
    const usedAbbreviations = new Map();
    
    // Find abbreviation definitions [ABBR] or (ABBR)
    const definitionPattern = /\b([A-Za-z][A-Za-z\s]+)\s*[\[(]([A-Z]{2,})\s*[\])]/g;
    const definitions = [...text.matchAll(definitionPattern)];
    
    definitions.forEach(match => {
      const fullTerm = match[1];
      const abbr = match[2];
      definedAbbreviations.add(abbr);
    });
    
    // Find used abbreviations (2+ capital letters)
    const abbrPattern = /\b([A-Z]{2,})\b/g;
    const abbreviations = [...text.matchAll(abbrPattern)];
    
    abbreviations.forEach(match => {
      const abbr = match[1];
      const position = match.index;
      
      // Skip common ones that don't need definition
      const skipList = ['USA', 'UK', 'US', 'AM', 'PM', 'BC', 'AD', 'DC', 'ID', 'OK', 'TV'];
      if (skipList.includes(abbr)) return;
      
      if (!usedAbbreviations.has(abbr)) {
        usedAbbreviations.set(abbr, []);
      }
      usedAbbreviations.get(abbr).push(position);
    });
    
    // Check for undefined abbreviations
    usedAbbreviations.forEach((positions, abbr) => {
      if (!definedAbbreviations.has(abbr) && positions.length > 1) {
        const firstPosition = positions[0];
        const context = text.substring(Math.max(0, firstPosition - 20), firstPosition + abbr.length + 20);
        
        issues.push({
          title: "Undefined abbreviation",
          description: `Abbreviation "${abbr}" used without definition`,
          text: context,
          severity: "Minor",
          category: "abbreviations",
          hasFix: false,
          explanation: "Define abbreviation on first use: American Psychological Association (APA)"
        });
      }
    });
    
    // Check Latin abbreviations usage
    Object.entries(this.commonAbbreviations).forEach(([abbr, meaning]) => {
      const pattern = new RegExp(`\\b${abbr.replace('.', '\\.')}`, 'g');
      const matches = text.match(pattern) || [];
      
      matches.forEach(match => {
        const position = text.indexOf(match);
        const context = text.substring(Math.max(0, position - 30), position + match.length + 30);
        
        // Check if in parentheses (required for e.g., i.e., etc.)
        const inParentheses = context.includes(`(${match}`) || 
                             context.includes(`(${meaning}`) ||
                             context.match(/\([^)]*$/);
        
        if (!inParentheses && ['e.g.', 'i.e.', 'etc.', 'cf.'].includes(abbr)) {
          issues.push({
            title: "Latin abbreviation outside parentheses",
            description: `"${abbr}" should only be used in parentheses`,
            text: context,
            severity: "Minor",
            category: "abbreviations",
            hasFix: true,
            fixAction: "replaceLatinAbbr",
            fixValue: { original: abbr, replacement: meaning },
            explanation: `In text use "${meaning}", in parentheses use "${abbr}"`
          });
        }
      })
    });
    
    // Check plural abbreviations
    const pluralAbbrPattern = /\b([A-Z]{2,})'s\b/g;
    const pluralAbbrs = text.match(pluralAbbrPattern) || [];
    
    pluralAbbrs.forEach(plural => {
      // Check if it has apostrophe (it shouldn't for plurals)
      if (plural.includes("'")) {
        issues.push({
          title: "Incorrect plural abbreviation",
          description: "Plural abbreviations don't use apostrophes",
          text: plural,
          severity: "Minor",
          category: "abbreviations",
          hasFix: true,
          fixAction: "fixPluralAbbr",
          explanation: "Use 'URLs' not 'URL's' for plurals"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate appendix and supplemental materials
   */
  validateAppendixAndSupplements(text, structure) {
    const issues = [];
    
    // Check for appendix references
    const appendixPattern = /\bAppendix\s+([A-Z])\b/g;
    const appendixRefs = [...text.matchAll(appendixPattern)];
    const referencedAppendices = new Set();
    const actualAppendices = new Set();
    
    appendixRefs.forEach(match => {
      const letter = match[1];
      const position = match.index;
      const context = text.substring(Math.max(0, position - 50), position + 100);
      
      // Check if this is the appendix itself or a reference to it
      if (context.match(/^Appendix\s+[A-Z]\s*\n/)) {
        actualAppendices.add(letter);
      } else {
        referencedAppendices.add(letter);
      }
    });
    
    // Check for missing appendices
    referencedAppendices.forEach(letter => {
      if (!actualAppendices.has(letter)) {
        issues.push({
          title: "Referenced appendix not found",
          description: `Appendix ${letter} is referenced but not included`,
          text: `Appendix ${letter}`,
          severity: "Major",
          category: "appendix",
          hasFix: false,
          explanation: "All referenced appendices must be included in the document"
        });
      }
    });
    
    // Check appendix order
    const appendixLetters = Array.from(actualAppendices).sort();
    for (let i = 0; i < appendixLetters.length; i++) {
      const expected = String.fromCharCode(65 + i); // A, B, C...
      if (appendixLetters[i] !== expected) {
        issues.push({
          title: "Appendix labeling sequence error",
          description: `Appendix ${appendixLetters[i]} out of sequence`,
          text: `Expected Appendix ${expected}`,
          severity: "Minor",
          category: "appendix",
          hasFix: false,
          explanation: "Label appendices consecutively: Appendix A, Appendix B, etc."
        });
        break;
      }
    }
    
    // Check for appendix titles
    actualAppendices.forEach(letter => {
      const titlePattern = new RegExp(`Appendix\\s+${letter}\\s*\\n\\s*([A-Z][^\\n]+)`, 'g');
      const titleMatch = text.match(titlePattern);
      
      if (!titleMatch) {
        issues.push({
          title: "Appendix missing title",
          description: `Appendix ${letter} should have a descriptive title`,
          text: `Appendix ${letter}`,
          severity: "Minor",
          category: "appendix",
          hasFix: false,
          explanation: "Each appendix needs a title: 'Appendix A: Survey Questions'"
        });
      }
    });
    
    // Check for callouts to appendices
    actualAppendices.forEach(letter => {
      const calloutPattern = new RegExp(`(?:see|See|shown in|presented in)\\s+Appendix\\s+${letter}`, 'g');
      const hasCallout = calloutPattern.test(text);
      
      if (!hasCallout) {
        // Check if appendix is mentioned at all before it appears
        const appendixPosition = text.indexOf(`Appendix ${letter}\n`);
        const mentionPattern = new RegExp(`Appendix\\s+${letter}`, 'g');
        const mentions = [...text.matchAll(mentionPattern)];
        
        const hasEarlierMention = mentions.some(m => m.index < appendixPosition);
        
        if (!hasEarlierMention) {
          issues.push({
            title: "Appendix not referenced in text",
            description: `Appendix ${letter} should be mentioned in the main text`,
            text: `Appendix ${letter}`,
            severity: "Minor",
            category: "appendix",
            hasFix: false,
            explanation: "Refer to each appendix in the main text before it appears"
          });
        }
      }
    });
    
    // Check for supplemental materials notation
    if (text.includes('supplemental material') || text.includes('supplementary material')) {
      const suppPattern = /supplementa[lr]y?\s+materials?\s+(?:is|are)?\s*available/gi;
      const suppMatches = text.match(suppPattern) || [];
      
      if (suppMatches.length > 0 && !text.includes('osf.io') && !text.includes('doi.org')) {
        issues.push({
          title: "Supplemental materials location not specified",
          description: "Specify where supplemental materials can be accessed",
          text: suppMatches[0],
          severity: "Minor",
          category: "appendix",
          hasFix: false,
          explanation: "Include repository URL or DOI for supplemental materials"
        });
      }
    }
    
    return issues;
  }

  /**
   * Additional title and heading validations
   */
  validateTitleAndHeadings(text) {
    const issues = [];
    
    // Check title length (‚â§12 words recommended)
    const lines = text.split('\n').filter(l => l.trim());
    if (lines.length > 0) {
      const potentialTitle = lines[0];
      const wordCount = potentialTitle.split(/\s+/).filter(w => w.length > 0).length;
      
      if (wordCount > 12 && wordCount < 30) {
        issues.push({
          title: "Title length",
          description: `Title has ${wordCount} words (recommended ‚â§12)`,
          text: potentialTitle.substring(0, 50) + '...',
          severity: "Minor",
          category: "headings",
          hasFix: false,
          explanation: "APA recommends concise titles of 12 words or fewer"
        });
      }
    }
    
    // Check for colon usage in titles
    const titleWithColon = lines[0]?.includes(':');
    if (titleWithColon) {
      const parts = lines[0].split(':');
      if (parts.length === 2 && parts[1].trim()[0] !== parts[1].trim()[0].toUpperCase()) {
        issues.push({
          title: "Subtitle capitalization",
          description: "Subtitle after colon should start with capital letter",
          text: lines[0].substring(0, 50),
          severity: "Minor",
          category: "headings",
          hasFix: true,
          fixAction: "capitalizeSubtitle",
          explanation: "Capitalize first word after colon in titles"
        });
      }
    }
    
    // Check heading length
    const headingPattern = /^(#{1,5}|[A-Z][^.!?]{5,50}$)/gm;
    const headings = text.match(headingPattern) || [];
    
    headings.forEach(heading => {
      const wordCount = heading.split(/\s+/).filter(w => w.length > 0).length;
      if (wordCount > 10) {
        issues.push({
          title: "Long heading",
          description: "Heading may be too long for clarity",
          text: heading.substring(0, 50),
          severity: "Minor",
          category: "headings",
          hasFix: false,
          explanation: "Keep headings concise and descriptive"
        });
      }
    });
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\enhancedApaAnalyzer.js
// src/utils/enhancedApaAnalyzer.js - Enhanced with reference and table/figure validation
'use client';

// Import specialized validators
import { ReferenceValidator } from './referenceValidator';
import { TableFigureValidator } from './tableFigureValidator';
import { HeaderFooterValidator } from './headerFooterValidator';
import { AdvancedCitationValidator } from './advancedCitationValidator';
import { QuotationValidator } from './quotationValidator';
import { StatisticalValidator } from './statisticalValidator';
import { BiasFreeLanguageValidator } from './biasFreeLanguageValidator';
import { ComprehensiveValidator } from './comprehensiveValidator';

// Enhanced APA 7th Edition Analyzer that works with rich document formatting data
export class EnhancedAPAAnalyzer {
  constructor() {
    this.apaStandards = {
      font: {
        family: 'times new roman',
        size: 12 // points
      },
      spacing: {
        line: 2.0, // double spacing
        paragraphAfter: 0, // no extra space after paragraphs
        paragraphBefore: 0
      },
      margins: {
        top: 1.0, // inches
        bottom: 1.0,
        left: 1.0,
        right: 1.0
      },
      indentation: {
        firstLine: 0.5 // inches
      }
    };
    
    // Initialize specialized validators
    this.referenceValidator = new ReferenceValidator();
    this.tableFigureValidator = new TableFigureValidator();
    this.headerFooterValidator = new HeaderFooterValidator();
    this.advancedCitationValidator = new AdvancedCitationValidator();
    this.quotationValidator = new QuotationValidator();
    this.statisticalValidator = new StatisticalValidator();
    this.biasFreeLanguageValidator = new BiasFreeLanguageValidator();
    this.comprehensiveValidator = new ComprehensiveValidator();
  }
  
  /**
   * Main analysis function - works with rich document data from server
   */
  analyzeDocument(documentData) {
    const issues = [];
    
    // Safely extract data with defaults
    const { 
      text = '', 
      html = '', 
      formatting = null, 
      structure = null 
    } = documentData || {};
    
    
    // 1. Analyze formatting with precise data (if available)
    if (formatting) {
      issues.push(...this.analyzeFormatting(formatting));
    } else {
      console.warn('‚ö†Ô∏è No formatting data available - using basic analysis');
      issues.push(...this.analyzeBasicFormatting(html));
    }
    
    // 2. Analyze document structure
    if (structure && text) {
      issues.push(...this.analyzeStructure(structure, text));
    } else if (text) {
      console.warn('‚ö†Ô∏è No structure data available - using text-based analysis');
      issues.push(...this.analyzeBasicStructure(text));
    }
    
    // 3. Analyze citations - use basic analysis for better results
    if (text) {
      console.log('üìö Using basic citation analysis for better coverage...');
      issues.push(...this.analyzeBasicCitations(text));
    }
    
    // 4. Analyze references with enhanced validation including deep formatting
    if (text) {
      // Pass italicized text for deep formatting validation
      const italicizedText = structure?.italicizedText || [];
      const referenceIssues = this.referenceValidator.validateReferences(text, structure, italicizedText);
      issues.push(...referenceIssues);
    }
    
    // 5. Analyze tables and figures including border validation
    if (text) {
      // Enhanced validation with table border information from XML
      const tableFigureIssues = this.tableFigureValidator.validateTablesAndFigures(text, structure, formatting);
      
      // Add table border validation if XML data is available
      if (structure?.tables) {
        tableFigureIssues.push(...this.validateTableBorders(structure.tables));
      }
      
      issues.push(...tableFigureIssues);
    }
    
    // 6. Analyze headers, footers, running heads, and page numbers
    if (text && structure) {
      const headerFooterIssues = this.headerFooterValidator.validateHeadersFooters(text, structure);
      issues.push(...headerFooterIssues);
    }
    
    // 7. Advanced citation validation
    if (text) {
      const advancedCitationIssues = this.advancedCitationValidator.validateAdvancedCitations(text, structure);
      issues.push(...advancedCitationIssues);
    }
    
    // 8. Quotation handling validation
    if (text) {
      const quotationIssues = this.quotationValidator.validateQuotations(text, structure);
      issues.push(...quotationIssues);
    }
    
    // 9. Statistical and numerical formatting
    if (text) {
      const statisticalIssues = this.statisticalValidator.validateStatistical(text, structure);
      issues.push(...statisticalIssues);
    }
    
    // 10. Bias-free language detection
    if (text) {
      const biasFreeIssues = this.biasFreeLanguageValidator.validateBiasFreeLanguage(text, structure);
      issues.push(...biasFreeIssues);
    }
    
    // 11. Lists, abbreviations, and appendices
    if (text) {
      issues.push(...this.comprehensiveValidator.validateListsAndSeriation(text));
      issues.push(...this.comprehensiveValidator.validateAbbreviations(text));
      issues.push(...this.comprehensiveValidator.validateAppendixAndSupplements(text, structure));
      issues.push(...this.comprehensiveValidator.validateTitleAndHeadings(text));
    }
    
    // 12. Analyze content compliance (original basic content check)
    if (text) {
      issues.push(...this.analyzeContent(text));
    }
    
    
    return this.prioritizeAndDeduplicateIssues(issues);
  }
  
  /**
   * Analyze formatting with precise measurements - FIXED with safe property access
   */
  analyzeFormatting(formatting) {
    const issues = [];
    
    
    // Safely access formatting properties
    const documentFormatting = formatting?.document || {};
    const font = documentFormatting.font || {};
    const spacing = documentFormatting.spacing || {};
    const margins = documentFormatting.margins || {};
    const indentation = documentFormatting.indentation || {};
    const paragraphs = formatting?.paragraphs || [];
    const compliance = formatting?.compliance || {};
    
    // Check font family - SAFE ACCESS
    if (font.family) {
      const fontFamily = font.family.toLowerCase();
      if (!fontFamily.includes('times new roman') && 
          !fontFamily.includes('times') && 
          !fontFamily.includes('liberation serif')) {
        issues.push({
          title: "Incorrect font family",
          description: `Document uses "${font.family}" instead of Times New Roman`,
          text: `Font: ${font.family}`,
          severity: "Major",
          category: "formatting",
          location: { type: "document", section: "font" },
          hasFix: true,
          fixAction: "fixFont",
          explanation: "APA 7th edition requires Times New Roman 12pt font throughout the document."
        });
      }
    } else if (compliance.font && !compliance.font.family) {
      issues.push({
        title: "Font family not specified or non-compliant",
        description: "Document should use Times New Roman font",
        severity: "Major",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    // Check font size with tolerance - SAFE ACCESS
    if (font.size && Math.abs(font.size - 12) > 0.5) {
      issues.push({
        title: "Incorrect font size",
        description: `Font size is ${font.size}pt instead of 12pt`,
        text: `Font size: ${font.size}pt`,
        severity: "Major",
        category: "formatting", 
        location: { type: "document", section: "font" },
        hasFix: true,
        fixAction: "fixFontSize",
        explanation: "APA 7th edition requires 12-point font size."
      });
    }
    
    // Check line spacing - SAFE ACCESS
    if (spacing.line && Math.abs(spacing.line - 2.0) > 0.1) {
      issues.push({
        title: "Incorrect line spacing",
        description: `Line spacing is ${spacing.line} instead of double (2.0)`,
        text: `Line spacing: ${spacing.line}`,
        severity: "Major",
        category: "formatting", 
        location: { type: "document", section: "spacing" },
        hasFix: true,
        fixAction: "fixLineSpacing",
        explanation: "APA 7th edition requires double spacing (2.0) throughout the document."
      });
    }
    
    // Check margins with tolerance - SAFE ACCESS
    const marginIssues = [];
    Object.entries(this.apaStandards.margins).forEach(([side, required]) => {
      const actual = margins[side];
      if (actual !== null && actual !== undefined && Math.abs(actual - required) > 0.1) {
        marginIssues.push(`${side}: ${actual}" (should be ${required}")`);
      }
    });
    
    if (marginIssues.length > 0) {
      issues.push({
        title: "Incorrect margins",
        description: `Margins are not 1 inch: ${marginIssues.join(', ')}`,
        text: marginIssues.join(', '),
        severity: "Major",
        category: "formatting",
        location: { type: "document", section: "margins" },
        hasFix: true,
        fixAction: "fixMargins",
        explanation: "APA 7th edition requires 1-inch margins on all sides."
      });
    }
    
    // Check paragraph indentation - SAFE ACCESS
    if (paragraphs.length > 0) {
      const bodyParagraphs = paragraphs.filter(p => 
        p && p.indentation && (p.indentation.firstLine !== null || p.indentation.left !== null)
      );
      
      const incorrectIndentation = bodyParagraphs.filter(p => {
        const firstLine = (p.indentation && p.indentation.firstLine) || 0;
        return Math.abs(firstLine - 0.5) > 0.05; // 5% tolerance
      });
      
      if (bodyParagraphs.length > 0 && incorrectIndentation.length > 0) {
        issues.push({
          title: "Incorrect paragraph indentation",
          description: `${incorrectIndentation.length} of ${bodyParagraphs.length} paragraphs have incorrect first-line indentation`,
          text: `Expected: 0.5", Found: varies`,
          severity: "Minor",
          category: "formatting",
          location: { 
            type: "paragraph", 
            indices: incorrectIndentation.map(p => p.index).slice(0, 5) 
          },
          hasFix: true,
          fixAction: "fixIndentation",
          explanation: "APA 7th edition requires 0.5-inch first-line indentation for all paragraphs."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback formatting analysis for when rich data isn't available
   */
  analyzeBasicFormatting(html) {
    const issues = [];
    
    
    if (!html) return issues;
    
    // Check font family
    const fontCheck = html.match(/font-family:\s*['"]([^'"]+)['"]/i);
    if (fontCheck && !fontCheck[1].toLowerCase().includes('times new roman')) {
      issues.push({
        title: "Incorrect font detected",
        description: `Document appears to use "${fontCheck[1]}" instead of Times New Roman`,
        text: `Font: ${fontCheck[1]}`,
        severity: "Minor",
        category: "formatting",
        hasFix: true,
        fixAction: "fixFont",
        explanation: "APA 7th edition requires Times New Roman font."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze document structure with heading hierarchy
   */
  analyzeStructure(structure, text) {
    const issues = [];
    
    
    if (!structure || !text) return issues;
    
    const headings = structure.headings || [];
    const sections = structure.sections || [];
    const citations = structure.citations || [];
    
    // 1. Check for required sections
    const hasAbstract = sections.some(s => s.type === 'abstract') || text.toLowerCase().includes('abstract');
    const hasReferences = sections.some(s => s.type === 'references') || text.toLowerCase().includes('references');
    const wordCount = text.split(/\s+/).length;
    
    if (wordCount > 1000 && !hasAbstract) {
      issues.push({
        title: "Missing abstract",
        description: "Long papers typically require an abstract",
        severity: "Major",
        category: "structure",
        hasFix: true,
        fixAction: "addAbstract",
        explanation: "Papers longer than 1000 words typically require an abstract (150-250 words) summarizing the main points."
      });
    }
    
    if (!hasReferences && citations.length > 0) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    // 2. Check heading hierarchy
    if (headings.length > 1) {
      for (let i = 1; i < headings.length; i++) {
        const current = headings[i];
        const previous = headings[i - 1];
        
        if (current.level > previous.level + 1) {
          issues.push({
            title: "Improper heading hierarchy",
            description: `Heading level ${current.level} follows level ${previous.level}`,
            text: `"${current.text}" (Level ${current.level}) after "${previous.text}" (Level ${previous.level})`,
            severity: "Major",
            category: "structure",
            location: { 
              type: "heading", 
              paragraphIndex: current.paragraphIndex 
            },
            hasFix: true,
            fixAction: "fixHeadingLevel",
            explanation: "Headings must follow sequential order: Level 1, then Level 2, then Level 3, etc. Don't skip levels."
          });
        }
      }
    }
    
    return issues;
  }
  
  /**
   * Fallback structure analysis
   */
  analyzeBasicStructure(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,\s*\d{4}\)/.test(text);
    
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing references section",
        description: "Document has citations but no references section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesSection",
        explanation: "All sources cited in the text must be listed in a References section."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze citations with extracted citation data
   */
  analyzeCitations(text, extractedCitations) {
    const issues = [];
    
    
    // Use extracted citations for more accurate analysis
    const citations = extractedCitations || [];
    
    citations.forEach((citation, index) => {
      // Check author-year format - SAFE ACCESS
      if (!citation.year || !citation.author) {
        issues.push({
          title: "Incomplete citation",
          description: "Citation missing author or year",
          text: citation.text || 'Unknown citation',
          severity: "Major",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: false,
          explanation: "All in-text citations must include author surname(s) and publication year."
        });
        return;
      }
      
      // Check for proper punctuation
      if (citation.text && !citation.text.includes(`, ${citation.year}`)) {
        issues.push({
          title: "Missing comma in citation",
          description: "Citation missing comma between author and year",
          text: citation.text,
          severity: "Minor",
          category: "citations",
          location: { 
            type: "citation", 
            paragraphIndex: citation.paragraphIndex,
            citationIndex: index 
          },
          hasFix: true,
          fixAction: "addCitationComma",
          explanation: "In-text citations require a comma between the author name and year: (Smith, 2023)."
        });
      }
    });
    
    return issues;
  }
  
  /**
   * Fallback citation analysis
   */
  analyzeBasicCitations(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Enhanced citation patterns to catch all APA violations
    
    // 1. Check for citations missing commas (Author YEAR) format - but exclude et al. cases
    const missingCommaPattern = /\(([A-Za-z][A-Za-z\s&.]+(?<!et\s+al))\s+(\d{4})\)/g;
    let missingCommaMatch;
    while ((missingCommaMatch = missingCommaPattern.exec(text)) !== null) {
      const fullCitation = missingCommaMatch[0];
      const authorPart = missingCommaMatch[1];
      
      // Skip if this contains et al. - handle separately
      if (authorPart.includes('et al')) continue;
      
      
      issues.push({
        title: "Missing comma in citation",
        description: "Citations must have a comma between author and year",
        text: fullCitation,
        severity: "Minor", 
        category: "citations",
        hasFix: true,
        fixAction: "addCitationComma",
        explanation: "APA format requires a comma between author name(s) and year: (Author, YEAR)."
      });
    }
    
    // 2. Standard citation pattern with comma (Author, YEAR)
    const citationPattern = /\(([^)]+),\s*(\d{4})[^)]*\)/g;
    let match;
    let citationCount = 0;
    
    while ((match = citationPattern.exec(text)) !== null) {
      citationCount++;
      const fullCitation = match[0];
      const authorPart = match[1];
      
      
      // Check for incorrect ampersand usage
      if (authorPart.includes(' and ') && fullCitation.includes('(')) {
        issues.push({
          title: "Incorrect connector in parenthetical citation",
          description: "Use '&' instead of 'and' in parenthetical citations",
          text: fullCitation,
          severity: "Minor",
          category: "citations",
          hasFix: true,
          fixAction: "fixParentheticalConnector",
          explanation: "In parenthetical citations, use & to connect author names."
        });
      }
      
      // Check for incorrect et al. formatting - APA 7th edition REQUIRES comma before et al.
      if (authorPart.includes(' et al.') && !authorPart.includes(', et al.')) {
        issues.push({
          title: "Missing comma before et al.",
          description: "APA 7th edition requires comma before 'et al.' in citations",
          text: fullCitation,
          severity: "Minor",
          category: "citations", 
          hasFix: true,
          fixAction: "fixEtAlFormatting",
          explanation: "APA 7th edition requires a comma before 'et al.': (Smith, et al., 2021)."
        });
      }
    }
    
    
    // 3. Analyze References section for consistency issues
    const referencesSection = text.match(/REFERENCES([\s\S]*?)(?=\n\n[A-Z]|$)/i);
    if (referencesSection) {
      const referencesText = referencesSection[1];
      
      // Check for "and" instead of "&" in references
      const andInReferencesPattern = /^[^.]+,\s+[^,]+,\s+and\s+[^,]+\./gm;
      let andMatch;
      while ((andMatch = andInReferencesPattern.exec(referencesText)) !== null) {
        issues.push({
          title: "Incorrect connector in reference",
          description: "Use '&' instead of 'and' in reference list",
          text: andMatch[0],
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixReferenceConnector",
          explanation: "In reference lists, use & (ampersand) to connect author names, not 'and'."
        });
      }
      
      // Check for missing DOI/URL when available
      const lines = referencesText.split('\n').filter(line => line.trim().length > 0);
      lines.forEach((line, index) => {
        if (line.match(/^\s*[A-Z]/)) { // Reference entry line
          if (!line.includes('doi:') && !line.includes('http') && !line.includes('Retrieved from')) {
            if (line.toLowerCase().includes('journal') || line.toLowerCase().includes('article')) {
              issues.push({
                title: "Missing DOI or URL",
                description: "Journal articles should include DOI or URL when available",
                text: line.substring(0, 100) + '...',
                severity: "Minor",
                category: "references",
                hasFix: false,
                explanation: "Include DOI (preferred) or URL for journal articles and online sources when available."
              });
            }
          }
        }
      });
    }
    
    // 4. Check for title page issues
    const titlePageIssues = this.analyzeTitlePage(text);
    issues.push(...titlePageIssues);
    
    // 5. Check for spacing issues around citations
    const spacingIssuePattern = /[^\s]\(([^)]+,\s*\d{4})\)|(\([^)]+,\s*\d{4}\))[^\s.,;]/g;
    let spacingMatch;
    while ((spacingMatch = spacingIssuePattern.exec(text)) !== null) {
      issues.push({
        title: "Citation spacing error",
        description: "Citations need proper spacing before and after",
        text: spacingMatch[0],
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "There should be a space before opening parenthesis and proper punctuation after citations."
      });
    }
    
    // 6. Check for URLs in text that should be properly formatted
    const urlInTextPattern = /https?:\/\/[^\s)]+/g;
    let urlMatch;
    while ((urlMatch = urlInTextPattern.exec(text)) !== null) {
      if (!text.includes('Retrieved from') || !text.includes('doi:')) {
        issues.push({
          title: "URL formatting in text",
          description: "URLs should be properly formatted in references, not embedded in text",
          text: urlMatch[0],
          severity: "Minor",
          category: "formatting",
          hasFix: false,
          explanation: "URLs should appear in the reference list, not embedded in the main text."
        });
      }
    }
    
    // 7. Check for ALL CAPS headings (more precise detection)
    const allCapsHeadingPattern = /\n\s*([A-Z][A-Z\s]{8,})\s*\n/g;
    let titleMatch;
    while ((titleMatch = allCapsHeadingPattern.exec(text)) !== null) {
      const heading = titleMatch[1].trim();
      // Only flag if it's truly ALL CAPS and looks like a heading
      if (heading.length > 8 && heading === heading.toUpperCase() && 
          !heading.includes('(') && !heading.includes(',') && 
          heading.split(' ').length <= 8) {
        issues.push({
          title: "ALL CAPS heading detected",
          description: "Headings should use title case or sentence case, not ALL CAPS",
          text: heading,
          severity: "Minor",
          category: "formatting", 
          hasFix: true,
          fixAction: "fixAllCapsHeading",
          explanation: "APA 7th edition headings should use title case (Level 1-3) or sentence case (Level 4-5), not ALL CAPS."
        });
      }
    }
    
    // 8. Check for paragraph structure (multiple consecutive line breaks)
    const excessiveBreaksPattern = /\n\s*\n\s*\n\s*\n/g;
    if (excessiveBreaksPattern.test(text)) {
      issues.push({
        title: "Excessive line spacing",
        description: "Too many blank lines between paragraphs",
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "APA format uses double-spacing with no extra blank lines between paragraphs."
      });
    }
    
    // 9. Check for sentences ending without punctuation (more precise)
    const incompleteSentencePattern = /[a-z]\s+[A-Z][a-z]/g;
    let incompleteMatch;
    let sentenceIssueCount = 0;
    while ((incompleteMatch = incompleteSentencePattern.exec(text)) && sentenceIssueCount < 3) {
      const context = text.substring(Math.max(0, incompleteMatch.index - 30), incompleteMatch.index + 50);
      
      // Skip if this looks like an abbreviation or proper formatting
      if (context.includes('Dr.') || context.includes('Mr.') || context.includes('Ms.') ||
          context.includes('etc.') || context.includes('i.e.') || context.includes('e.g.') ||
          context.match(/\d+\s+[A-Z]/) || // Numbers followed by caps (like page numbers)
          context.includes('(') || context.includes(')')) {
        continue;
      }
      
      sentenceIssueCount++;
      issues.push({
        title: "Possible missing punctuation",
        description: "Check if sentence needs proper punctuation",
        text: context.trim().substring(0, 60) + '...',
        severity: "Minor",
        category: "formatting",
        hasFix: false,
        explanation: "Sentences should end with appropriate punctuation before starting a new sentence."
      });
    }
    
    // Check for direct quotes without page numbers
    const quotePattern = /[""][^""]{10,}[""]\s*(\([^)]+\))/g;
    let quoteMatch;
    while ((quoteMatch = quotePattern.exec(text)) !== null) {
      const citation = quoteMatch[1];
      if (!citation.match(/,\s*p\.?\s*\d+/)) {
        issues.push({
          title: "Direct quote missing page number",
          description: "Direct quotes require page numbers",
          text: quoteMatch[0],
          severity: "Major",
          category: "citations",
          hasFix: true,
          fixAction: "addPageNumber",
          explanation: "All direct quotations must include a page number to help readers locate the original text."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Analyze title page structure
   */
  analyzeTitlePage(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    const firstPage = text.substring(0, 1500); // First ~1500 chars for title page
    
    // Check for required elements in order
    const lines = firstPage.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    if (lines.length < 3) {
      issues.push({
        title: "Incomplete title page",
        description: "Title page appears to be missing required elements",
        severity: "Major",
        category: "structure",
        hasFix: false,
        explanation: "APA title page requires: paper title, author name(s), institutional affiliation, and author note."
      });
      return issues;
    }
    
    // Check if title is centered (simple heuristic - no excessive leading spaces)
    const possibleTitle = lines[0];
    if (possibleTitle.length > 5 && possibleTitle.startsWith('  ')) {
      // This might indicate improper formatting, but it's hard to detect without rich formatting
    }
    
    // Check for common title page issues
    const titlePageText = firstPage.toLowerCase();
    
    // Check for missing running head
    if (!titlePageText.includes('running head') && !titlePageText.includes('page')) {
      issues.push({
        title: "Missing running head",
        description: "Title page should include a running head (for professional papers)",
        severity: "Minor", 
        category: "structure",
        hasFix: false,
        explanation: "Professional papers require a running head on the title page and throughout the document."
      });
    }
    
    // Check for in-text citations on title page (but be more selective)
    const citationPattern = /\([A-Za-z]+,?\s+\d{4}\)/g;
    const citationsOnTitlePage = firstPage.match(citationPattern);
    if (citationsOnTitlePage && citationsOnTitlePage.length > 0) {
      // Only flag if it's clearly in the main title page content, not in author notes
      const titlePageWithoutAuthorNote = firstPage.split('Author Note')[0];
      if (citationPattern.test(titlePageWithoutAuthorNote)) {
        issues.push({
          title: "Citations on title page",
          description: "Title page should not contain in-text citations",
          severity: "Minor",
          category: "structure", 
          hasFix: false,
          explanation: "The title page should contain only title, author, affiliation information - no citations."
        });
      }
    }
    
    return issues;
  }
  
  /**
   * Validate table borders from XML data
   */
  validateTableBorders(tables) {
    const issues = [];
    
    tables.forEach((table, index) => {
      // Check for vertical lines (APA doesn't use them)
      if (table.hasVerticalLines) {
        issues.push({
          title: "Vertical lines in table",
          description: `Table ${index + 1} contains vertical lines which violate APA format`,
          text: `Table ${index + 1}`,
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "removeTableVerticalLines",
          explanation: "APA style tables should not use vertical lines. Use only horizontal lines for clarity."
        });
      }
      
      // Check for excessive borders
      if (table.hasFullBorders) {
        issues.push({
          title: "Excessive borders in table",
          description: `Table ${index + 1} has full borders instead of APA style minimal borders`,
          text: `Table ${index + 1}`,
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "fixTableBorders",
          explanation: "APA tables use minimal borders: horizontal lines at top, bottom, and below column headings only."
        });
      }
      
      // Check for proper APA table border style
      if (table.borderStyle) {
        const hasProperBorders = table.borderStyle.top && 
                                table.borderStyle.bottom && 
                                table.borderStyle.insideH && 
                                !table.borderStyle.left && 
                                !table.borderStyle.right && 
                                !table.borderStyle.insideV;
        
        if (!hasProperBorders && !table.hasFullBorders) {
          issues.push({
            title: "Incorrect table border style",
            description: `Table ${index + 1} doesn't follow APA border guidelines`,
            text: `Table ${index + 1}`,
            severity: "Minor",
            category: "tables",
            hasFix: true,
            fixAction: "fixTableBorderStyle",
            explanation: "APA tables should have horizontal lines at top, bottom, and after header row only."
          });
        }
      }
    });
    
    return issues;
  }

  /**
   * Legacy analyze references section - kept for backward compatibility
   * Now replaced by ReferenceValidator for comprehensive validation
   * @deprecated Use ReferenceValidator.validateReferences() instead
   */
  analyzeReferences(text, structure) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Simple check - if we have citations but no references section
    const hasReferences = text.toLowerCase().includes('references');
    const hasCitations = /\([^)]+,?\s*\d{4}\)/.test(text);
    
    
    if (hasCitations && !hasReferences) {
      issues.push({
        title: "Missing References section",
        description: "Document has citations but no References section",
        severity: "Critical",
        category: "structure",
        hasFix: true,
        fixAction: "addReferencesHeader",
        explanation: "All APA papers must include a References section."
      });
    }
    
    const referencesMatch = text.match(/References[\s\n]+([\s\S]+?)(?:\n\n[A-Z]|$)/i);
    if (!referencesMatch) return issues;
    
    const referencesText = referencesMatch[1].trim();
    const referenceEntries = referencesText
      .split(/\n\s*\n/)
      .filter(entry => entry.trim().length > 10);
    
    if (referenceEntries.length === 0) {
      issues.push({
        title: "Empty references section",
        description: "References section contains no entries",
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "The References section must contain entries for all sources cited in your paper."
      });
      return issues;
    }
    
    // Check alphabetical order
    const firstWords = referenceEntries.map(entry => {
      const match = entry.match(/^([^,\s]+)/);
      return match ? match[1].toLowerCase() : '';
    });
    
    const sortedFirstWords = [...firstWords].sort();
    const isAlphabetical = JSON.stringify(firstWords) === JSON.stringify(sortedFirstWords);
    
    if (!isAlphabetical) {
      issues.push({
        title: "References not in alphabetical order",
        description: "Reference entries must be alphabetized by first author's surname",
        text: `First entries: ${firstWords.slice(0, 3).join(', ')}...`,
        severity: "Major",
        category: "references",
        hasFix: true,
        fixAction: "sortReferences",
        explanation: "References must be arranged in alphabetical order by the surname of the first author."
      });
    }
    
    return issues;
  }
  
  /**
   * Analyze content for APA compliance
   */
  analyzeContent(text) {
    const issues = [];
    
    if (!text) return issues;
    
    
    // Check for excessive first person usage
    const firstPersonPattern = /\b(I|me|my|mine|we|us|our|ours)\b/gi;
    const firstPersonMatches = text.match(firstPersonPattern) || [];
    const wordCount = text.split(/\s+/).length;
    
    if (firstPersonMatches.length > wordCount * 0.02) { // More than 2%
      issues.push({
        title: "Excessive first-person usage",
        description: "Consider reducing first-person pronouns in formal academic writing",
        text: `Found ${firstPersonMatches.length} instances`,
        severity: "Minor",
        category: "content",
        hasFix: false,
        explanation: "While not prohibited, excessive first-person usage should be avoided in formal academic writing."
      });
    }
    
    return issues;
  }
  
  /**
   * Helper methods
   */
  prioritizeAndDeduplicateIssues(issues) {
    // Remove duplicates based on title and text
    const unique = issues.filter((issue, index, self) => 
      index === self.findIndex(i => 
        i.title === issue.title && i.text === issue.text
      )
    );
    
    // Sort by severity and category
    const severityOrder = { 'Critical': 0, 'Major': 1, 'Minor': 2 };
    const categoryOrder = { 
      'formatting': 0, 
      'structure': 1, 
      'citations': 2, 
      'references': 3, 
      'content': 4 
    };
    
    return unique.sort((a, b) => {
      // First by severity
      const severityCompare = severityOrder[a.severity] - severityOrder[b.severity];
      if (severityCompare !== 0) return severityCompare;
      
      // Then by category
      return categoryOrder[a.category] - categoryOrder[b.category];
    });
  }
}

// Usage function that matches what your store expects
export function analyzeAPADocument(documentData) {
  const analyzer = new EnhancedAPAAnalyzer();
  return analyzer.analyzeDocument(documentData);
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\headerFooterValidator.js
// src/utils/headerFooterValidator.js - Running head and page number validation
'use client';

export class HeaderFooterValidator {
  constructor() {
    this.maxRunningHeadLength = 50;
  }

  /**
   * Validate headers, footers, running head, and page numbers
   */
  validateHeadersFooters(text, structure) {
    const issues = [];
    
    // Extract headers/footers from structure if available
    const headersFooters = structure?.headersFooters || {};
    
    // Validate running head
    issues.push(...this.validateRunningHead(headersFooters, text));
    
    // Validate page numbers
    issues.push(...this.validatePageNumbers(headersFooters, text));
    
    // Check for different first page header
    issues.push(...this.validateFirstPageHeader(headersFooters, text));
    
    // Validate section breaks
    issues.push(...this.validateSectionBreaks(headersFooters, text));
    
    return issues;
  }

  /**
   * Validate running head format
   */
  validateRunningHead(headersFooters, text) {
    const issues = [];
    
    // Check if document appears to be a professional paper (longer documents typically are)
    const wordCount = text.split(/\s+/).filter(Boolean).length;
    const isProfessionalPaper = wordCount > 3000 || text.toLowerCase().includes('running head');
    
    if (isProfessionalPaper) {
      const runningHead = headersFooters.runningHead;
      
      // Check if running head exists
      if (!runningHead && !headersFooters.headers?.length) {
        issues.push({
          title: "Missing running head",
          description: "Professional papers require a running head in the page header",
          severity: "Major",
          category: "headers",
          hasFix: false,
          explanation: "Add a running head in the format: 'Running head: ABBREVIATED TITLE' on the title page, then 'ABBREVIATED TITLE' on subsequent pages."
        });
        return issues;
      }
      
      if (runningHead) {
        // Check length (max 50 characters)
        if (runningHead.length > this.maxRunningHeadLength) {
          issues.push({
            title: "Running head too long",
            description: `Running head is ${runningHead.length} characters (max 50)`,
            text: runningHead.text,
            severity: "Major",
            category: "headers",
            hasFix: false,
            explanation: "Running head must be 50 characters or less including spaces and punctuation."
          });
        }
        
        // Check if all caps
        if (runningHead.text && !runningHead.allCaps) {
          const upperText = runningHead.text.replace(/^Running head:\s*/i, '');
          if (upperText !== upperText.toUpperCase()) {
            issues.push({
              title: "Running head not in all caps",
              description: "Running head should be in ALL CAPITAL LETTERS",
              text: runningHead.text,
              severity: "Minor",
              category: "headers",
              hasFix: true,
              fixAction: "fixRunningHeadCaps",
              explanation: "The running head text (after 'Running head:') should be in all capital letters."
            });
          }
        }
        
        // Check first page format
        const firstPageHasLabel = text.substring(0, 2000).includes('Running head:');
        const hasRunningHeadText = runningHead.text && runningHead.text.length > 0;
        
        if (hasRunningHeadText && !firstPageHasLabel) {
          issues.push({
            title: "Missing 'Running head:' label on title page",
            description: "Title page should include 'Running head:' before the abbreviated title",
            severity: "Minor",
            category: "headers",
            hasFix: true,
            fixAction: "addRunningHeadLabel",
            explanation: "The title page header should read 'Running head: ABBREVIATED TITLE' while subsequent pages show only 'ABBREVIATED TITLE'."
          });
        }
      }
    }
    
    return issues;
  }

  /**
   * Validate page number positioning
   */
  validatePageNumbers(headersFooters, text) {
    const issues = [];
    const pageNumbers = headersFooters.pageNumbers || {};
    
    // Check if page numbers exist
    if (!pageNumbers.present) {
      // Check if document has multiple pages (rough estimate based on content)
      const estimatedPages = Math.ceil(text.split(/\s+/).length / 250); // ~250 words per page
      
      if (estimatedPages > 1) {
        issues.push({
          title: "Missing page numbers",
          description: "Document appears to have multiple pages but no page numbers detected",
          severity: "Major",
          category: "headers",
          hasFix: false,
          explanation: "All pages should be numbered consecutively, starting with the title page as page 1."
        });
      }
    } else {
      // Check positioning (should be top right)
      if (pageNumbers.position && pageNumbers.position !== 'right') {
        issues.push({
          title: "Incorrect page number position",
          description: `Page numbers are ${pageNumbers.position}-aligned instead of right-aligned`,
          severity: "Minor",
          category: "headers",
          hasFix: true,
          fixAction: "fixPageNumberPosition",
          explanation: "Page numbers should be positioned in the top right corner of every page."
        });
      }
      
      // Check if in header (not footer)
      const inFooter = headersFooters.footers?.some(f => f.hasPageNumber);
      const inHeader = headersFooters.headers?.some(h => h.hasPageNumber);
      
      if (inFooter && !inHeader) {
        issues.push({
          title: "Page numbers in footer instead of header",
          description: "Page numbers should be in the header, not the footer",
          severity: "Major",
          category: "headers",
          hasFix: true,
          fixAction: "movePageNumbersToHeader",
          explanation: "APA format requires page numbers in the top right corner of the header, not in the footer."
        });
      }
    }
    
    return issues;
  }

  /**
   * Validate first page header differences
   */
  validateFirstPageHeader(headersFooters, text) {
    const issues = [];
    
    // Check if there's a different first page header setting
    if (headersFooters.firstPageHeader || headersFooters.firstPageFooter) {
      // This is often correct for APA (different first page for running head)
      // But check if it's properly configured
      
      const hasRunningHead = headersFooters.runningHead;
      const firstPageText = text.substring(0, 2000);
      
      if (hasRunningHead && !firstPageText.includes('Running head:')) {
        issues.push({
          title: "First page header configuration issue",
          description: "Different first page header detected but may not be properly configured",
          severity: "Minor",
          category: "headers",
          hasFix: false,
          explanation: "The title page should have 'Running head: TITLE' while other pages have just 'TITLE'."
        });
      }
    }
    
    // Check for title page elements
    const titlePageElements = this.checkTitlePageElements(text);
    if (!titlePageElements.hasAll) {
      const missing = [];
      if (!titlePageElements.hasTitle) missing.push('paper title');
      if (!titlePageElements.hasAuthor) missing.push('author name(s)');
      if (!titlePageElements.hasAffiliation) missing.push('institutional affiliation');
      
      if (missing.length > 0) {
        issues.push({
          title: "Incomplete title page",
          description: `Title page missing: ${missing.join(', ')}`,
          severity: "Major",
          category: "structure",
          hasFix: false,
          explanation: "APA title page must include: paper title, author name(s), institutional affiliation, and author note (if applicable)."
        });
      }
    }
    
    return issues;
  }

  /**
   * Check title page elements
   */
  checkTitlePageElements(text) {
    const firstPage = text.substring(0, 1500);
    const lines = firstPage.split('\n').map(l => l.trim()).filter(l => l.length > 0);
    
    // Simple heuristics for title page elements
    const hasTitle = lines.some(line => 
      line.length > 10 && 
      line.length < 100 && 
      !line.includes('Running head') &&
      line[0] === line[0].toUpperCase()
    );
    
    // Check for author names (typically after title)
    const hasAuthor = lines.some((line, i) => 
      i > 0 && // Not first line
      line.length > 3 && 
      line.length < 50 &&
      /^[A-Z][a-z]+/.test(line) && // Starts with capital letter
      !line.includes('University') &&
      !line.includes('College')
    );
    
    // Check for affiliation (university/institution name)
    const hasAffiliation = lines.some(line => 
      line.includes('University') || 
      line.includes('College') || 
      line.includes('Institute') ||
      line.includes('Department')
    );
    
    return {
      hasTitle,
      hasAuthor,
      hasAffiliation,
      hasAll: hasTitle && hasAuthor && hasAffiliation
    };
  }

  /**
   * Validate section breaks and headers consistency
   */
  validateSectionBreaks(headersFooters, text) {
    const issues = [];
    
    // Check if there are multiple header/footer definitions (indicating section breaks)
    const headerCount = headersFooters.headers?.length || 0;
    const footerCount = headersFooters.footers?.length || 0;
    
    if (headerCount > 3 || footerCount > 3) {
      // Multiple section breaks detected
      issues.push({
        title: "Multiple section breaks detected",
        description: "Document has multiple section breaks which may cause header/footer inconsistencies",
        severity: "Minor",
        category: "headers",
        hasFix: false,
        explanation: "APA format typically uses consistent headers throughout. Avoid unnecessary section breaks unless needed for landscape pages or appendices."
      });
    }
    
    // Check for consistency across headers
    if (headersFooters.headers && headersFooters.headers.length > 1) {
      const firstHeader = headersFooters.headers[0];
      const inconsistentHeaders = headersFooters.headers.filter(h => 
        h.text !== firstHeader.text && 
        !h.text.includes('Running head')
      );
      
      if (inconsistentHeaders.length > 0) {
        issues.push({
          title: "Inconsistent headers across document",
          description: "Headers vary across different sections of the document",
          severity: "Minor",
          category: "headers",
          hasFix: false,
          explanation: "Maintain consistent headers throughout the document, except for the title page which may have 'Running head:' prefix."
        });
      }
    }
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\quotationValidator.js
// src/utils/quotationValidator.js - Quotation and block quote validation
'use client';

export class QuotationValidator {
  constructor() {
    this.blockQuoteMinWords = 40;
  }

  /**
   * Validate quotation handling and formatting
   */
  validateQuotations(text, structure) {
    const issues = [];
    
    // Block quote detection and formatting
    issues.push(...this.validateBlockQuotes(text));
    
    // Ellipsis usage
    issues.push(...this.validateEllipsisUsage(text));
    
    // Square brackets for modifications
    issues.push(...this.validateSquareBrackets(text));
    
    // Quote integration
    issues.push(...this.validateQuoteIntegration(text));
    
    // Quote accuracy indicators
    issues.push(...this.validateQuoteAccuracy(text));
    
    return issues;
  }

  /**
   * Validate block quote formatting (40+ words)
   */
  validateBlockQuotes(text) {
    const issues = [];
    
    // Find all quoted text
    const quotePattern = /[""]([^""]+)[""]/g;
    const quotes = [...text.matchAll(quotePattern)];
    
    quotes.forEach(match => {
      const quoteText = match[1];
      const wordCount = quoteText.split(/\s+/).filter(w => w.length > 0).length;
      
      // Check if quote is 40+ words
      if (wordCount >= this.blockQuoteMinWords) {
        // Check if it's formatted as block quote (usually indented paragraph)
        const quotePosition = match.index;
        const beforeQuote = text.substring(Math.max(0, quotePosition - 50), quotePosition);
        const afterQuote = text.substring(quotePosition + match[0].length, Math.min(text.length, quotePosition + match[0].length + 50));
        
        // Block quotes shouldn't have quotation marks
        if (match[0].includes('"') || match[0].includes('"')) {
          issues.push({
            title: "Long quote not formatted as block quote",
            description: `Quote with ${wordCount} words should be a block quote (40+ words)`,
            text: quoteText.substring(0, 50) + '...',
            severity: "Major",
            category: "quotations",
            hasFix: true,
            fixAction: "convertToBlockQuote",
            explanation: "Quotes of 40+ words should be in block format: indented 0.5\", no quotation marks"
          });
        }
        
        // Check for citation after block quote
        if (!afterQuote.match(/^\s*\([^)]+\)/)) {
          issues.push({
            title: "Block quote missing citation",
            description: "Block quote should be followed immediately by citation",
            text: quoteText.substring(0, 30) + '...',
            severity: "Major",
            category: "quotations",
            hasFix: false,
            explanation: "Place citation after final punctuation of block quote: ...end of quote. (Author, Year, p. #)"
          });
        }
      } else if (wordCount > 30 && wordCount < this.blockQuoteMinWords) {
        // Warning for quotes approaching block quote length
        issues.push({
          title: "Long inline quote",
          description: `Quote with ${wordCount} words is long for inline format`,
          text: quoteText.substring(0, 50) + '...',
          severity: "Minor",
          category: "quotations",
          hasFix: false,
          explanation: "Consider paraphrasing or using block quote format for lengthy quotes"
        });
      }
    });
    
    // Check for improperly formatted block quotes (indented but with quotes)
    const indentedQuotes = text.match(/\n\s{4,}[""].*[""]/g) || [];
    indentedQuotes.forEach(quote => {
      issues.push({
        title: "Block quote with quotation marks",
        description: "Block quotes should not have quotation marks",
        text: quote.trim().substring(0, 50),
        severity: "Major",
        category: "quotations",
        hasFix: true,
        fixAction: "removeBlockQuoteMarks",
        explanation: "Block quotes use indentation only, no quotation marks"
      });
    });
    
    return issues;
  }

  /**
   * Validate ellipsis usage in quotes
   */
  validateEllipsisUsage(text) {
    const issues = [];
    
    // Find ellipses in quotes
    const quotesWithEllipsis = text.match(/[""][^""]*\.\.\.+[^""]*[""]/g) || [];
    
    quotesWithEllipsis.forEach(quote => {
      // Check for correct ellipsis format (three dots with spaces)
      const ellipsisVariants = quote.match(/\.\.+/g) || [];
      
      ellipsisVariants.forEach(ellipsis => {
        if (ellipsis !== '...' && ellipsis !== '. . .') {
          issues.push({
            title: "Incorrect ellipsis format",
            description: "Use three dots for ellipsis (...) or spaced (. . .)",
            text: quote.substring(quote.indexOf(ellipsis) - 10, quote.indexOf(ellipsis) + 20),
            severity: "Minor",
            category: "quotations",
            hasFix: true,
            fixAction: "fixEllipsisFormat",
            explanation: "Ellipsis should be exactly three dots, with or without spaces"
          });
        }
      });
      
      // Check for ellipsis at beginning (usually not needed)
      if (quote.match(/[""]\.\.\./) || quote.match(/[""]\s*\.\.\./)) {
        issues.push({
          title: "Ellipsis at quote beginning",
          description: "Ellipsis at start of quote usually unnecessary",
          text: quote.substring(0, 30),
          severity: "Minor",
          category: "quotations",
          hasFix: false,
          explanation: "Begin quotes at natural starting point without ellipsis unless showing continuation"
        });
      }
      
      // Check for four dots (period + ellipsis)
      if (quote.includes('....')) {
        issues.push({
          title: "Four dots in quote",
          description: "Use three dots for ellipsis, even at sentence end",
          text: quote.substring(quote.indexOf('....') - 10, quote.indexOf('....') + 20),
          severity: "Minor",
          category: "quotations",
          hasFix: true,
          fixAction: "fixFourDots",
          explanation: "APA 7th uses three dots only, not four dots for end of sentence"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate square bracket usage for modifications
   */
  validateSquareBrackets(text) {
    const issues = [];
    
    // Find square brackets in quotes
    const quotesWithBrackets = text.match(/[""][^""]*\[[^\]]*\][^""]*[""]/g) || [];
    
    quotesWithBrackets.forEach(quote => {
      const brackets = quote.match(/\[([^\]]*)\]/g) || [];
      
      brackets.forEach(bracket => {
        const content = bracket.slice(1, -1);
        
        // Check for [sic] usage
        if (content.toLowerCase() === 'sic') {
          // Check if [sic] is italicized (in some formats)
          const position = quote.indexOf(bracket);
          if (position > 0 && quote[position - 1] !== ' ') {
            issues.push({
              title: "Missing space before [sic]",
              description: "[sic] should have space before it",
              text: quote.substring(position - 10, position + 10),
              severity: "Minor",
              category: "quotations",
              hasFix: true,
              fixAction: "addSpaceBeforeSic",
              explanation: "Format: 'original text [sic]' with space before bracket"
            });
          }
        }
        
        // Check for clarifications
        else if (content.length > 20) {
          issues.push({
            title: "Long text in square brackets",
            description: "Keep bracketed clarifications brief",
            text: bracket,
            severity: "Minor",
            category: "quotations",
            hasFix: false,
            explanation: "Use square brackets sparingly for brief clarifications only"
          });
        }
        
        // Check for capital letter changes
        else if (content.length === 1 && /[A-Z]/.test(content)) {
          // This is likely a capitalization change, which is correct
          // No issue
        }
        
        // Check for ellipsis in brackets (should be without brackets)
        else if (content === '...') {
          issues.push({
            title: "Ellipsis in square brackets",
            description: "Ellipsis should not be in square brackets",
            text: bracket,
            severity: "Minor",
            category: "quotations",
            hasFix: true,
            fixAction: "removeEllipsisBrackets",
            explanation: "Use ... without brackets for omitted material"
          });
        }
      });
    });
    
    return issues;
  }

  /**
   * Validate quote integration (floating quotes, etc.)
   */
  validateQuoteIntegration(text) {
    const issues = [];
    
    // Check for floating quotes (quotes without introduction)
    const sentences = text.split(/[.!?]+/);
    
    sentences.forEach(sentence => {
      if (sentence.trim().startsWith('"') || sentence.trim().startsWith('"')) {
        // Check if previous sentence introduces the quote
        const sentenceIndex = sentences.indexOf(sentence);
        if (sentenceIndex > 0) {
          const prevSentence = sentences[sentenceIndex - 1];
          const hasIntroduction = prevSentence.includes('states') || 
                                 prevSentence.includes('argues') || 
                                 prevSentence.includes('notes') ||
                                 prevSentence.includes('writes') ||
                                 prevSentence.includes('according to') ||
                                 prevSentence.includes('said') ||
                                 prevSentence.includes('explained');
          
          if (!hasIntroduction && sentence.length > 20) {
            issues.push({
              title: "Floating quotation",
              description: "Quote appears without proper introduction",
              text: sentence.trim().substring(0, 50) + '...',
              severity: "Minor",
              category: "quotations",
              hasFix: false,
              explanation: "Introduce quotes with signal phrases: 'Smith (2023) noted that...'"
            });
          }
        }
      }
    });
    
    // Check for overuse of quotes
    const quoteCount = (text.match(/[""][^""]+[""]/g) || []).length;
    const paragraphCount = (text.match(/\n\n/g) || []).length + 1;
    const quotesPerParagraph = quoteCount / paragraphCount;
    
    if (quotesPerParagraph > 2) {
      issues.push({
        title: "Excessive use of direct quotes",
        description: `Average of ${quotesPerParagraph.toFixed(1)} quotes per paragraph`,
        text: `${quoteCount} quotes in ${paragraphCount} paragraphs`,
        severity: "Minor",
        category: "quotations",
        hasFix: false,
        explanation: "Prefer paraphrasing over direct quotes. Use quotes sparingly for impact."
      });
    }
    
    return issues;
  }

  /**
   * Validate quote accuracy indicators
   */
  validateQuoteAccuracy(text) {
    const issues = [];
    
    // Check for quotes with emphasis added
    const emphasisPattern = /[""][^""]*(?:\*[^*]+\*|_[^_]+_)[^""]*[""]/g;
    const emphasisQuotes = text.match(emphasisPattern) || [];
    
    emphasisQuotes.forEach(quote => {
      // Check if "emphasis added" is noted
      const quoteEnd = text.indexOf(quote) + quote.length;
      const afterQuote = text.substring(quoteEnd, quoteEnd + 100);
      
      if (!afterQuote.includes('emphasis added') && !afterQuote.includes('[emphasis added]')) {
        issues.push({
          title: "Emphasis without attribution",
          description: "Added emphasis in quote should be noted",
          text: quote.substring(0, 50) + '...',
          severity: "Minor",
          category: "quotations",
          hasFix: true,
          fixAction: "addEmphasisNote",
          explanation: "Note added emphasis: (Author, Year, p. #, emphasis added)"
        });
      }
    });
    
    // Check for translated quotes
    const translationIndicators = ['translated from', 'trans.', 'translation', 'my translation'];
    translationIndicators.forEach(indicator => {
      if (text.includes(indicator)) {
        const position = text.indexOf(indicator);
        const context = text.substring(Math.max(0, position - 100), position + 50);
        
        if (context.includes('"') || context.includes('"')) {
          // Found a likely translated quote
          if (!context.includes('trans.') && !context.includes('translation')) {
            issues.push({
              title: "Translation not properly noted",
              description: "Translated quotes should be clearly marked",
              text: context.substring(0, 50),
              severity: "Minor",
              category: "quotations",
              hasFix: false,
              explanation: "Note translations: (Author, Year, p. #, my translation)"
            });
          }
        }
      }
    });
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\referenceValidator.js
// src/utils/referenceValidator.js - Comprehensive reference list validation
'use client';

export class ReferenceValidator {
  constructor() {
    this.doiPattern = /(?:https?:\/\/)?(?:dx\.)?doi\.org\/(.+)|doi:\s*(.+)/i;
    this.urlPattern = /https?:\/\/[^\s)]+/g;
  }

  /**
   * Main validation function for references section with deep formatting
   */
  validateReferences(text, structure, italicizedText = []) {
    const issues = [];
    
    if (!text) return issues;
    
    // Extract references section
    const referencesMatch = text.match(/(?:^|\n)(?:references|REFERENCES|References)\s*\n([\s\S]*?)(?=\n(?:appendix|APPENDIX|Appendix)|$)/i);
    
    if (!referencesMatch) {
      // Check if there are citations that need references
      const hasCitations = /\([^)]+,\s*\d{4}\)/.test(text);
      if (hasCitations) {
        issues.push({
          title: "Missing references section",
          description: "Document contains citations but no references section",
          severity: "Critical",
          category: "references",
          hasFix: false,
          explanation: "All cited sources must be listed in the References section at the end of the document."
        });
      }
      return issues;
    }
    
    const referencesText = referencesMatch[1].trim();
    
    // Check for empty references section
    if (referencesText.length < 50 || !referencesText.match(/[A-Z]/)) {
      issues.push({
        title: "Empty references section",
        description: "References section exists but contains no entries",
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "The References section must contain full citations for all sources cited in the text."
      });
      return issues;
    }
    
    // Parse individual references
    const referenceEntries = this.parseReferenceEntries(referencesText);
    
    // Run all validation checks including deep formatting with italicized text
    issues.push(...this.checkAlphabeticalOrder(referenceEntries));
    issues.push(...this.checkHangingIndent(referenceEntries, referencesText));
    issues.push(...this.checkReferenceFormatting(referenceEntries, italicizedText));
    issues.push(...this.crossCheckCitationsAndReferences(text, referenceEntries));
    issues.push(...this.checkDuplicateReferences(referenceEntries));
    issues.push(...this.checkDOIAndURLFormatting(referenceEntries));
    
    return issues;
  }

  /**
   * Parse reference entries from text
   */
  parseReferenceEntries(referencesText) {
    const entries = [];
    const lines = referencesText.split('\n');
    let currentEntry = '';
    let entryStartLine = 0;
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const trimmedLine = line.trim();
      
      // Check if this is a new reference entry (starts with capital letter, previous entry has year)
      const isNewEntry = trimmedLine.length > 0 && 
                         /^[A-Z]/.test(trimmedLine) && 
                         currentEntry.includes('(') && 
                         currentEntry.includes(')');
      
      if (trimmedLine.length === 0 || isNewEntry) {
        if (currentEntry.trim().length > 10) {
          entries.push({
            text: currentEntry.trim(),
            firstAuthor: this.extractFirstAuthor(currentEntry),
            year: this.extractYear(currentEntry),
            hasMultipleAuthors: this.hasMultipleAuthors(currentEntry),
            type: this.detectReferenceType(currentEntry),
            lineNumber: entryStartLine,
            indentation: this.checkIndentation(currentEntry, lines.slice(entryStartLine, i))
          });
        }
        
        if (isNewEntry) {
          currentEntry = trimmedLine;
          entryStartLine = i;
        } else {
          currentEntry = '';
        }
      } else if (trimmedLine.length > 0) {
        currentEntry += (currentEntry ? ' ' : '') + trimmedLine;
      }
    }
    
    // Add last entry
    if (currentEntry.trim().length > 10) {
      entries.push({
        text: currentEntry.trim(),
        firstAuthor: this.extractFirstAuthor(currentEntry),
        year: this.extractYear(currentEntry),
        hasMultipleAuthors: this.hasMultipleAuthors(currentEntry),
        type: this.detectReferenceType(currentEntry),
        lineNumber: entryStartLine,
        indentation: this.checkIndentation(currentEntry, lines.slice(entryStartLine))
      });
    }
    
    return entries;
  }

  /**
   * Extract first author's surname from reference
   */
  extractFirstAuthor(reference) {
    // Match pattern: Surname, F. M. or Surname, First Middle
    const match = reference.match(/^([A-Z][a-zA-Z'-]+(?:\s+[A-Z][a-zA-Z'-]+)?),/);
    return match ? match[1] : '';
  }

  /**
   * Extract year from reference
   */
  extractYear(reference) {
    // Match (YYYY) or (YYYY, Month) or (n.d.)
    const match = reference.match(/\((\d{4}[a-z]?|n\.d\.)[^)]*\)/);
    return match ? match[1] : '';
  }

  /**
   * Check if reference has multiple authors
   */
  hasMultipleAuthors(reference) {
    return reference.includes('&') || reference.includes(', &') || 
           reference.split(',').length > 3;
  }

  /**
   * Detect reference type (journal, book, website, etc.)
   */
  detectReferenceType(reference) {
    if (reference.match(/\d+\(\d+\),?\s*\d+-\d+/)) return 'journal';
    if (reference.includes('http') || reference.includes('doi')) return 'online';
    if (reference.match(/\([^)]*Ed(?:s)?\.\)/)) return 'book';
    if (reference.includes('In ')) return 'chapter';
    return 'other';
  }

  /**
   * Check indentation of reference entry
   */
  checkIndentation(entry, lines) {
    if (lines.length <= 1) return 'single-line';
    
    // Check if second line has more indentation than first
    const firstLineIndent = lines[0].match(/^(\s*)/)[1].length;
    const secondLineIndent = lines[1] ? lines[1].match(/^(\s*)/)[1].length : 0;
    
    return secondLineIndent > firstLineIndent ? 'hanging' : 'no-hanging';
  }

  /**
   * Check alphabetical order
   */
  checkAlphabeticalOrder(entries) {
    const issues = [];
    if (entries.length < 2) return issues;
    
    for (let i = 1; i < entries.length; i++) {
      const current = entries[i].firstAuthor.toLowerCase();
      const previous = entries[i-1].firstAuthor.toLowerCase();
      
      if (current && previous && current < previous) {
        // Check for same author, different years
        const currentBase = current.replace(/[a-z]$/, '');
        const previousBase = previous.replace(/[a-z]$/, '');
        
        if (currentBase !== previousBase) {
          issues.push({
            title: "References not in alphabetical order",
            description: `"${entries[i].firstAuthor}" should come before "${entries[i-1].firstAuthor}"`,
            text: `${entries[i].firstAuthor} (${entries[i].year})`,
            severity: "Major",
            category: "references",
            hasFix: true,
            fixAction: "sortReferences",
            explanation: "References must be listed in alphabetical order by the first author's surname."
          });
          break; // Only report first occurrence
        }
      }
      
      // Check same author, year order
      if (current === previous && entries[i].year && entries[i-1].year) {
        const currentYear = entries[i].year;
        const previousYear = entries[i-1].year;
        
        if (currentYear < previousYear && !currentYear.includes('n.d.')) {
          issues.push({
            title: "Same author references not in chronological order",
            description: `${entries[i].firstAuthor}'s works should be ordered by year`,
            text: `${previousYear} comes before ${currentYear}`,
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "sortReferencesByYear",
            explanation: "When the same author has multiple works, order them chronologically (oldest first)."
          });
        }
      }
    }
    
    return issues;
  }

  /**
   * Check hanging indent
   */
  checkHangingIndent(entries, referencesText) {
    const issues = [];
    let noHangingCount = 0;
    
    entries.forEach((entry) => {
      if (entry.indentation === 'no-hanging' && entry.text.length > 80) {
        noHangingCount++;
      }
    });
    
    if (noHangingCount > entries.length * 0.3) { // If >30% lack hanging indent
      issues.push({
        title: "Missing hanging indent in references",
        description: "Reference entries should have 0.5\" hanging indent for lines after the first",
        text: `${noHangingCount} of ${entries.length} references lack proper indentation`,
        severity: "Minor",
        category: "references",
        hasFix: true,
        fixAction: "fixReferenceIndent",
        explanation: "Each reference entry should have a hanging indent of 0.5 inches for continuation lines."
      });
    }
    
    return issues;
  }

  /**
   * Enhanced deep reference formatting validation
   */
  checkReferenceFormatting(entries, italicizedText) {
    const issues = [];
    const reportedTypes = new Set();
    
    entries.forEach((entry, index) => {
      // Deep validation of author format
      const authorIssues = this.validateAuthorFormat(entry);
      if (authorIssues && !reportedTypes.has('author-format')) {
        issues.push(authorIssues);
        reportedTypes.add('author-format');
      }
      
      // Check for missing year
      if (!entry.year && !reportedTypes.has('year')) {
        issues.push({
          title: "Missing year in reference",
          description: "Reference entry missing publication year",
          text: entry.text.substring(0, 60) + '...',
          severity: "Major",
          category: "references",
          hasFix: false,
          explanation: "All references must include the publication year in parentheses after the author(s)."
        });
        reportedTypes.add('year');
      }
      
      // Deep validation based on reference type
      const typeSpecificIssues = this.validateReferenceByType(entry, italicizedText);
      typeSpecificIssues.forEach(issue => {
        if (!reportedTypes.has(issue.type)) {
          issues.push(issue);
          reportedTypes.add(issue.type);
        }
      });
      
      // Check for missing DOI/URL in journal articles
      if (entry.type === 'journal' && 
          !entry.text.match(/(?:https?:\/\/|doi:|DOI:)/) && 
          !reportedTypes.has('doi')) {
        issues.push({
          title: "Missing DOI or URL in journal article",
          description: "Journal articles should include DOI or stable URL",
          text: entry.text.substring(0, 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: false,
          explanation: "Include DOI (preferred) or stable URL for all journal articles when available."
        });
        reportedTypes.add('doi');
      }
      
      // Check for "and" instead of "&"
      if (entry.hasMultipleAuthors && entry.text.includes(', and ')) {
        issues.push({
          title: "Incorrect connector in reference",
          description: "Use '&' instead of 'and' between authors",
          text: entry.text.substring(0, 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixReferenceConnector",
          explanation: "In reference lists, use & (ampersand) to connect the last two author names."
        });
      }
      
      // Check for consistent punctuation
      if (!entry.text.endsWith('.') && !entry.text.match(/\)\.?$/) && !reportedTypes.has('period')) {
        issues.push({
          title: "Missing period at end of reference",
          description: "References should end with a period",
          text: entry.text.substring(entry.text.length - 30),
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "addReferencePeriod",
          explanation: "Each reference entry must end with a period."
        });
        reportedTypes.add('period');
      }
    });
    
    return issues;
  }

  /**
   * Cross-check citations with references
   */
  crossCheckCitationsAndReferences(text, referenceEntries) {
    const issues = [];
    
    // Extract all in-text citations
    const citationPattern = /\(([A-Za-z][A-Za-z\s&.,'-]+?)(?:,?\s+et\s+al\.)?(?:,\s+)?(\d{4}[a-z]?|n\.d\.)\)/g;
    const citations = new Map();
    let match;
    
    while ((match = citationPattern.exec(text)) !== null) {
      const author = match[1].trim().replace(/,$/, '').split(/\s+&\s+|\s+and\s+/)[0];
      const year = match[2];
      const key = `${author.toLowerCase()}_${year}`;
      
      if (!citations.has(key)) {
        citations.set(key, { author, year, full: match[0], count: 1 });
      } else {
        citations.get(key).count++;
      }
    }
    
    // Create reference map
    const references = new Map();
    referenceEntries.forEach(ref => {
      if (ref.firstAuthor && ref.year) {
        const key = `${ref.firstAuthor.toLowerCase()}_${ref.year}`;
        references.set(key, ref);
      }
    });
    
    // Find citations without references
    const missingRefs = [];
    citations.forEach((citation, key) => {
      // Try exact match first
      if (!references.has(key)) {
        // Try fuzzy match (first 3 letters)
        const authorStart = citation.author.toLowerCase().substring(0, 3);
        const found = Array.from(references.keys()).some(refKey => 
          refKey.startsWith(authorStart) && refKey.includes(citation.year)
        );
        
        if (!found) {
          missingRefs.push(citation);
        }
      }
    });
    
    // Report missing references (max 3)
    missingRefs.slice(0, 3).forEach(citation => {
      issues.push({
        title: "Citation without reference",
        description: `Citation "${citation.full}" not found in references`,
        text: citation.full,
        severity: "Critical",
        category: "references",
        hasFix: false,
        explanation: "Every in-text citation must have a corresponding entry in the References section."
      });
    });
    
    // Find orphaned references
    const orphanedRefs = [];
    references.forEach((ref, key) => {
      const authorPart = key.split('_')[0];
      const yearPart = key.split('_')[1];
      
      // Check if this reference is cited
      const found = Array.from(citations.keys()).some(citKey => {
        const citAuthor = citKey.split('_')[0];
        const citYear = citKey.split('_')[1];
        return citAuthor.startsWith(authorPart.substring(0, 3)) && citYear === yearPart;
      });
      
      if (!found) {
        orphanedRefs.push(ref);
      }
    });
    
    // Report orphaned references (max 3)
    orphanedRefs.slice(0, 3).forEach(ref => {
      issues.push({
        title: "Orphaned reference",
        description: `Reference for ${ref.firstAuthor} (${ref.year}) not cited in text`,
        text: ref.text.substring(0, 60) + '...',
        severity: "Major",
        category: "references",
        hasFix: false,
        explanation: "Only include references that are cited in the document text."
      });
    });
    
    return issues;
  }

  /**
   * Check for duplicate references
   */
  checkDuplicateReferences(entries) {
    const issues = [];
    const seen = new Map();
    
    entries.forEach(entry => {
      const key = `${entry.firstAuthor}_${entry.year}`.toLowerCase();
      
      if (key && entry.firstAuthor && entry.year) {
        if (seen.has(key)) {
          const existing = seen.get(key);
          
          // Check if texts are actually different (not just formatting)
          const normalizedCurrent = entry.text.replace(/\s+/g, ' ').toLowerCase();
          const normalizedExisting = existing.text.replace(/\s+/g, ' ').toLowerCase();
          
          if (normalizedCurrent !== normalizedExisting) {
            issues.push({
              title: "Possible duplicate reference",
              description: `Multiple references for ${entry.firstAuthor} (${entry.year})`,
              text: entry.text.substring(0, 60) + '...',
              severity: "Major",
              category: "references",
              hasFix: false,
              explanation: "Each source should appear only once. Use 'a', 'b' suffixes for multiple works by same author in same year."
            });
          }
        } else {
          seen.set(key, entry);
        }
      }
    });
    
    return issues;
  }

  /**
   * Validate author format in references
   */
  validateAuthorFormat(entry) {
    const text = entry.text;
    
    // Check for proper author format: Lastname, F. M.
    const authorPattern = /^([A-Z][a-zA-Z'-]+),\s+([A-Z]\.(?:\s*[A-Z]\.)*)/;
    
    if (!authorPattern.test(text)) {
      // Check for common formatting errors
      
      // Missing initials
      if (/^[A-Z][a-zA-Z'-]+,\s+[A-Z][a-z]+/.test(text)) {
        return {
          title: "Full first names instead of initials",
          description: "Use initials instead of full first names in references",
          text: text.substring(0, 50) + '...',
          severity: "Major",
          category: "references",
          hasFix: false,
          type: 'author-format',
          explanation: "Author names should use initials: Smith, J. D., not Smith, John David."
        };
      }
      
      // Missing comma after surname
      if (/^[A-Z][a-zA-Z'-]+\s+[A-Z]\./.test(text)) {
        return {
          title: "Missing comma after author surname",
          description: "Author surname should be followed by a comma",
          text: text.substring(0, 50) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixAuthorComma",
          type: 'author-format',
          explanation: "Format: Lastname, F. M., not Lastname F. M."
        };
      }
      
      // Missing periods after initials
      if (/^[A-Z][a-zA-Z'-]+,\s+[A-Z]\s+[A-Z]/.test(text)) {
        return {
          title: "Missing periods after author initials",
          description: "Each initial should be followed by a period",
          text: text.substring(0, 50) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "fixAuthorInitials",
          type: 'author-format',
          explanation: "Format: Smith, J. D., not Smith, J D"
        };
      }
    }
    
    // Check for up to 20 authors rule (APA 7th)
    const authorCount = (text.match(/[A-Z][a-zA-Z'-]+,\s+[A-Z]\./g) || []).length;
    if (authorCount > 20) {
      return {
        title: "Too many authors listed",
        description: "List first 19 authors, then ... and the last author",
        text: text.substring(0, 50) + '...',
        severity: "Minor",
        category: "references",
        hasFix: false,
        type: 'author-format',
        explanation: "For 21+ authors: list first 19, then ellipsis (...), then final author."
      };
    }
    
    return null;
  }
  
  /**
   * Validate reference by type with deep formatting checks
   */
  validateReferenceByType(entry, italicizedText = []) {
    const issues = [];
    const text = entry.text;
    
    if (entry.type === 'journal') {
      // Journal article specific validation
      
      // Check for journal name italicization
      const journalMatch = text.match(/\)\.\s+([^,]+),\s*\d+/);
      if (journalMatch) {
        const journalName = journalMatch[1];
        const isItalicized = italicizedText?.some(item => 
          item.text.includes(journalName) || journalName.includes(item.text)
        );
        
        if (!isItalicized && journalName.length > 3) {
          issues.push({
            title: "Journal name not italicized",
            description: "Journal names must be italicized in references",
            text: journalName,
            severity: "Major",
            category: "references",
            hasFix: false,
            type: 'journal-italics',
            explanation: "Journal titles should be in italics: Journal of Psychology, not Journal of Psychology"
          });
        }
      }
      
      // Check for volume number italicization
      const volumeMatch = text.match(/,\s*(\d+)(?:\(|,)/);
      if (volumeMatch) {
        const volume = volumeMatch[1];
        const volumeContext = text.substring(
          text.indexOf(volume) - 10, 
          text.indexOf(volume) + volume.length + 10
        );
        
        const volumeItalicized = italicizedText?.some(item => 
          item.text.includes(volume) && item.context?.includes(journalMatch?.[1])
        );
        
        if (!volumeItalicized) {
          issues.push({
            title: "Volume number not italicized",
            description: "Journal volume numbers should be italicized",
            text: volumeContext,
            severity: "Minor",
            category: "references",
            hasFix: false,
            type: 'volume-italics',
            explanation: "Volume numbers should be italicized: Psychology Today, 45(3), not Psychology Today, 45(3)"
          });
        }
      }
      
      // Check for issue number format
      const issueMatch = text.match(/\d+\((\d+)\)/);
      if (issueMatch) {
        const issueContext = text.substring(
          text.indexOf(issueMatch[0]) - 5,
          text.indexOf(issueMatch[0]) + issueMatch[0].length + 5
        );
        
        // Issue number should NOT be italicized
        const issueItalicized = italicizedText?.some(item => 
          item.text.includes(`(${issueMatch[1]})`)
        );
        
        if (issueItalicized) {
          issues.push({
            title: "Issue number incorrectly italicized",
            description: "Issue numbers in parentheses should not be italicized",
            text: issueContext,
            severity: "Minor",
            category: "references",
            hasFix: false,
            type: 'issue-italics',
            explanation: "Only volume is italicized, not issue: 45(3), where 45 is italic but (3) is not"
          });
        }
      }
      
      // Check page range format
      const pageMatch = text.match(/,\s*(\d+)[‚Äì-](\d+)/);
      if (pageMatch) {
        // Check for en dash vs hyphen
        if (text.includes(`${pageMatch[1]}-${pageMatch[2]}`)) {
          issues.push({
            title: "Hyphen instead of en dash in page range",
            description: "Use en dash (‚Äì) not hyphen (-) for page ranges",
            text: `${pageMatch[1]}-${pageMatch[2]}`,
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "fixPageRangeDash",
            type: 'page-dash',
            explanation: "Page ranges use en dash: 123‚Äì456, not 123-456"
          });
        }
      }
      
    } else if (entry.type === 'book') {
      // Book specific validation
      
      // Check for book title italicization
      const titleMatch = text.match(/\)\.\s+([^.]+)\./);
      if (titleMatch) {
        const bookTitle = titleMatch[1];
        const isItalicized = italicizedText?.some(item => 
          item.text.includes(bookTitle) || bookTitle.includes(item.text)
        );
        
        if (!isItalicized && bookTitle.length > 3) {
          issues.push({
            title: "Book title not italicized",
            description: "Book titles must be italicized in references",
            text: bookTitle.substring(0, 50),
            severity: "Major",
            category: "references",
            hasFix: false,
            type: 'book-italics',
            explanation: "Book titles should be in italics throughout the reference"
          });
        }
        
        // Check for sentence case in book titles
        const words = bookTitle.split(/\s+/);
        const hasExcessiveCapitals = words.filter(w => 
          w.length > 3 && w[0] === w[0].toUpperCase()
        ).length > words.length * 0.5;
        
        if (hasExcessiveCapitals) {
          issues.push({
            title: "Book title not in sentence case",
            description: "Book titles should use sentence case, not title case",
            text: bookTitle.substring(0, 50),
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "fixBookTitleCase",
            type: 'book-case',
            explanation: "Book titles use sentence case: 'The psychology of learning' not 'The Psychology of Learning'"
          });
        }
      }
      
      // Check for edition format
      const editionMatch = text.match(/\((\d+)(?:st|nd|rd|th)\s+[Ee]d(?:ition)?\)/);
      if (editionMatch) {
        if (!text.includes(`(${editionMatch[1]}th ed.)`) && 
            !text.includes(`(${editionMatch[1]}nd ed.)`) &&
            !text.includes(`(${editionMatch[1]}rd ed.)`) &&
            !text.includes(`(${editionMatch[1]}st ed.)`)) {
          issues.push({
            title: "Incorrect edition format",
            description: "Edition should be formatted as '(2nd ed.)'",
            text: editionMatch[0],
            severity: "Minor",
            category: "references",
            hasFix: true,
            fixAction: "fixEditionFormat",
            type: 'edition-format',
            explanation: "Format editions as: (2nd ed.), (3rd ed.), etc."
          });
        }
      }
      
      // Check for publisher location (not needed in APA 7th)
      if (text.match(/[A-Z][a-z]+,\s+[A-Z]{2}:\s+[A-Z]/) || 
          text.includes('New York:') || 
          text.includes('London:')) {
        issues.push({
          title: "Publisher location included",
          description: "APA 7th edition no longer requires publisher location",
          text: text.substring(0, 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "removePublisherLocation",
          type: 'publisher-location',
          explanation: "APA 7th edition omits publisher location. Use just publisher name."
        });
      }
    }
    
    return issues;
  }

  /**
   * Check DOI and URL formatting
   */
  checkDOIAndURLFormatting(entries) {
    const issues = [];
    const reportedTypes = new Set();
    
    entries.forEach(entry => {
      // Check for "Retrieved from" (outdated in APA 7)
      if (entry.text.includes('Retrieved from') && !reportedTypes.has('retrieved')) {
        issues.push({
          title: "Outdated 'Retrieved from' phrase",
          description: "APA 7th edition no longer uses 'Retrieved from' before URLs",
          text: entry.text.substring(entry.text.indexOf('Retrieved'), 60) + '...',
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "removeRetrievedFrom",
          explanation: "APA 7th edition omits 'Retrieved from' before URLs unless a retrieval date is needed."
        });
        reportedTypes.add('retrieved');
      }
      
      // Check DOI format
      const doiMatch = entry.text.match(this.doiPattern);
      if (doiMatch && !entry.text.includes('https://doi.org/') && !reportedTypes.has('doi-format')) {
        issues.push({
          title: "Incorrect DOI format",
          description: "DOIs should be formatted as hyperlinks",
          text: doiMatch[0],
          severity: "Minor",
          category: "references",
          hasFix: true,
          fixAction: "formatDOI",
          explanation: "Format DOIs as hyperlinks: https://doi.org/xxxxx"
        });
        reportedTypes.add('doi-format');
      }
    });
    
    return issues;
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\statisticalValidator.js
// src/utils/statisticalValidator.js - Statistical and numerical formatting validation
'use client';

export class StatisticalValidator {
  constructor() {
    this.statisticalSymbols = {
      p: 'probability',
      t: 't test',
      F: 'F test',
      r: 'correlation',
      R: 'multiple correlation',
      n: 'sample size',
      N: 'total sample',
      M: 'mean',
      SD: 'standard deviation',
      SE: 'standard error',
      df: 'degrees of freedom',
      œá2: 'chi-square',
      Œ±: 'alpha',
      Œ≤: 'beta',
      Œ∑: 'eta',
      œâ: 'omega'
    };
  }

  /**
   * Validate statistical and numerical formatting
   */
  validateStatistical(text, structure) {
    const issues = [];
    
    // Statistical notation italicization
    issues.push(...this.validateStatisticalItalics(text, structure));
    
    // Decimal places consistency
    issues.push(...this.validateDecimalPlaces(text));
    
    // Number presentation rules
    issues.push(...this.validateNumberPresentation(text));
    
    // Percentage formatting
    issues.push(...this.validatePercentageFormat(text));
    
    // Statistical results reporting
    issues.push(...this.validateStatisticalReporting(text));
    
    // Mathematical operators spacing
    issues.push(...this.validateMathOperators(text));
    
    return issues;
  }

  /**
   * Validate statistical notation italicization
   */
  validateStatisticalItalics(text, structure) {
    const issues = [];
    const italicizedText = structure?.italicizedText || [];
    
    // Check for statistical symbols that should be italicized
    Object.entries(this.statisticalSymbols).forEach(([symbol, name]) => {
      // Skip uppercase letters that might be regular text
      if (symbol.length === 1 && /[A-Z]/.test(symbol)) {
        // Look for statistical context
        const statPattern = new RegExp(`\\b${symbol}\\s*[=<>]\\s*[\\d.-]+`, 'g');
        const matches = text.match(statPattern) || [];
        
        matches.forEach(match => {
          const isItalicized = italicizedText.some(item => item.text.includes(symbol));
          if (!isItalicized) {
            issues.push({
              title: `Statistical symbol '${symbol}' not italicized`,
              description: `'${symbol}' should be italicized when used as ${name}`,
              text: match,
              severity: "Minor",
              category: "statistical",
              hasFix: false,
              explanation: `Statistical symbols like ${symbol} must be italicized: *${symbol}* = value`
            });
          }
        });
      } else {
        // For lowercase letters and multi-character symbols
        const pattern = new RegExp(`\\b${symbol}\\b`, 'g');
        const matches = text.match(pattern) || [];
        
        matches.forEach(match => {
          const position = text.indexOf(match);
          const context = text.substring(Math.max(0, position - 20), position + 30);
          
          // Check if in statistical context
          if (context.match(/[=<>]/) || context.match(/\d/)) {
            const isItalicized = italicizedText.some(item => item.text.includes(symbol));
            if (!isItalicized) {
              issues.push({
                title: `Statistical symbol '${symbol}' not italicized`,
                description: `'${symbol}' should be italicized in statistical context`,
                text: context,
                severity: "Minor",
                category: "statistical",
                hasFix: false,
                explanation: `Italicize statistical notation: *${symbol}*`
              });
              return; // Only report once per symbol
            }
          }
        });
      }
    });
    
    return issues.slice(0, 5); // Limit to avoid overwhelming
  }

  /**
   * Validate decimal places consistency
   */
  validateDecimalPlaces(text) {
    const issues = [];
    
    // Find all decimal numbers
    const decimalPattern = /\b\d+\.\d+\b/g;
    const decimals = text.match(decimalPattern) || [];
    
    // Group by context (p-values, correlations, means, etc.)
    const pValues = decimals.filter(d => {
      const pos = text.indexOf(d);
      return text.substring(Math.max(0, pos - 10), pos).includes('p');
    });
    
    const correlations = decimals.filter(d => {
      const pos = text.indexOf(d);
      const context = text.substring(Math.max(0, pos - 10), pos);
      return context.includes('r') || context.includes('R');
    });
    
    // Check p-value formatting
    pValues.forEach(pValue => {
      const value = parseFloat(pValue);
      const decimalPlaces = pValue.split('.')[1].length;
      
      // p-values should have 2-3 decimal places
      if (decimalPlaces > 3 || decimalPlaces < 2) {
        issues.push({
          title: "Inconsistent p-value decimal places",
          description: `p-value '${pValue}' should have 2-3 decimal places`,
          text: `p = ${pValue}`,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "fixPValueDecimals",
          explanation: "Report p-values to 2-3 decimal places: p = .045 or p = .001"
        });
      }
      
      // Check for leading zero
      if (value < 1 && pValue.startsWith('0.')) {
        issues.push({
          title: "Leading zero in p-value",
          description: "Omit leading zero for values that cannot exceed 1",
          text: `p = ${pValue}`,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "removeLeadingZero",
          explanation: "Use p = .05 not p = 0.05"
        });
      }
    });
    
    // Check correlation formatting
    correlations.forEach(correlation => {
      const value = parseFloat(correlation);
      
      if (Math.abs(value) <= 1 && correlation.startsWith('0.')) {
        issues.push({
          title: "Leading zero in correlation",
          description: "Omit leading zero for correlations",
          text: `r = ${correlation}`,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "removeLeadingZero",
          explanation: "Use r = .45 not r = 0.45"
        });
      }
    });
    
    return issues.slice(0, 5); // Limit to avoid overwhelming
  }

  /**
   * Validate number presentation rules (spell out below 10)
   */
  validateNumberPresentation(text) {
    const issues = [];
    
    // Find numbers at beginning of sentences
    const sentenceStartNumbers = text.match(/(?:^|\. )\d+/g) || [];
    sentenceStartNumbers.forEach(match => {
      const number = match.replace(/[^0-9]/g, '');
      issues.push({
        title: "Number at sentence beginning",
        description: "Spell out numbers that begin sentences",
        text: match + '...',
        severity: "Major",
        category: "statistical",
        hasFix: false,
        explanation: `Write "Twenty-three participants..." not "${number} participants..."`
      });
    });
    
    // Find single digit numbers (1-9) that should be spelled out
    const singleDigits = text.match(/\b[1-9]\b/g) || [];
    const reportedSingleDigit = false;
    
    singleDigits.forEach(digit => {
      if (reportedSingleDigit) return;
      
      const position = text.indexOf(digit);
      const context = text.substring(Math.max(0, position - 30), position + 30);
      
      // Check if it's in a measurement, age, time, etc. (where digits are OK)
      const isException = context.match(/\d+\s*(years?|months?|days?|hours?|minutes?|%)/) ||
                         context.match(/[Ff]igure\s+\d/) ||
                         context.match(/[Tt]able\s+\d/) ||
                         context.match(/[Pp]age\s+\d/) ||
                         context.match(/[Cc]hapter\s+\d/) ||
                         context.match(/\d+:\d+/) || // Time
                         context.match(/\$\d+/) || // Money
                         context.match(/\d+\.\d+/); // Decimal
      
      if (!isException) {
        issues.push({
          title: "Single digit not spelled out",
          description: `Number ${digit} should be spelled out (under 10)`,
          text: context,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "spellOutNumber",
          explanation: "Spell out numbers below 10: one, two, three... nine"
        });
      }
    });
    
    // Check for inconsistent number format in comparisons
    const comparisons = text.match(/\b\d+\s*(?:to|and|-)\s*\d+\b/g) || [];
    comparisons.forEach(comparison => {
      const numbers = comparison.match(/\d+/g);
      if (numbers && numbers.length === 2) {
        const first = parseInt(numbers[0]);
        const second = parseInt(numbers[1]);
        
        if ((first < 10 && second >= 10) || (first >= 10 && second < 10)) {
          issues.push({
            title: "Inconsistent number format in range",
            description: "Use consistent format for number ranges",
            text: comparison,
            severity: "Minor",
            category: "statistical",
            hasFix: false,
            explanation: "Be consistent: 'five to nine' or '5 to 15', not 'five to 15'"
          });
        }
      }
    });
    
    return issues.slice(0, 5);
  }

  /**
   * Validate percentage formatting
   */
  validatePercentageFormat(text) {
    const issues = [];
    
    // Find percentages
    const percentPattern = /\d+\.?\d*\s*(?:%|percent|per cent)/gi;
    const percentages = text.match(percentPattern) || [];
    
    percentages.forEach(percentage => {
      // Check for space before %
      if (percentage.includes(' %')) {
        issues.push({
          title: "Space before percent symbol",
          description: "No space between number and % symbol",
          text: percentage,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "removePercentSpace",
          explanation: "Use 75% not 75 %"
        });
      }
      
      // Check for 'percent' vs '%'
      if (percentage.includes('percent') || percentage.includes('per cent')) {
        const position = text.indexOf(percentage);
        const isStartOfSentence = position === 0 || text[position - 2] === '.';
        
        if (!isStartOfSentence) {
          issues.push({
            title: "Word 'percent' instead of symbol",
            description: "Use % symbol except at sentence beginning",
            text: percentage,
            severity: "Minor",
            category: "statistical",
            hasFix: true,
            fixAction: "usePercentSymbol",
            explanation: "Use % symbol: 25% not 25 percent"
          });
        }
      }
      
      // Check for percentages over 100 (unless clearly intentional)
      const value = parseFloat(percentage);
      if (value > 100 && value < 1000) {
        const position = text.indexOf(percentage);
        const context = text.substring(Math.max(0, position - 50), position + 50);
        
        if (!context.includes('increase') && !context.includes('growth')) {
          issues.push({
            title: "Percentage over 100%",
            description: "Verify percentage value exceeding 100%",
            text: percentage,
            severity: "Minor",
            category: "statistical",
            hasFix: false,
            explanation: "Double-check percentages over 100% for accuracy"
          });
        }
      }
    });
    
    return issues.slice(0, 3);
  }

  /**
   * Validate statistical results reporting format
   */
  validateStatisticalReporting(text) {
    const issues = [];
    
    // Check t-test reporting format
    const tTestPattern = /t\s*\([^)]+\)\s*=\s*[^,\s]+/gi;
    const tTests = text.match(tTestPattern) || [];
    
    tTests.forEach(tTest => {
      // Should include df in parentheses
      if (!tTest.match(/t\s*\(\d+(?:\.\d+)?\)/)) {
        issues.push({
          title: "t-test missing degrees of freedom",
          description: "t-test should include df: t(df) = value",
          text: tTest,
          severity: "Major",
          category: "statistical",
          hasFix: false,
          explanation: "Format: t(45) = 2.31, p = .025"
        });
      }
    });
    
    // Check F-test reporting format
    const fTestPattern = /F\s*\([^)]+\)\s*=\s*[^,\s]+/gi;
    const fTests = text.match(fTestPattern) || [];
    
    fTests.forEach(fTest => {
      // Should include two df values
      if (!fTest.match(/F\s*\(\d+,\s*\d+\)/)) {
        issues.push({
          title: "F-test incorrect df format",
          description: "F-test needs two df values: F(df1, df2)",
          text: fTest,
          severity: "Major",
          category: "statistical",
          hasFix: false,
          explanation: "Format: F(2, 147) = 5.67, p = .004"
        });
      }
    });
    
    // Check chi-square reporting
    const chiSquarePattern = /(?:œá2|chi-square|Chi-square)\s*\([^)]+\)/gi;
    const chiSquares = text.match(chiSquarePattern) || [];
    
    chiSquares.forEach(chiSquare => {
      if (!chiSquare.includes('œá¬≤') && !chiSquare.includes('œá2')) {
        issues.push({
          title: "Chi-square symbol format",
          description: "Use œá¬≤ symbol for chi-square",
          text: chiSquare,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "fixChiSquareSymbol",
          explanation: "Use œá¬≤(df) = value, not 'chi-square'"
        });
      }
    });
    
    // Check for p < .001 format
    const pValuePattern = /p\s*[<>=]\s*\.?\d+/gi;
    const pValues = text.match(pValuePattern) || [];
    
    pValues.forEach(pValue => {
      if (pValue.includes('0.000') || pValue.includes('.000')) {
        issues.push({
          title: "p-value reported as .000",
          description: "Report as p < .001 instead of p = .000",
          text: pValue,
          severity: "Major",
          category: "statistical",
          hasFix: true,
          fixAction: "fixPValueZero",
          explanation: "Never report p = .000, use p < .001"
        });
      }
      
      if (pValue.includes('=') && pValue.includes('.05')) {
        issues.push({
          title: "Exact p = .05",
          description: "Avoid reporting exactly p = .05",
          text: pValue,
          severity: "Minor",
          category: "statistical",
          hasFix: false,
          explanation: "Report actual p-value (e.g., p = .049 or p = .051)"
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate mathematical operators spacing
   */
  validateMathOperators(text) {
    const issues = [];
    
    // Check for spaces around operators
    const operators = ['=', '<', '>', '‚â§', '‚â•', '¬±', '√ó'];
    
    operators.forEach(op => {
      // Find operator without proper spacing
      const noSpaceBefore = new RegExp(`\\S${op}`, 'g');
      const noSpaceAfter = new RegExp(`${op}\\S`, 'g');
      
      const matchesBefore = text.match(noSpaceBefore) || [];
      const matchesAfter = text.match(noSpaceAfter) || [];
      
      if (matchesBefore.length > 0 || matchesAfter.length > 0) {
        const example = matchesBefore[0] || matchesAfter[0];
        issues.push({
          title: "Missing spaces around operator",
          description: `Add spaces around '${op}' operator`,
          text: example,
          severity: "Minor",
          category: "statistical",
          hasFix: true,
          fixAction: "addOperatorSpaces",
          explanation: `Use spaces: n ${op} 50, not n${op}50`
        });
      }
    });
    
    // Check for minus sign vs hyphen
    const minusPattern = /\b\d+\s*-\s*\d+\b/g;
    const minusMatches = text.match(minusPattern) || [];
    
    minusMatches.forEach(match => {
      const position = text.indexOf(match);
      const context = text.substring(Math.max(0, position - 10), position + match.length + 10);
      
      // Check if it's a range (should use en dash) or subtraction
      if (!context.includes('minus') && !context.includes('negative')) {
        // Likely a range, covered elsewhere
      } else {
        // Subtraction should have spaces
        if (!match.includes(' - ')) {
          issues.push({
            title: "Missing spaces around minus sign",
            description: "Add spaces around minus operator",
            text: match,
            severity: "Minor",
            category: "statistical",
            hasFix: true,
            fixAction: "addMinusSpaces",
            explanation: "Use: 10 - 5 = 5, not 10-5=5"
          });
        }
      }
    });
    
    return issues.slice(0, 3);
  }
}

// File: c:\Users\Taimoor\Documents\GitHub\apa-document-checker\src\utils\tableFigureValidator.js
// src/utils/tableFigureValidator.js - Table and Figure APA compliance validation
'use client';

export class TableFigureValidator {
  constructor() {
    this.tablePattern = /(?:Table|TABLE)\s+(\d+\.?\d*)/gi;
    this.figurePattern = /(?:Figure|FIGURE|Fig\.|FIG\.)\s+(\d+\.?\d*)/gi;
    this.tableTitlePattern = /(?:Table|TABLE)\s+\d+\.?\d*\s*\n\s*([^\n]+)/gi;
    this.figureTitlePattern = /(?:Figure|FIGURE|Fig\.|FIG\.)\s+\d+\.?\d*\s*\n\s*([^\n]+)/gi;
  }

  /**
   * Main validation function for tables and figures
   */
  validateTablesAndFigures(text, structure, formatting) {
    const issues = [];
    
    if (!text) return issues;
    
    // Extract tables and figures
    const tables = this.extractTables(text, structure);
    const figures = this.extractFigures(text, structure);
    
    // Validate tables
    issues.push(...this.validateTables(tables, text));
    
    // Validate figures  
    issues.push(...this.validateFigures(figures, text));
    
    // Check in-text callouts
    issues.push(...this.validateCallouts(tables, figures, text));
    
    // Check for table/figure formatting in document structure
    if (formatting?.tables || formatting?.figures) {
      issues.push(...this.validateFormattingCompliance(formatting));
    }
    
    return issues;
  }

  /**
   * Extract tables from document
   */
  extractTables(text, structure) {
    const tables = [];
    const tableMatches = [...text.matchAll(this.tablePattern)];
    
    tableMatches.forEach((match, index) => {
      const number = match[1];
      const position = match.index;
      
      // Extract title
      const titleMatch = text.substring(position, position + 200).match(/Table\s+\d+\.?\d*\s*\n\s*([^\n]+)/i);
      const title = titleMatch ? titleMatch[1].trim() : '';
      
      // Extract note if present
      const noteMatch = text.substring(position, position + 500).match(/Note[.:]\s*([^\n]+)/i);
      const note = noteMatch ? noteMatch[1].trim() : '';
      
      tables.push({
        number: parseFloat(number),
        numberText: number,
        title: title,
        note: note,
        position: position,
        fullMatch: match[0],
        hasTitle: title.length > 0,
        hasNote: note.length > 0,
        titleCase: this.checkTitleCase(title),
        location: this.getLocationContext(text, position)
      });
    });
    
    return tables;
  }

  /**
   * Extract figures from document
   */
  extractFigures(text, structure) {
    const figures = [];
    const figureMatches = [...text.matchAll(this.figurePattern)];
    
    figureMatches.forEach((match, index) => {
      const number = match[1];
      const position = match.index;
      
      // Extract caption
      const captionMatch = text.substring(position, position + 200).match(/(?:Figure|Fig\.)\s+\d+\.?\d*\s*\.?\s*([^\n]+)/i);
      const caption = captionMatch ? captionMatch[1].trim() : '';
      
      // Extract note if present
      const noteMatch = text.substring(position, position + 500).match(/Note[.:]\s*([^\n]+)/i);
      const note = noteMatch ? noteMatch[1].trim() : '';
      
      figures.push({
        number: parseFloat(number),
        numberText: number,
        caption: caption,
        note: note,
        position: position,
        fullMatch: match[0],
        hasCaption: caption.length > 0,
        hasNote: note.length > 0,
        captionCase: this.checkSentenceCase(caption),
        location: this.getLocationContext(text, position)
      });
    });
    
    return figures;
  }

  /**
   * Get location context for table/figure
   */
  getLocationContext(text, position) {
    const before = text.substring(Math.max(0, position - 100), position);
    const after = text.substring(position, Math.min(text.length, position + 100));
    
    // Check if it's in references section
    const inReferences = before.toLowerCase().includes('references') || 
                        text.substring(Math.max(0, position - 500), position).toLowerCase().includes('references');
    
    // Check if it's in appendix
    const inAppendix = before.toLowerCase().includes('appendix') ||
                      text.substring(Math.max(0, position - 500), position).toLowerCase().includes('appendix');
    
    return {
      inReferences,
      inAppendix,
      contextBefore: before.substring(before.length - 50),
      contextAfter: after.substring(0, 50)
    };
  }

  /**
   * Check if text is in title case
   */
  checkTitleCase(text) {
    if (!text) return false;
    
    const words = text.split(/\s+/);
    const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 
                       'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet', 'with'];
    
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const isSmallWord = smallWords.includes(word.toLowerCase());
      const isFirstOrLast = i === 0 || i === words.length - 1;
      
      // First and last words should be capitalized
      if (isFirstOrLast && word[0] !== word[0].toUpperCase()) {
        return false;
      }
      
      // Small words in middle should be lowercase
      if (!isFirstOrLast && isSmallWord && word[0] === word[0].toUpperCase()) {
        return false;
      }
      
      // Other words should be capitalized
      if (!isFirstOrLast && !isSmallWord && word[0] !== word[0].toUpperCase()) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * Check if text is in sentence case
   */
  checkSentenceCase(text) {
    if (!text) return false;
    
    // First letter should be capital
    if (text[0] !== text[0].toUpperCase()) return false;
    
    // Check for proper nouns and acronyms (allow those to be capitalized)
    const words = text.split(/\s+/);
    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      
      // Skip acronyms (all caps)
      if (word === word.toUpperCase() && word.length > 1) continue;
      
      // Skip words after colons
      if (i > 0 && words[i-1].endsWith(':')) continue;
      
      // Regular words should be lowercase
      if (word[0] === word[0].toUpperCase() && word !== word.toUpperCase()) {
        // Could be a proper noun, but flag if too many
        const capsCount = words.filter(w => w[0] === w[0].toUpperCase()).length;
        if (capsCount > words.length * 0.3) return false;
      }
    }
    
    return true;
  }

  /**
   * Validate tables
   */
  validateTables(tables, text) {
    const issues = [];
    
    // Check numbering sequence
    const numberingIssues = this.checkNumberingSequence(tables, 'Table');
    issues.push(...numberingIssues);
    
    tables.forEach((table, index) => {
      // Check for missing title
      if (!table.hasTitle || table.title.length < 5) {
        issues.push({
          title: "Missing or incomplete table title",
          description: `Table ${table.numberText} lacks a descriptive title`,
          text: table.fullMatch,
          severity: "Major",
          category: "tables",
          hasFix: false,
          explanation: "Every table must have a brief, descriptive title in title case placed above the table."
        });
      } else if (!table.titleCase) {
        // Check title case
        issues.push({
          title: "Incorrect table title capitalization",
          description: `Table ${table.numberText} title should use title case`,
          text: table.title,
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "fixTableTitleCase",
          explanation: "Table titles should use title case capitalization (major words capitalized)."
        });
      }
      
      // Check table placement
      if (table.location.inReferences) {
        issues.push({
          title: "Table in references section",
          description: `Table ${table.numberText} appears in the References section`,
          text: table.fullMatch,
          severity: "Major",
          category: "tables",
          hasFix: false,
          explanation: "Tables should appear in the main text or appendices, not in the References section."
        });
      }
      
      // Check for table note formatting
      if (table.hasNote && !table.note.startsWith('Note.')) {
        issues.push({
          title: "Incorrect table note format",
          description: `Table ${table.numberText} note should start with 'Note.' in italics`,
          text: table.note.substring(0, 50),
          severity: "Minor",
          category: "tables",
          hasFix: true,
          fixAction: "fixTableNoteFormat",
          explanation: "Table notes should begin with 'Note.' in italics, followed by the note text."
        });
      }
    });
    
    return issues;
  }

  /**
   * Validate figures
   */
  validateFigures(figures, text) {
    const issues = [];
    
    // Check numbering sequence
    const numberingIssues = this.checkNumberingSequence(figures, 'Figure');
    issues.push(...numberingIssues);
    
    figures.forEach((figure, index) => {
      // Check for missing caption
      if (!figure.hasCaption || figure.caption.length < 5) {
        issues.push({
          title: "Missing or incomplete figure caption",
          description: `Figure ${figure.numberText} lacks a descriptive caption`,
          text: figure.fullMatch,
          severity: "Major",
          category: "figures",
          hasFix: false,
          explanation: "Every figure must have a brief, descriptive caption in sentence case placed below the figure."
        });
      } else if (!figure.captionCase) {
        // Check sentence case
        issues.push({
          title: "Incorrect figure caption capitalization",
          description: `Figure ${figure.numberText} caption should use sentence case`,
          text: figure.caption,
          severity: "Minor",
          category: "figures",
          hasFix: true,
          fixAction: "fixFigureCaptionCase",
          explanation: "Figure captions should use sentence case (only first word and proper nouns capitalized)."
        });
      }
      
      // Check figure placement
      if (figure.location.inReferences) {
        issues.push({
          title: "Figure in references section",
          description: `Figure ${figure.numberText} appears in the References section`,
          text: figure.fullMatch,
          severity: "Major",
          category: "figures",
          hasFix: false,
          explanation: "Figures should appear in the main text or appendices, not in the References section."
        });
      }
      
      // Check for copyright/permission note if needed
      const needsCopyright = figure.caption.includes('from') || 
                            figure.caption.includes('adapted') || 
                            figure.caption.includes('reprinted');
      
      if (needsCopyright && !figure.note.includes('Copyright') && !figure.note.includes('permission')) {
        issues.push({
          title: "Missing copyright information",
          description: `Figure ${figure.numberText} may need copyright attribution`,
          text: figure.caption.substring(0, 50),
          severity: "Minor",
          category: "figures",
          hasFix: false,
          explanation: "Figures adapted or reprinted from other sources need copyright attribution in the note."
        });
      }
    });
    
    return issues;
  }

  /**
   * Check numbering sequence
   */
  checkNumberingSequence(items, type) {
    const issues = [];
    
    if (items.length < 2) return issues;
    
    // Sort by position to check sequence
    const sortedItems = [...items].sort((a, b) => a.position - b.position);
    
    let expectedNumber = 1;
    for (let i = 0; i < sortedItems.length; i++) {
      const item = sortedItems[i];
      
      // Check if it's a sub-number (e.g., Table 2.1)
      const isSubNumber = item.numberText.includes('.');
      
      if (item.number !== expectedNumber) {
        if (!isSubNumber && Math.abs(item.number - expectedNumber) > 0.1) {
          issues.push({
            title: `${type} numbering sequence error`,
            description: `${type} ${item.numberText} appears out of sequence (expected ${type} ${expectedNumber})`,
            text: item.fullMatch,
            severity: "Major",
            category: type.toLowerCase() + 's',
            hasFix: true,
            fixAction: `fix${type}Numbering`,
            explanation: `${type}s must be numbered consecutively in the order they appear in the text.`
          });
          break; // Only report first sequence error
        }
      }
      
      if (!isSubNumber) {
        expectedNumber = item.number + 1;
      }
    }
    
    return issues;
  }

  /**
   * Validate in-text callouts
   */
  validateCallouts(tables, figures, text) {
    const issues = [];
    const reportedMissing = new Set();
    
    // Check table callouts
    tables.forEach(table => {
      const calloutPattern = new RegExp(`(?:see |See |shown in |displayed in |presented in )?Table\\s+${table.numberText}(?![\\d.])`, 'gi');
      const hasCallout = calloutPattern.test(text.substring(0, table.position));
      
      if (!hasCallout && !reportedMissing.has('table')) {
        issues.push({
          title: "Missing table callout",
          description: `Table ${table.numberText} is not referenced in the text before it appears`,
          text: `Table ${table.numberText}`,
          severity: "Major",
          category: "tables",
          hasFix: false,
          explanation: "Every table must be called out (mentioned) in the text before it appears."
        });
        reportedMissing.add('table');
      }
    });
    
    // Check figure callouts
    figures.forEach(figure => {
      const calloutPattern = new RegExp(`(?:see |See |shown in |displayed in |illustrated in )?(?:Figure|Fig\\.)\\s+${figure.numberText}(?![\\d.])`, 'gi');
      const hasCallout = calloutPattern.test(text.substring(0, figure.position));
      
      if (!hasCallout && !reportedMissing.has('figure')) {
        issues.push({
          title: "Missing figure callout",
          description: `Figure ${figure.numberText} is not referenced in the text before it appears`,
          text: `Figure ${figure.numberText}`,
          severity: "Major",
          category: "figures",
          hasFix: false,
          explanation: "Every figure must be called out (mentioned) in the text before it appears."
        });
        reportedMissing.add('figure');
      }
    });
    
    // Check for callouts to non-existent tables/figures
    const tableCalloutPattern = /(?:see |See |shown in |displayed in |presented in )?Table\s+(\d+\.?\d*)/gi;
    const existingTableNumbers = new Set(tables.map(t => t.numberText));
    
    let match;
    while ((match = tableCalloutPattern.exec(text)) !== null) {
      const calledNumber = match[1];
      if (!existingTableNumbers.has(calledNumber) && !reportedMissing.has('missing-table-' + calledNumber)) {
        issues.push({
          title: "Reference to non-existent table",
          description: `Text references Table ${calledNumber} which doesn't exist`,
          text: match[0],
          severity: "Critical",
          category: "tables",
          hasFix: false,
          explanation: "All tables referenced in the text must actually exist in the document."
        });
        reportedMissing.add('missing-table-' + calledNumber);
      }
    }
    
    const figureCalloutPattern = /(?:see |See |shown in |displayed in |illustrated in )?(?:Figure|Fig\.)\s+(\d+\.?\d*)/gi;
    const existingFigureNumbers = new Set(figures.map(f => f.numberText));
    
    while ((match = figureCalloutPattern.exec(text)) !== null) {
      const calledNumber = match[1];
      if (!existingFigureNumbers.has(calledNumber) && !reportedMissing.has('missing-figure-' + calledNumber)) {
        issues.push({
          title: "Reference to non-existent figure",
          description: `Text references Figure ${calledNumber} which doesn't exist`,
          text: match[0],
          severity: "Critical",
          category: "figures",
          hasFix: false,
          explanation: "All figures referenced in the text must actually exist in the document."
        });
        reportedMissing.add('missing-figure-' + calledNumber);
      }
    }
    
    return issues;
  }

  /**
   * Validate formatting compliance from document structure
   */
  validateFormattingCompliance(formatting) {
    const issues = [];
    
    // Check table formatting if available
    if (formatting.tables) {
      formatting.tables.forEach((table, index) => {
        // Check for vertical lines (APA doesn't use them)
        if (table.hasVerticalLines) {
          issues.push({
            title: "Vertical lines in table",
            description: `Table ${index + 1} contains vertical lines`,
            text: `Table ${index + 1}`,
            severity: "Minor",
            category: "tables",
            hasFix: true,
            fixAction: "removeTableVerticalLines",
            explanation: "APA style tables should not use vertical lines, only horizontal lines for clarity."
          });
        }
        
        // Check for borders
        if (table.hasFullBorders) {
          issues.push({
            title: "Excessive borders in table",
            description: `Table ${index + 1} has full borders instead of APA style`,
            text: `Table ${index + 1}`,
            severity: "Minor",
            category: "tables",
            hasFix: true,
            fixAction: "fixTableBorders",
            explanation: "APA tables use minimal borders: top and bottom of table, and below column headings."
          });
        }
      });
    }
    
    // Check figure formatting if available
    if (formatting.figures) {
      formatting.figures.forEach((figure, index) => {
        // Check image quality/resolution notes
        if (figure.lowResolution) {
          issues.push({
            title: "Low resolution figure",
            description: `Figure ${index + 1} appears to have low resolution`,
            text: `Figure ${index + 1}`,
            severity: "Minor",
            category: "figures",
            hasFix: false,
            explanation: "Figures should be high resolution for clarity in print and digital formats."
          });
        }
      });
    }
    
    return issues;
  }
}

'use client';

import { create } from 'zustand';
import { v4 as uuidv4 } from 'uuid';

// Import the enhanced APA analyzer
import { EnhancedAPAAnalyzer } from '@/utils/enhancedApaAnalyzer';

export const useDocumentStore = create((set, get) => ({
  // Document state - now includes rich formatting data
  documentText: null,
  documentHtml: null,
  documentName: null,
  documentFormatting: null, // Rich formatting data from server
  documentStructure: null,  // Document structure data
  documentStyles: null,     // Document styles
  originalDocumentBuffer: null, // Original document buffer for first upload
  currentDocumentBuffer: null,  // Current document buffer (with applied fixes)
  
  // Editor state
  editorContent: null,      // Slate.js editor content
  editorChanged: false,     // Track if editor content has changed
  documentStats: {
    wordCount: 0,
    charCount: 0,
    paragraphCount: 0,
    processingTime: 0
  },
  
  // Issues and analysis state
  issues: [],
  activeIssueId: null,
  showIssueHighlighting: true, // Persist issue highlighting state
  analysisScore: null,
  complianceDetails: null, // Detailed compliance information
  lastFixAppliedAt: null,
  
  // Processing state
  processingState: {
    isUploading: false,
    isAnalyzing: false,
    isSchedulingAnalysis: false,
    isApplyingFix: false,
    lastError: null,
    progress: 0,
    currentFixId: null,
    stage: null
  },
  
  // Upload document with server-side processing
  uploadDocument: async (file) => {
    const SERVER_URL = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3001' 
      : '';
    
    try {
      set({
        processingState: {
          ...get().processingState,
          isUploading: true,
          lastError: null,
          progress: 10,
          stage: 'Uploading document...'
        }
      });
      
      // Validate file on client side
      if (!file.name.toLowerCase().endsWith('.docx')) {
        throw new Error('Please upload a .docx file only');
      }
      
      if (file.size > 10 * 1024 * 1024) { // 10MB
        throw new Error('File size must be less than 10MB');
      }
      
      // Store the original file buffer for fixes
      const fileBuffer = await file.arrayBuffer();
      const uint8Array = new Uint8Array(fileBuffer);
      
      // Create FormData for file upload
      const formData = new FormData();
      formData.append('document', file);
      
      set({
        documentName: file.name,
        processingState: {
          ...get().processingState,
          progress: 20,
          stage: 'Sending to server...'
        }
      });
      
      // Send to server for processing
      const response = await fetch(`${SERVER_URL}/api/upload-docx`, {
        method: 'POST',
        body: formData,
        // Don't set Content-Type header - let browser set it with boundary
      });
      
      set({
        processingState: {
          ...get().processingState,
          progress: 60,
          stage: 'Processing document...'
        }
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Server error: ${response.status}`);
      }
      
      const result = await response.json();
      
      if (!result.success) {
        throw new Error(result.error || 'Server processing failed');
      }
      
      set({
        processingState: {
          ...get().processingState,
          progress: 80,
          stage: 'Extracting document data...'
        }
      });
      
      const { document: documentData } = result;
      
      // Validate that we got the expected data structure
      if (!documentData.html || !documentData.text) {
        console.warn('Incomplete document data from server:', documentData);
        throw new Error('Server returned incomplete document data');
      }
      
      // Calculate stats
      const words = documentData.processingInfo?.wordCount || 
                    documentData.text.trim().split(/\s+/).filter(Boolean).length;
      const chars = documentData.text.length;
      const paragraphs = documentData.formatting?.paragraphs?.length || 0;
      
      set({
        processingState: {
          ...get().processingState,
          progress: 90,
          stage: 'Finalizing...'
        }
      });
      
      // Store the rich document data including document buffers
      set(state => ({
        documentHtml: documentData.html,
        documentText: documentData.text,
        documentFormatting: documentData.formatting,
        documentStructure: documentData.structure,
        documentStyles: documentData.styles,
        originalDocumentBuffer: uint8Array, // Store original buffer
        currentDocumentBuffer: uint8Array,  // Initialize current buffer same as original
        documentStats: {
          wordCount: words,
          charCount: chars,
          paragraphCount: paragraphs,
          processingTime: documentData.processingInfo?.processingTime || 0
        },
        complianceDetails: documentData.formatting?.compliance || null,
        issues: [], // Clear previous issues
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          progress: 100,
          isUploading: false,
          stage: 'Upload complete'
        }
      }));
      
      // No automatic analysis - user must click "Run Check" button
      
      return true;
      
    } catch (error) {
      console.error('Error uploading document:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isUploading: false,
          lastError: error.message || 'Failed to process document',
          progress: 0,
          stage: null
        }
      }));
      
      return false;
    }
  },
  
  // Enhanced analysis using rich document data
  analyzeDocument: async () => {
    const { 
      documentText, 
      documentHtml, 
      documentFormatting, 
      documentStructure,
      documentStyles 
    } = get();
    
    if (!documentText) {
      return { success: false, error: 'No document data available' };
    }
    
    try {
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null,
          stage: 'Analyzing APA compliance...'
        }
      }));
      
      // Create comprehensive document data object
      const documentData = {
        text: documentText,
        html: documentHtml,
        formatting: documentFormatting,
        structure: documentStructure,
        styles: documentStyles
      };
      
      
      // Use enhanced analyzer with rich document data
      const analysisResults = await new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            const analyzer = new EnhancedAPAAnalyzer();
            const results = analyzer.analyzeDocument(documentData);
            resolve(results);
          } catch (error) {
            reject(error);
          }
        }, 100);
      });
      
      // Map results to store format and add IDs
      let issues = analysisResults.map(issue => ({
        id: uuidv4(),
        ...issue,
        // Ensure all required fields are present
        title: issue.title || 'Unknown Issue',
        description: issue.description || '',
        severity: issue.severity || 'Minor',
        category: issue.category || 'general',
        text: issue.text || null,
        location: issue.location || null,
        hasFix: issue.hasFix || false,
        fixAction: issue.fixAction || null,
        explanation: issue.explanation || issue.description || ''
      }));

      
      // Calculate enhanced compliance score
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;
      
      // Use server-provided compliance data if available
      let analysisScore;
      if (documentFormatting?.compliance?.overall !== undefined) {
        // Adjust server compliance score based on content issues
        const contentPenalty = criticalCount * 10 + majorCount * 5 + minorCount * 2;
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(documentFormatting.compliance.overall - contentPenalty)
        ));
      } else {
        // Fallback calculation
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))
        ));
      }
      
      set(state => ({
        issues,
        analysisScore,
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          isSchedulingAnalysis: false,
          stage: null
        }
      }));
      
      
      return { 
        success: true, 
        issueCount: issues.length,
        score: analysisScore,
        breakdown: { criticalCount, majorCount, minorCount }
      };
      
    } catch (error) {
      console.error('‚ùå Error analyzing document:', error);
      console.error('Error details:', error.message, error.stack);
      
      set(state => ({
        issues: [],
        analysisScore: null,
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          isSchedulingAnalysis: false,
          lastError: error.message || 'Document analysis failed',
          stage: null
        }
      }));
      
      return { success: false, error: error.message };
    }
  },
  
  // Auto-analyze after upload
  analyzeDocumentDebounced: async () => {
    // For server-side processing, we can analyze immediately since processing is faster
    return await get().analyzeDocument();
  },
  
  // Enhanced fix application with document regeneration
  applyFix: async (issueId) => {
    const { issues, documentHtml, documentText, documentFormatting } = get();
    const issue = issues.find(i => i.id === issueId);
    
    if (!issue || !issue.hasFix) {
      return false;
    }
    
    set(state => ({
      processingState: {
        ...state.processingState,
        isApplyingFix: true,
        currentFixId: issueId,
        stage: `Applying fix: ${issue.title}`
      }
    }));
    
    try {
      // Separate formatting fixes (server-side) from content fixes (client-side)
      const serverFormattingFixes = [
        'fixFont', 'fixFontSize', 'fixLineSpacing', 'fixMargins', 'fixIndentation'
      ];
      
      const clientContentFixes = [
        'addCitationComma', 'fixParentheticalConnector', 'fixEtAlFormatting', 
        'fixReferenceConnector', 'fixAllCapsHeading', 'addPageNumber',
        'sortReferences', 'fixTableTitleCase', 'fixFigureCaptionCase',
        'fixTableNoteFormat', 'removeRetrievedFrom', 'formatDOI',
        'addReferencePeriod', 'fixReferenceIndent',
        'addSerialComma', 'fixListNumbering', 'fixComplexSeries',
        'replaceLatinAbbr', 'fixPluralAbbr', 'capitalizeSubtitle',
        'fixBlockQuote', 'fixStatSymbol', 'fixNumberFormat', 'replaceBiasedTerm'
      ];
      
      if (clientContentFixes.includes(issue.fixAction)) {
        console.log(`üîß Applying client-side content fix: ${issue.fixAction}`);
        
        // Apply fix directly to current editor content (no server involved)
        const success = await get().applyClientSideFix(issue, issueId);
        
        return success;
        
      } else if (serverFormattingFixes.includes(issue.fixAction)) {
        console.log(`üîÑ Regenerating document with fix: ${issue.fixAction}`);
        
        // Apply the fix to the formatting data and regenerate HTML
        const result = await get().applyFormattingFix(issue, documentFormatting, documentText);
        
        if (result.success) {
          // Remove the fixed issue and update all document data
          const updatedIssues = issues.filter(i => i.id !== issueId);
          
          // Recalculate score
          const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
          const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
          const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
          
          const newScore = updatedIssues.length === 0 ? 100 : 
            Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
          
          // Calculate updated stats
          const words = result.text ? result.text.trim().split(/\s+/).filter(Boolean).length : 0;
          const chars = result.text ? result.text.length : 0;
          const paragraphs = result.formatting?.paragraphs?.length || 0;
          
          set(state => ({
            // Update all document data with the server response
            documentHtml: result.html,
            documentText: result.text,
            documentFormatting: result.formatting,
            documentStructure: result.structure,
            documentStyles: result.styles,
            currentDocumentBuffer: result.updatedBuffer || state.currentDocumentBuffer, // Update buffer for next fix
            documentStats: {
              wordCount: words,
              charCount: chars,
              paragraphCount: paragraphs,
              processingTime: state.documentStats.processingTime // Keep original processing time
            },
            complianceDetails: result.formatting?.compliance || null,
            issues: updatedIssues,
            analysisScore: newScore,
            lastFixAppliedAt: Date.now(),
            activeIssueId: null,
            processingState: {
              ...state.processingState,
              isApplyingFix: false,
              currentFixId: null,
              stage: null
            }
          }));
          
          // Clear the lastFixAppliedAt after a brief delay to allow re-triggering
          setTimeout(() => {
            set(state => ({
              lastFixAppliedAt: null
            }));
          }, 100);
          
          return true;
        }
      } else {
        // Use the original text-based fix approach for content issues
        let updatedHtml = documentHtml;
        let updatedText = documentText;
        let contentChanged = false;
        
        const success = await get().applySpecificFix(issue, updatedHtml, updatedText);
        
        if (success.changed) {
          updatedHtml = success.html;
          updatedText = success.text;
          contentChanged = true;
        }
        
        // Remove the fixed issue
        const updatedIssues = issues.filter(i => i.id !== issueId);
        
        // Recalculate score
        const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
        const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
        const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
        
        const newScore = updatedIssues.length === 0 ? 100 : 
          Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
        
        set(state => ({
          documentText: updatedText,
          documentHtml: updatedHtml,
          issues: updatedIssues,
          analysisScore: newScore,
          lastFixAppliedAt: contentChanged ? Date.now() : state.lastFixAppliedAt,
          activeIssueId: null,
          processingState: {
            ...state.processingState,
            isApplyingFix: false,
            currentFixId: null,
            stage: null
          }
        }));
        
        // Clear the lastFixAppliedAt after a brief delay if content changed
        if (contentChanged) {
          setTimeout(() => {
            set(state => ({
              lastFixAppliedAt: null
            }));
          }, 100);
        }
        
        return true;
      }
      
    } catch (error) {
      console.error('Error applying fix:', error);
      
      // Still remove the issue even if fix failed
      const updatedIssues = issues.filter(i => i.id !== issueId);
      
      set(state => ({
        issues: updatedIssues,
        activeIssueId: null,
        processingState: {
          ...state.processingState,
          isApplyingFix: false,
          currentFixId: null,
          lastError: `Failed to apply fix: ${error.message}`,
          stage: null
        }
      }));
      
      return false;
    }
  },

  // Apply client-side fix directly to editor content (no server involved)
  applyClientSideFix: async (issue, issueId) => {
    const { issues } = get();
    
    try {
      console.log(`üîß Applying client-side fix: ${issue.fixAction} for issue: ${issue.title}`);
      console.log(`üìù Original text: "${issue.text}"`);
      
      // Calculate the replacement text
      let replacementText = '';
      
      switch (issue.fixAction) {
        case 'addCitationComma':
          replacementText = issue.text.replace(/\(([^,)]+)\s+(\d{4})\)/g, '($1, $2)');
          break;
        case 'fixParentheticalConnector':
          replacementText = issue.text.replace(' and ', ' & ');
          break;
        case 'fixEtAlFormatting':
          replacementText = issue.text.replace(/\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, '($1, et al., $2)');
          break;
        case 'fixReferenceConnector':
          replacementText = issue.text.replace(/, and /g, ', & ');
          break;
        case 'fixAllCapsHeading':
          replacementText = issue.text.toLowerCase()
            .split(' ')
            .map((word, index) => {
              const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
              if (index === 0 || !smallWords.includes(word)) {
                return word.charAt(0).toUpperCase() + word.slice(1);
              }
              return word;
            })
            .join(' ');
          break;
        case 'addPageNumber':
          if (issue.text.includes('(') && issue.text.includes(')')) {
            replacementText = issue.text.replace(/\)$/, ', p. 1)');
          }
          break;
          
        // New reference fixes
        case 'sortReferences':
          // This requires reorganizing the entire references section
          replacementText = this.sortReferencesSection(issue.text);
          break;
          
        case 'addReferencePeriod':
          replacementText = issue.text.trim();
          if (!replacementText.endsWith('.')) {
            replacementText += '.';
          }
          break;
          
        case 'removeRetrievedFrom':
          replacementText = issue.text.replace(/Retrieved from\s*/gi, '');
          break;
          
        case 'formatDOI':
          // Convert doi:xxxxx to https://doi.org/xxxxx
          replacementText = issue.text.replace(/doi:\s*([^\s]+)/gi, 'https://doi.org/$1');
          break;
          
        // Table/Figure fixes
        case 'fixTableTitleCase':
          replacementText = this.convertToTitleCase(issue.text);
          break;
          
        case 'fixFigureCaptionCase':
          replacementText = this.convertToSentenceCase(issue.text);
          break;
          
        case 'fixTableNoteFormat':
          if (!issue.text.startsWith('Note.')) {
            replacementText = 'Note. ' + issue.text;
          } else {
            replacementText = issue.text;
          }
          break;
          
        // Lists and seriation fixes
        case 'addSerialComma':
          // Add comma before 'and' in series
          replacementText = issue.text.replace(/(\w+)\s+and\s+/, '$1, and ');
          break;
          
        case 'fixListNumbering':
          // This would require context of the whole list
          console.log('List numbering fix requires document-level changes');
          replacementText = issue.text;
          break;
          
        case 'fixComplexSeries':
          // Add semicolon before 'and' in complex series
          replacementText = issue.text.replace(/;\s*and\s+/, '; and ');
          break;
          
        // Abbreviation fixes
        case 'replaceLatinAbbr':
          if (issue.fixValue) {
            replacementText = issue.text.replace(issue.fixValue.original, issue.fixValue.replacement);
          }
          break;
          
        case 'fixPluralAbbr':
          // Remove apostrophe from plural abbreviations
          replacementText = issue.text.replace(/'s\b/g, 's');
          break;
          
        // Title/heading fixes
        case 'capitalizeSubtitle':
          // Capitalize first word after colon
          replacementText = issue.text.replace(/(:\s*)([a-z])/g, (match, colon, letter) => colon + letter.toUpperCase());
          break;
          
        // Quotation fixes
        case 'fixBlockQuote':
          // Add block quote formatting indicator
          replacementText = '\n' + issue.text + '\n';
          break;
          
        // Statistical fixes
        case 'fixStatSymbol':
          // Italicize statistical symbols
          if (issue.fixValue && issue.fixValue.symbol) {
            replacementText = issue.text.replace(new RegExp(`\\b${issue.fixValue.symbol}\\b`, 'g'), `*${issue.fixValue.symbol}*`);
          }
          break;
          
        case 'fixNumberFormat':
          // Fix number formatting issues
          if (issue.fixValue && issue.fixValue.corrected) {
            replacementText = issue.text.replace(issue.fixValue.original, issue.fixValue.corrected);
          }
          break;
          
        // Bias-free language fixes
        case 'replaceBiasedTerm':
          if (issue.fixValue && issue.fixValue.replacement) {
            replacementText = issue.text.replace(new RegExp(issue.fixValue.term, 'gi'), issue.fixValue.replacement);
          }
          break;
          
        default:
          console.warn(`Unsupported client-side fix: ${issue.fixAction}`);
          return false;
      }
      
      if (replacementText && replacementText !== issue.text) {
        console.log(`üìù Replacement text: "${replacementText}"`);
        
        // Signal to DocumentEditor to apply the text replacement
        // We'll use a custom event or store method to communicate with the editor
        window.dispatchEvent(new CustomEvent('applyTextReplacement', {
          detail: {
            originalText: issue.text,
            replacementText: replacementText,
            issueId: issueId
          }
        }));
        
        // Remove the issue from the list
        const updatedIssues = issues.filter(i => i.id !== issueId);
        
        // Recalculate score
        const criticalCount = updatedIssues.filter(i => i.severity === 'Critical').length;
        const majorCount = updatedIssues.filter(i => i.severity === 'Major').length;
        const minorCount = updatedIssues.filter(i => i.severity === 'Minor').length;
        
        const newScore = updatedIssues.length === 0 ? 100 : 
          Math.max(0, Math.min(100, Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))));
        
        set({
          issues: updatedIssues,
          analysisScore: newScore,
          activeIssueId: null,
          processingState: {
            ...get().processingState,
            isApplyingFix: false,
            currentFixId: null,
            stage: null
          }
        });
        
        return true;
      }
      
      return false;
      
    } catch (error) {
      console.error('Error applying client-side fix:', error);
      
      set({
        activeIssueId: null,
        processingState: {
          ...get().processingState,
          isApplyingFix: false,
          currentFixId: null,
          lastError: `Failed to apply fix: ${error.message}`,
          stage: null
        }
      });
      
      return false;
    }
  },
  
  // Apply specific fix logic (same as before)
  applySpecificFix: async (issue, html, text) => {
    let updatedHtml = html;
    let updatedText = text;
    let changed = false;
    
    try {
      switch (issue.fixAction) {
        case 'addCitationComma':
          if (issue.text) {
            const fixedText = issue.text.replace(
              /\(([^,)]+)\s+(\d{4})\)/g, 
              '($1, $2)'
            );
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixParentheticalConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(' and ', ' & ');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'addPageNumber':
          if (issue.text && issue.text.includes('(') && issue.text.includes(')')) {
            const fixedText = issue.text.replace(/\)$/, ', p. 1)');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixEtAlFormatting':
          if (issue.text) {
            // Fix et al. formatting: (Smith et al., 2021) ‚Üí (Smith, et al., 2021)
            const fixedText = issue.text.replace(
              /\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, 
              '($1, et al., $2)'
            );
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixReferenceConnector':
          if (issue.text) {
            // Fix reference connector: "Author, A., and Author, B." ‚Üí "Author, A., & Author, B."
            const fixedText = issue.text.replace(/, and /g, ', & ');
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        case 'fixAllCapsHeading':
          if (issue.text) {
            // Convert ALL CAPS heading to Title Case
            const fixedText = issue.text.toLowerCase()
              .split(' ')
              .map(word => {
                // Capitalize first letter of each word, except small words (unless first word)
                const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
                const isFirstWord = word === issue.text.toLowerCase().split(' ')[0];
                
                if (isFirstWord || !smallWords.includes(word)) {
                  return word.charAt(0).toUpperCase() + word.slice(1);
                }
                return word;
              })
              .join(' ');
            
            updatedText = text.replace(issue.text, fixedText);
            updatedHtml = html.replace(issue.text, fixedText);
            changed = updatedText !== text;
          }
          break;
          
        default:
          break;
      }
      
      return { html: updatedHtml, text: updatedText, changed };
      
    } catch (error) {
      console.error('Error in applySpecificFix:', error);
      return { html, text, changed: false };
    }
  },
  
  // Apply formatting fix via server-side DOCX modification (Memory-based)
  applyFormattingFix: async (issue, originalFormatting, documentText) => {
    const SERVER_URL = process.env.NODE_ENV === 'development' 
      ? 'http://localhost:3001' 
      : '';
    
    const { currentDocumentBuffer, documentName } = get();
    
    try {
      console.log(`üîß Applying memory-based formatting fix: ${issue.fixAction}`);
      
      if (!currentDocumentBuffer) {
        throw new Error('No document buffer available for document modification');
      }
      
      // Determine fix value based on action
      let fixValue;
      switch (issue.fixAction) {
        // Formatting fixes
        case 'fixFont':
          fixValue = 'Times New Roman';
          break;
        case 'fixFontSize':
          fixValue = 24; // 24 half-points = 12pt
          break;
        case 'fixLineSpacing':
          fixValue = 480; // 480 = double spacing in Word
          break;
        case 'fixMargins':
          fixValue = { top: 1.0, bottom: 1.0, left: 1.0, right: 1.0 };
          break;
        case 'fixIndentation':
          fixValue = 0.5;
          break;

        // Text-based content fixes
        case 'addCitationComma':
          if (issue.text) {
            const fixedText = issue.text.replace(/\(([^,)]+)\s+(\d{4})\)/g, '($1, $2)');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixParentheticalConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(' and ', ' & ');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixEtAlFormatting':
          if (issue.text) {
            const fixedText = issue.text.replace(/\(([^,)]+)\s+et\s+al\.,\s*(\d{4})\)/g, '($1, et al., $2)');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixReferenceConnector':
          if (issue.text) {
            const fixedText = issue.text.replace(/, and /g, ', & ');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'fixAllCapsHeading':
          if (issue.text) {
            const fixedText = issue.text.toLowerCase()
              .split(' ')
              .map(word => {
                const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet'];
                const isFirstWord = word === issue.text.toLowerCase().split(' ')[0];
                
                if (isFirstWord || !smallWords.includes(word)) {
                  return word.charAt(0).toUpperCase() + word.slice(1);
                }
                return word;
              })
              .join(' ');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        case 'addPageNumber':
          if (issue.text && issue.text.includes('(') && issue.text.includes(')')) {
            const fixedText = issue.text.replace(/\)$/, ', p. 1)');
            fixValue = { originalText: issue.text, replacementText: fixedText };
          }
          break;
        default:
          throw new Error(`Unknown fix action: ${issue.fixAction}`);
      }
      
      if (!fixValue) {
        throw new Error(`Could not determine fix value for action: ${issue.fixAction}`);
      }
      
      console.log(`üí° Sending fix request to server: ${issue.fixAction} = ${JSON.stringify(fixValue)}`);
      
      // First, test if server is accessible
      try {
        const healthCheck = await fetch(`${SERVER_URL}/api/health`);
        console.log('üè• Health check response:', healthCheck.status);
        if (!healthCheck.ok) {
          throw new Error(`Server health check failed: ${healthCheck.status}`);
        }
      } catch (healthError) {
        console.error('‚ùå Server is not accessible:', healthError);
        throw new Error(`Server is not accessible: ${healthError.message}. Make sure the backend server is running on port 3001.`);
      }
      
      // Convert Uint8Array to base64 for JSON transport
      const base64Buffer = btoa(String.fromCharCode(...currentDocumentBuffer));
      
      // Send fix request to server with document buffer
      console.log('üöÄ Sending fix request to server:', {
        fixAction: issue.fixAction,
        fixValue: fixValue,
        fixValueType: typeof fixValue,
        bufferSize: base64Buffer.length,
        filename: documentName
      });
      
      const response = await fetch(`${SERVER_URL}/api/apply-fix`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          documentBuffer: base64Buffer,
          fixAction: issue.fixAction,
          fixValue: fixValue,
          originalFilename: documentName
        })
      });
      
      console.log('üì° Server response status:', response.status);
      console.log('üì° Server response headers:', Object.fromEntries(response.headers.entries()));
      
      if (!response.ok) {
        let errorData;
        const contentType = response.headers.get('content-type');
        console.log('Response content-type:', contentType);
        
        try {
          const responseText = await response.text();
          console.log('Raw response text:', responseText);
          
          if (contentType && contentType.includes('application/json') && responseText) {
            errorData = JSON.parse(responseText);
          } else {
            errorData = { error: responseText || 'Unknown server error' };
          }
        } catch (parseError) {
          console.error('Error parsing server response:', parseError);
          errorData = { error: 'Failed to parse server error response' };
        }
        
        console.error('‚ùå Server error response:', errorData);
        console.error('‚ùå Full response details:', {
          status: response.status,
          statusText: response.statusText,
          url: response.url,
          headers: Object.fromEntries(response.headers.entries())
        });
        
        throw new Error(errorData.error || `Server error: ${response.status} ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log('‚úÖ Server fix response:', {
        success: result.success,
        fixApplied: result.fixApplied,
        hasDocument: !!result.document,
        hasBuffer: !!result.modifiedDocumentBuffer
      });
      
      if (!result.success) {
        throw new Error(result.error || 'Server failed to apply fix');
      }
      
      console.log('üéâ Memory-based fix applied successfully');
      
      // Convert the returned buffer back to Uint8Array for next iteration
      let updatedBuffer = null;
      if (result.modifiedDocumentBuffer) {
        const binaryString = atob(result.modifiedDocumentBuffer);
        updatedBuffer = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          updatedBuffer[i] = binaryString.charCodeAt(i);
        }
      }
      
      // Return the updated document data from server
      return {
        success: true,
        html: result.document.html,
        text: result.document.text,
        formatting: result.document.formatting,
        structure: result.document.structure,
        styles: result.document.styles,
        updatedBuffer: updatedBuffer // Include updated buffer for cumulative fixes
      };
      
    } catch (error) {
      console.error('Error applying memory-based formatting fix:', error);
      return {
        success: false,
        error: error.message
      };
    }
  },
  
  // Set active issue and scroll to it
  setActiveIssue: (issueId) => {
    set({ activeIssueId: issueId });
    
    // Scroll to the issue in the document
    if (issueId) {
      setTimeout(() => {
        const issueElement = document.querySelector(`[data-issue-id="${issueId}"]`);
        if (issueElement) {
          issueElement.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center',
            inline: 'nearest'
          });
          console.log(`üìç Scrolled to issue: ${issueId}`);
        } else {
          console.warn(`‚ö†Ô∏è Could not find element for issue: ${issueId}`);
        }
      }, 100); // Small delay to ensure DOM is updated
    }
  },

  // Toggle issue highlighting
  toggleIssueHighlighting: () => {
    set(state => {
      const newState = !state.showIssueHighlighting;
      console.log('üîÑ Store: Toggling issue highlighting from', state.showIssueHighlighting, 'to', newState);
      return { showIssueHighlighting: newState };
    });
  },

  
  // Get analysis summary with rich formatting data
  getAnalysisSummary: () => {
    const { 
      issues, 
      analysisScore, 
      documentStats, 
      documentFormatting,
      complianceDetails 
    } = get();
    
    const severityCounts = issues.reduce((acc, issue) => {
      acc[issue.severity] = (acc[issue.severity] || 0) + 1;
      return acc;
    }, {});
    
    const categoryCounts = issues.reduce((acc, issue) => {
      acc[issue.category] = (acc[issue.category] || 0) + 1;
      return acc;
    }, {});
    
    return {
      score: analysisScore,
      totalIssues: issues.length,
      severity: severityCounts,
      categories: categoryCounts,
      documentInfo: {
        ...documentStats,
        hasRichFormatting: !!documentFormatting,
        formattingCompliance: complianceDetails
      },
      compliance: complianceDetails
    };
  },

  // Editor management functions
  setEditorContent: (content) => {
    set({ 
      editorContent: content, 
      editorChanged: true 
    });
  },


  // Convert editor content back to text for analysis
  getTextFromEditorContent: (editorContent) => {
    if (!editorContent || !Array.isArray(editorContent)) return '';
    
    return editorContent.map(node => {
      if (node.children) {
        return node.children.map(child => child.text || '').join('');
      }
      return node.text || '';
    }).join('\n');
  },

  // Real-time analysis for editor changes
  analyzeEditorContent: async (editorContent, preservedFormatting = null) => {
    if (!editorContent) return { success: false, error: 'No editor content' };
    
    const { documentHtml, documentFormatting, documentStructure, documentStyles } = get();
    
    // Use preserved formatting if provided, otherwise fall back to stored formatting
    const formattingToUse = preservedFormatting || documentFormatting;
    
    try {
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: true,
          lastError: null,
          stage: 'Analyzing edited content...'
        }
      }));

      // Convert editor content to text
      const text = get().getTextFromEditorContent(editorContent);
      
      if (!text || text.trim().length < 10) {
        set(state => ({
          issues: [],
          analysisScore: 100,
          processingState: {
            ...state.processingState,
            isAnalyzing: false,
            stage: null
          }
        }));
        return { success: true, issueCount: 0 };
      }

      // Create comprehensive document data object
      const documentData = {
        text: text,
        html: documentHtml,
        formatting: formattingToUse, // Use preserved formatting
        structure: documentStructure,
        styles: documentStyles
      };

      console.log('üìä Analysis using formatting data:', {
        hasFormatting: !!formattingToUse,
        formattingSource: preservedFormatting ? 'preserved' : 'stored',
        paragraphCount: formattingToUse?.paragraphs?.length || 0
      });

      // Use enhanced analyzer with rich document data
      const analysisResults = await new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            const analyzer = new EnhancedAPAAnalyzer();
            const results = analyzer.analyzeDocument(documentData);
            resolve(results);
          } catch (error) {
            reject(error);
          }
        }, 100);
      });

      // Map results to store format and add IDs
      let issues = analysisResults.map(issue => ({
        id: uuidv4(),
        ...issue,
        title: issue.title || 'Unknown Issue',
        description: issue.description || '',
        severity: issue.severity || 'Minor',
        category: issue.category || 'general',
        text: issue.text || null,
        location: issue.location || null,
        hasFix: issue.hasFix || false,
        fixAction: issue.fixAction || null,
        explanation: issue.explanation || issue.description || ''
      }));


      // Calculate enhanced compliance score
      const criticalCount = issues.filter(i => i.severity === 'Critical').length;
      const majorCount = issues.filter(i => i.severity === 'Major').length;
      const minorCount = issues.filter(i => i.severity === 'Minor').length;

      let analysisScore;
      if (formattingToUse?.compliance?.overall !== undefined) {
        const contentPenalty = criticalCount * 10 + majorCount * 5 + minorCount * 2;
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(formattingToUse.compliance.overall - contentPenalty)
        ));
      } else {
        analysisScore = Math.max(0, Math.min(100, 
          Math.round(100 - (criticalCount * 8 + majorCount * 4 + minorCount * 1.5))
        ));
      }

      // Update stats from editor content
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      const chars = text.length;
      const paragraphs = text.split('\n').filter(p => p.trim().length > 0).length;

      set(state => ({
        // Don't update documentText to avoid triggering editor regeneration
        issues,
        analysisScore,
        documentStats: {
          ...state.documentStats,
          wordCount: words,
          charCount: chars,
          paragraphCount: paragraphs
        },
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          stage: null
        },
        editorChanged: false // Reset change flag
      }));

      console.log(`‚úÖ Editor content analysis complete: ${issues.length} issues`);
      
      return { 
        success: true, 
        issueCount: issues.length,
        score: analysisScore,
        breakdown: { criticalCount, majorCount, minorCount }
      };

    } catch (error) {
      console.error('‚ùå Error analyzing editor content:', error);
      
      set(state => ({
        processingState: {
          ...state.processingState,
          isAnalyzing: false,
          lastError: error.message || 'Editor content analysis failed',
          stage: null
        }
      }));

      return { success: false, error: error.message };
    }
  },

  // Helper method: Convert text to title case
  convertToTitleCase: (text) => {
    const smallWords = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'for', 'if', 'in', 
                       'nor', 'of', 'on', 'or', 'so', 'the', 'to', 'up', 'yet', 'with'];
    
    return text.split(' ').map((word, index, array) => {
      const isFirstOrLast = index === 0 || index === array.length - 1;
      const lowerWord = word.toLowerCase();
      
      if (isFirstOrLast || !smallWords.includes(lowerWord)) {
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }
      return lowerWord;
    }).join(' ');
  },
  
  // Helper method: Convert text to sentence case
  convertToSentenceCase: (text) => {
    // Keep first letter capitalized, rest lowercase except proper nouns/acronyms
    return text.charAt(0).toUpperCase() + 
           text.slice(1).toLowerCase()
               .replace(/\b[A-Z]{2,}\b/g, match => match) // Keep acronyms
               .replace(/:\s*([a-z])/g, (match, letter) => ': ' + letter.toUpperCase()); // Capitalize after colon
  },
  
  // Helper method: Sort references section alphabetically
  sortReferencesSection: (referencesText) => {
    // Parse individual references
    const entries = [];
    const lines = referencesText.split('\n');
    let currentEntry = '';
    
    lines.forEach(line => {
      if (line.trim() && /^[A-Z]/.test(line.trim()) && currentEntry) {
        entries.push(currentEntry.trim());
        currentEntry = line;
      } else if (line.trim()) {
        currentEntry += (currentEntry ? ' ' : '') + line;
      }
    });
    
    if (currentEntry) {
      entries.push(currentEntry.trim());
    }
    
    // Sort alphabetically by first author's surname
    entries.sort((a, b) => {
      const authorA = a.match(/^([A-Z][a-zA-Z'-]+)/)?.[1] || '';
      const authorB = b.match(/^([A-Z][a-zA-Z'-]+)/)?.[1] || '';
      return authorA.localeCompare(authorB);
    });
    
    return entries.join('\n\n');
  },

  // Export document
  exportDocument: async (format) => {
    const { documentHtml, documentName, currentDocumentBuffer } = get();
    
    if (!documentHtml) {
      alert('No document to export');
      return false;
    }
    
    try {
      if (format === 'html') {
        // HTML export
        const fullHtml = `
          <!DOCTYPE html>
          <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Document Export</title>
            <style>
              body { 
                font-family: "Times New Roman", Times, serif; 
                font-size: 12pt; 
                line-height: 1.5; 
                margin: 1in; 
              }
            </style>
          </head>
          <body>${documentHtml}</body>
          </html>
        `;
        
        const blob = new Blob([fullHtml], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = documentName ? 
          documentName.replace('.docx', '_APA_formatted.html') : 
          'apa_formatted_document.html';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        return true;
      } else if (format === 'docx' && currentDocumentBuffer) {
        // DOCX export - use the modified buffer
        const blob = new Blob([currentDocumentBuffer], { 
          type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' 
        });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = documentName ? 
          documentName.replace('.docx', '_APA_fixed.docx') : 
          'apa_fixed_document.docx';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        return true;
      } else {
        throw new Error('Unsupported export format or missing document buffer');
      }
    } catch (error) {
      console.error('Export failed:', error);
      throw error;
    }
  }
}));